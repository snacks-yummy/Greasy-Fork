// ==UserScript==
// @name         æ–°æ ‡ç­¾é¡µPro-å…¨ç«™ç½‘é¡µå¢å¼ºå·¥å…·ç®±
// @namespace    https://github.com/Snack-Zhou
// @version      1.5.343
// @author       é›¶é£Ÿæ€ä¹ˆåƒéƒ½ä¸èƒ–
// @description  å…¨ç«™ç½‘é¡µå¢å¼ºï¼šæ–°æ ‡ç­¾é¡µæ‰“å¼€ï½œç›´è¾¾/å»é‡å®šå‘/çŸ­é“¾è¿˜åŸï½œæ–‡æœ¬è£¸é“¾è½¬é“¾æ¥ï½œç½‘ç›˜æå–ç è¯†åˆ«/è‡ªåŠ¨å¡«å……ï¼ˆå†å²/æ”¶è—ï¼‰ï½œæ‚¬æµ®æç¤ºçœŸå®é“¾æ¥/å®Œæ•´URLï½œå·²è®¿é—®å˜è‰²/ç»Ÿè®¡ï½œè‡ªåŠ¨å±•å¼€ï½œç½®é¡¶/ç½®åº•ï½œé€šç”¨ç™»å½•é®æŒ¡ï½œç™¾åº¦æœç´¢å‡€åŒ–/å¸ƒå±€/å±è”½AI/å®˜ç½‘ç½®é¡¶ï½œCSDN å¼ºåŠ›å¤åˆ¶/å‡€åŒ–/è§£é”ï½œQQé‚®ç®±å»å¹¿å‘Šï½œè®¾ç½®é¢æ¿/å¯¼å…¥å¯¼å‡º/å®¡è®¡/è°ƒè¯•/é»‘åå•/æ€§èƒ½ä¿æŠ¤

// å¼•ç”¨ä¸è‡´è°¢ï¼ˆå‚è€ƒè„šæœ¬æ¸…å•ï¼‰ï¼š
// ï¼ˆ1ï¼‰æ–°æ ‡ç­¾é¡µæ‰“å¼€ï¼ˆX.I.Uï¼‰
// ï¼ˆ2ï¼‰è¿”å›é¡¶éƒ¨å’Œåº•éƒ¨-ç¾åŒ–ç‰ˆï¼ˆbzw1204ï¼‰
// ï¼ˆ3ï¼‰ç™¾åº¦å…¨é¡µé¢æ ·å¼ä¼˜åŒ–-å»å¹¿å‘Šï¼Œæ·±è‰²æ¨¡å¼ï¼ˆAi-Rcccccccc (Enhanced)ï¼‰
// ï¼ˆ4ï¼‰CSDNä¼˜åŒ–ï¼ˆWhiteSevsï¼‰
// ï¼ˆ5ï¼‰Links Helperï¼ˆğŸ”— é“¾æ¥åŠ©æ‰‹ï¼‰ï¼ˆPipecraftï¼‰
// ï¼ˆ6ï¼‰çŸ¥ä¹å¢å¼ºï¼ˆXIU2ï¼‰
// ï¼ˆ7ï¼‰è·³è½¬é“¾æ¥ä¿®å¤ï¼ˆç§»é™¤é‡å®šå‘å¤–é“¾ç›´è¾¾ï¼‰ï¼ˆmaomao1996ï¼‰
// ï¼ˆ8ï¼‰ç½‘ç›˜æœ‰æ•ˆæ€§æ£€æŸ¥ï¼ˆLeon406ï¼‰
// ï¼ˆ9ï¼‰é“¾æ¥åŠ©æ‰‹ï¼ˆä¸€ä¸ªåŒ—ä¸ƒï¼‰
// ï¼ˆ10ï¼‰AC-baidu-é‡å®šå‘ä¼˜åŒ–ç™¾åº¦æœç‹—è°·æ­Œå¿…åº”æœç´¢_favicon_åŒåˆ—ï¼ˆinDarknessï¼‰
// ï¼ˆ11ï¼‰ç½‘ç›˜æ™ºèƒ½è¯†åˆ«åŠ©æ‰‹ï¼ˆğŸ¥‡_ğŸ¥‡ï¼‰
// ï¼ˆ12ï¼‰ã€ŒCSDNGreenerã€CSDNå¹¿å‘Šå®Œå…¨è¿‡æ»¤ / å…ç™»å½• / ä¸ªæ€§åŒ–æ’ç‰ˆï¼ˆadlered_ï¼‰
// ï¼ˆ13ï¼‰å»é™¤é“¾æ¥é‡å®šå‘ï¼ˆMeriel Varenï¼‰
// ï¼ˆ14ï¼‰å·²æµè§ˆé“¾æ¥å˜è‰²ï¼ˆddddddï¼‰
// ï¼ˆ15ï¼‰è‡ªåŠ¨å±•å¼€ï¼ˆAutoUnfoldï¼‰ï¼ˆåŒå­¦çš„éªšå¹´ï¼‰ï¼ˆé€šè¿‡ @resource å¼•å…¥å¹¶å°è£…ä¸ºæ¨¡å—ï¼‰
// ï¼ˆ16ï¼‰redirect å¤–é“¾è·³è½¬ï¼ˆsakura-flutterï¼‰
// @match        *://*/*
// @icon         data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%20viewBox%3D%270%200%20128%20128%27%3E%3Cdefs%3E%3ClinearGradient%20id%3D%27g%27%20x1%3D%270%27%20y1%3D%270%27%20x2%3D%271%27%20y2%3D%271%27%3E%3Cstop%20offset%3D%270%27%20stop-color%3D%27%237c3aed%27%2F%3E%3Cstop%20offset%3D%271%27%20stop-color%3D%27%2306b6d4%27%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Crect%20x%3D%278%27%20y%3D%278%27%20width%3D%27112%27%20height%3D%27112%27%20rx%3D%2728%27%20fill%3D%27url(%23g)%27%2F%3E%3Crect%20x%3D%2730%27%20y%3D%2754%27%20width%3D%2768%27%20height%3D%2744%27%20rx%3D%2714%27%20fill%3D%27%23ffffff%27%20opacity%3D%270.95%27%2F%3E%3Crect%20x%3D%2744%27%20y%3D%2738%27%20width%3D%2740%27%20height%3D%2722%27%20rx%3D%2711%27%20fill%3D%27%23ffffff%27%20opacity%3D%270.95%27%2F%3E%3Cpath%20d%3D%27M30%2070h68%27%20stroke%3D%27%230f172a%27%20stroke-width%3D%276%27%20opacity%3D%270.18%27%2F%3E%3Ccircle%20cx%3D%2754%27%20cy%3D%2782%27%20r%3D%275%27%20fill%3D%27%230f172a%27%20opacity%3D%270.22%27%2F%3E%3Ccircle%20cx%3D%2774%27%20cy%3D%2782%27%20r%3D%275%27%20fill%3D%27%230f172a%27%20opacity%3D%270.22%27%2F%3E%3C%2Fsvg%3E
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_deleteValue
// @grant        GM_registerMenuCommand
// @grant        GM_openInTab
// @grant        GM_addStyle
// @grant        GM_addValueChangeListener
// @grant        GM_removeValueChangeListener
// @grant        GM_setClipboard
// @grant        GM_getResourceText
// @grant        GM_xmlhttpRequest
// @require      https://update.greasyfork.org/scripts/562281/1737308/%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%EF%BC%88%E5%A4%8D%E5%88%B6%E6%89%A9%E5%B1%95%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%89.js
// @license      GPL-3.0 License
// @run-at       document-start
// @exclude      https://accounts.google.com/*
// @exclude      https://accounts.google.com.hk/*
// ==/UserScript==

        (function() {
            'use strict';

            try {
                if (window.top === window.self) {
                    const host = String(location.host || '');
                    const pathname = String(location.pathname || '');
                    if (host === 'www.baidu.com' && pathname === '/s') {
                        const getGM = typeof GM_getValue === 'function' ? GM_getValue : null;
                        const styleOptimizeEnabled = getGM ? Boolean(getGM('baiduStyleOptimizeEnabled', true)) : true;
                        const hideRightContent = getGM ? Boolean(getGM('baiduHideRightContent', true)) : true;
                        const cleanAdsEnabled = getGM ? Boolean(getGM('baiduCleanAdsEnabled', true)) : true;
                        const hideAiEnabled = getGM ? Boolean(getGM('baiduHideAiAnswerEnabled', true)) : true;
                        const layoutMode = getGM ? String(getGM('baiduLayoutMode', 'single') || '') : 'single';
                        const darkEnabled = getGM ? Boolean(getGM('baiduFloatingDarkMode', false)) : false;
                        const root = document.documentElement;
                        if (root && root.classList) {
                            const mode = String(layoutMode || '').toLowerCase() === 'double' ? 'double' : 'single';
                            root.classList.toggle('single-column', mode === 'single');
                            root.classList.toggle('double-column', mode === 'double');
                            root.classList.toggle('newtab-pro-baidu-dark-mode', darkEnabled);
                            root.classList.toggle('newtab-pro-hide-ai', hideAiEnabled);
                        }
                        const cssRules = [];
                        if (styleOptimizeEnabled) {
                            cssRules.push('#wrapper_wrapper,#container{max-width:100% !important;padding:0 !important;box-sizing:border-box !important;}');
                            cssRules.push('#s_form,#u{display:none !important;}');
                            cssRules.push('#head{height:60px !important;display:flex !important;align-items:center !important;justify-content:center !important;background:#fff !important;border-bottom:1px solid #e4e7ed !important;}');
                            cssRules.push('#container{padding-top:10px !important;}');
                            cssRules.push(':root.single-column #content_left,:root.single-column #container.sam_newgrid,:root.single-column .wrapper_new #content_left{width:100% !important;max-width:1200px !important;margin:0 auto !important;padding:0 !important;box-sizing:border-box !important;}');
                            cssRules.push(':root.double-column #content_left,:root.double-column #container.sam_newgrid,:root.double-column .wrapper_new #content_left{width:100% !important;max-width:1400px !important;margin:0 auto !important;padding:10px !important;box-sizing:border-box !important;}');
                            cssRules.push('.c-container,.result-op,.result{border-radius:10px !important;box-shadow:0 3px 10px rgba(0,0,0,0.08) !important;background-color:#fff !important;transition:all 0.3s ease !important;box-sizing:border-box !important;}');
                            cssRules.push(':root.newtab-pro-baidu-dark-mode{background-color:#1a1a1a !important;}');
                            cssRules.push(':root.newtab-pro-baidu-dark-mode #head{background:#252525 !important;border-bottom:1px solid #333 !important;}');
                        }
                        if (hideRightContent) {
                            cssRules.push('#content_right{display:none !important;}');
                            cssRules.push('#rrecom-container{display:none !important;}');
                            cssRules.push('.opr-recommends-merge-content{display:none !important;}');
                        }
                        if (cleanAdsEnabled) {
                            cssRules.push('#top-ad{display:none !important;}');
                            cssRules.push('.EC_result,.ec_result,[data-tuiguang],[data-ecimtimesign],[data-placeid],[data-cmatchid],.ec-tuiguang,.c-recomm-wrap,#s_popup_advert{display:none !important;}');
                        }
                        if (hideAiEnabled) {
                            cssRules.push(':root.newtab-pro-hide-ai div[tpl="new_baikan_index"],:root.newtab-pro-hide-ai [tpl="wenda_generate"],:root.newtab-pro-hide-ai .ai-entry.cos-space-mb-xs,:root.newtab-pro-hide-ai .result-op.c-container.new-pmd[tpl="ai_index"],:root.newtab-pro-hide-ai .result-op[tpl="ai_index"],:root.newtab-pro-hide-ai .result-op[tpl="wenda_generate"],:root.newtab-pro-hide-ai div[m-name^="mirror-san/app/wenda_generate"],:root.newtab-pro-hide-ai div[tpl="ai_ask"]{display:none !important;}');
                        }
                        const cssText = cssRules.join('\n').trim();
                        if (cssText) {
                            const styleId = 'newtab-pro-baidu-search-enhance-style';
                            let el = document.getElementById(styleId);
                            if (!el) {
                                el = document.createElement('style');
                                el.id = styleId;
                                el.type = 'text/css';
                            }
                            el.textContent = cssText;
                            (document.head || document.documentElement || document).appendChild(el);
                        }
                    }
                }
            } catch (e0) {}

            function safeJsonParse(text, fallback) {
                try {
                    return JSON.parse(String(text));
                } catch (e) {
                    return fallback;
                }
            }

            function escapeHtml(s) {
                return String(s)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            const esc = (s) => escapeHtml(s);

            function safeDecodeUriText(text) {
                try {
                    return decodeURI(String(text));
                } catch (e) {
                    return String(text);
                }
            }

            function normalizeUrlForClipboard(url, decodeChinese) {
                const raw = String(url || '');
                if (!decodeChinese) return raw;
                try {
                    const u = new URL(raw, location.href);
                    const pathname = safeDecodeUriText(u.pathname);
                    const search = safeDecodeUriText(u.search);
                    const hash = safeDecodeUriText(u.hash);
                    return `${u.origin}${pathname}${search}${hash}`;
                } catch (e) {
                    return safeDecodeUriText(raw);
                }
            }

            function isTopWindow() {
                try {
                    return window.top === window.self;
                } catch (e) {
                    return false;
                }
            }

            function isEventFromSettingsPanel(e) {
                if (!e) return false;
                let t = e.target;
                try {
                    if (t && t.nodeType === 3) t = t.parentElement;
                } catch (e0) {}
                if (t && t instanceof Element) {
                    try {
                        const root = typeof t.getRootNode === 'function' ? t.getRootNode() : null;
                        const host = root && root.host ? root.host : null;
                        if (host && host.id === 'newtab-open-links-settings-panel') return true;
                    } catch (e1) {}
                    try {
                        if (t.id === 'newtab-open-links-settings-panel') return true;
                    } catch (e2) {}
                }
                const path = typeof e.composedPath === 'function' ? e.composedPath() : null;
                if (path && path.length) {
                    for (let i = 0; i < path.length; i++) {
                        const n = path[i];
                        if (!n || n.nodeType !== 1) continue;
                        try {
                            if (n.id === 'newtab-open-links-settings-panel') return true;
                        } catch (e3) {}
                    }
                }
                return false;
            }

            const STORAGE_PREFIX = 'newtab_open_links__';

                const LOGIN_POPUP_BYPASS_IGNORED_KEY = 'loginPopupBypassIgnoredSites';
            const EventRegistry = (function() {
                const list = [];
                function add(target, type, handler, options) {
                    try {
                        if (target && typeof target.addEventListener === 'function') {
                            target.addEventListener(type, handler, options);
                            list.push({ target, type, handler, options });
                        }
                    } catch (e) {}
                }
                function removeAll() {
                    for (let i = list.length - 1; i >= 0; i--) {
                        const it = list[i];
                        try {
                            if (it.target && typeof it.target.removeEventListener === 'function') {
                                it.target.removeEventListener(it.type, it.handler, it.options);
                            }
                        } catch (e) {}
                    }
                    list.length = 0;
                }
                return { add, removeAll };
            })();
            const TimerRegistry = (function() {
                const timeouts = [];
                const intervals = [];
                function setTimeoutTracked(fn, ms) {
                    try {
                        const id = setTimeout(fn, ms || 0);
                        timeouts.push(id);
                        return id;
                    } catch (e) {
                        return 0;
                    }
                }
                function setIntervalTracked(fn, ms) {
                    try {
                        const id = setInterval(fn, ms || 0);
                        intervals.push(id);
                        return id;
                    } catch (e) {
                        return 0;
                    }
                }
                function clearAll() {
                    for (let i = 0; i < timeouts.length; i++) {
                        try {
                            clearTimeout(timeouts[i]);
                        } catch (e) {}
                    }
                    for (let i = 0; i < intervals.length; i++) {
                        try {
                            clearInterval(intervals[i]);
                        } catch (e) {}
                    }
                    timeouts.length = 0;
                    intervals.length = 0;
                }
                return { setTimeout: setTimeoutTracked, setInterval: setIntervalTracked, clearAll };
            })();
            const MutationRegistry = (function() {
                const observers = [];
                function observe(target, options, callback, ttlMs) {
                    let scheduled = false;
                    function run() {
                        scheduled = false;
                        try {
                            if (typeof callback === 'function') callback();
                        } catch (e) {}
                    }
                    function queue() {
                        if (scheduled) return;
                        scheduled = true;
                        if (typeof requestAnimationFrame === 'function') {
                            try {
                                requestAnimationFrame(run);
                                return;
                            } catch (e) {}
                        }
                        try {
                            TimerRegistry.setTimeout(run, 0);
                        } catch (e2) {}
                    }
                    let obs = null;
                    try {
                        obs = new MutationObserver(queue);
                        if (target) obs.observe(target, options || { childList: true, subtree: true });
                        observers.push(obs);
                    } catch (e3) {}
                    if (ttlMs && ttlMs > 0) {
                        try {
                            TimerRegistry.setTimeout(() => {
                                try {
                                    if (obs) obs.disconnect();
                                } catch (e4) {}
                            }, ttlMs);
                        } catch (e5) {}
                    }
                    return obs;
                }
                function disconnectAll() {
                    for (let i = 0; i < observers.length; i++) {
                        try {
                            observers[i].disconnect();
                        } catch (e) {}
                    }
                    observers.length = 0;
                }
                return { observe, disconnectAll };
            })();
            function disposeAll() {
                try {
                    MutationRegistry.disconnectAll();
                } catch (e) {}
                try {
                    TimerRegistry.clearAll();
                } catch (e2) {}
                try {
                    EventRegistry.removeAll();
                } catch (e3) {}
            }
            function stopAllModules() {
                try {
                    disposeAll();
                } catch (e) {}
                try { stopSmartRedirectTipRecheck(); } catch (e1) {}
                try { stopDebugOverlayBroadcast(); } catch (e2) {}
                try { stopOverlayOwnershipLoop(); } catch (e3) {}
                try { stopDebugOverlay(); } catch (e4) {}
                try { stopGoTopBottomControls(); } catch (e5) {}
                try { stopAutoUnfold(); } catch (e6) {}
                try { stopLoginPopupBypass(); } catch (e7) {}
                try { stopCsdnLoginJumpGuard(); } catch (e8) {}
                try { stopCsdnStrongCopy(); } catch (e9) {}
                try { stopCsdnCleanPage(); } catch (e10) {}
                try { stopCsdnUnfreezeScroll(); } catch (e11) {}
                try { stopQqMailCleanVipBubble(); } catch (e11a) {}
                try { stopBaiduSearchEnhance(); } catch (e11b) {}
                try { stopPanCodeAssist(); } catch (e12) {}
                try { stopHoverTitleEnhancer(); } catch (e13) {}
                try { stopItskCloudQueryAutoJump(); } catch (e16) {}
                try { stopScheduledApplyAllTargets(); } catch (e17) {}
                try { stopObserver(); } catch (e18) {}
                try { stopClickInterceptor(); } catch (e19) {}
                try { stopTextLinkify(); } catch (e20) {}
            }
            try {
                EventRegistry.add(window, 'beforeunload', stopAllModules, true);
            } catch (e) {}

            function upsertStyleText(styleId, cssText) {
                const id = String(styleId || '').trim();
                if (!id) return null;
                const css = String(cssText || '').trim();
                if (!css) return null;
                const existing = document.getElementById(id);
                const style = existing || document.createElement('style');
                style.id = id;
                style.type = 'text/css';
                style.textContent = css;
                if (!existing) {
                    try {
                        (document.head || document.documentElement || document.body || document).appendChild(style);
                    } catch (e) {}
                }
                return style;
            }

            function removeElementById(id) {
                const key = String(id || '').trim();
                if (!key) return;
                try {
                    const el = document.getElementById(key);
                    if (el) el.remove();
                } catch (e) {}
            }

            function readLoginPopupBypassIgnoredSites() {
                let list = getValue(LOGIN_POPUP_BYPASS_IGNORED_KEY, []);
                if (!Array.isArray(list)) list = [];
                const defaults = ['intune.microsoft.com', 'wappass.baidu.com', 'wappass.passport.baidu.com'];
                return Array.from(
                    new Set(
                        list
                            .map((x) => String(x || '').trim().toLowerCase())
                            .filter(Boolean)
                            .concat(defaults)
                    )
                );
            }

            const DEFAULT_SETTINGS = {
                enabled: true,
                passiveTipsEnabled: true,
                passiveTipDurationMs: 3000,
                copyChineseUrlEnabled: true,
                copyCurrentUrlHotkey: 'altShiftC',
                copyCurrentUrlHotkeyCustom: '',
                visitedLinkColorEnabled: true,
                visitedLinkColor: '#8b5cf6',
                visitedLinkHistoryScope: 'global',
                greasyForkVisitStatsEnabled: true,
                baiduSearchEnhanceEnabled: true,
                baiduHideHotSearch: true,
                baiduHideRightContent: true,
                baiduLayoutMode: 'single',
                baiduStyleOptimizeEnabled: true,
                baiduCleanAdsEnabled: true,
                baiduHideAiAnswerEnabled: true,
                baiduAiAutoExpandEnabled: true,
                baiduPinOfficialEnabled: true,
                csdnStrongCopyEnabled: true,
                csdnCleanPageEnabled: true,
                csdnCleanHideTopToolbar: true,
                csdnCleanHideSideToolbar: true,
                csdnCleanHideLoginPopup: true,
                csdnCleanHideRecommend: true,
                csdnCleanHideRightAside: true,
                csdnCleanHideAds: true,
                csdnCenterContentEnabled: true,
                csdnUnfreezeScrollEnabled: true,
                csdnRedirectFastJumpEnabled: true,
                csdnCommentEnabled: true,
                csdnBottomArticleEnabled: true,
                qqMailCleanVipBubbleEnabled: true,
                panCodeAssistEnabled: true,
                panCodeLinkMergeEnabled: true,
                panCodeAutoFillEnabled: true,
                panCodeSmartSelectHotkey: 'off',
                panCodeSmartSelectHotkeyCustom: '',
                netdiskHoverRealUrlEnabled: true,
                panCodeHistoryEnabled: true,
                panCodeFavoritesEnabled: true,
                panCodeHistoryLimit: 500,
                enableDiscuz: true,
                enableObserver: true,
                enableTextLinkify: true,
                textLinkHoverFullUrlEnabled: true,
                autoUnfoldEnabled: true,
                autoUnfoldInterval: '100',
                autoUnfoldMaxTicks: '100',
                loginPopupBypassEnabled: true,
                debugOverlay: false,
                pinScrollEnabled: true,
                onlyExternalNewTab: false,
                uiTheme: 'light',
                settingsLayoutMode: 'commonFirst',
                settingsLayoutStyle: 'comfortable',
                menuDisplayMode: 'full',
                debugLogLevel: 'INFO',
                debugSyncInterval: '200',
                excludeDomains: '',
                keepOnclickSelf: true,
                keepNonHttpSelf: true,
                keepHashSelf: true,
                keepEmptyHrefSelf: true,
                keepFormSelf: true,
                textLinkifyIncludeHosts: '',
                textLinkifyExcludeHosts: '',
                smartRedirectEnabled: true,
                smartRedirectCleanLink: true,
                smartRedirectAutoJump: true,
                smartShortLinkEnabled: true,
            };

            const PASSIVE_TIP_DURATION_OPTIONS = [
                [600, '0.6 ç§’'],
                [800, '0.8 ç§’'],
                [1200, '1.2 ç§’'],
                [1800, '1.8 ç§’'],
                [2500, '2.5 ç§’'],
                [3000, '3 ç§’ï¼ˆé»˜è®¤ï¼‰'],
                [4000, '4 ç§’'],
                [6000, '6 ç§’'],
                [8000, '8 ç§’'],
            ];

            const COPY_CURRENT_URL_HOTKEY_OPTIONS = [
                ['off', 'å…³é—­'],
                ['altShiftC', 'Alt + Shift + Cï¼ˆé»˜è®¤ï¼‰'],
                ['altShiftU', 'Alt + Shift + U'],
                ['ctrlAltC', 'Ctrl + Alt + C'],
                ['ctrlAltU', 'Ctrl + Alt + U'],
                ['custom', 'è‡ªå®šä¹‰ï¼ˆåœ¨æ²¹çŒ´èœå•ä¸­è®¾ç½®ï¼‰'],
            ];

            const PAN_CODE_SMART_SELECT_HOTKEY_OPTIONS = [
                ['off', 'å…³é—­'],
                ['altShiftP', 'Alt + Shift + P'],
                ['altShiftN', 'Alt + Shift + N'],
                ['ctrlAltP', 'Ctrl + Alt + P'],
                ['ctrlAltN', 'Ctrl + Alt + N'],
                ['custom', 'è‡ªå®šä¹‰ï¼ˆåœ¨æ²¹çŒ´èœå•ä¸­è®¾ç½®ï¼‰'],
            ];

            const VISITED_LINK_COLOR_OPTIONS = [
                ['#8b5cf6', 'ç´«è‰²ï¼ˆé»˜è®¤ï¼‰'],
                ['#3b82f6', 'è“è‰²'],
                ['#10b981', 'ç»¿è‰²'],
                ['#f59e0b', 'é»„è‰²'],
                ['#f97316', 'æ©™è‰²'],
                ['#ef4444', 'çº¢è‰²'],
                ['#6b7280', 'ç°è‰²'],
            ];

            const VISITED_LINK_HISTORY_SCOPE_OPTIONS = [
                ['global', 'å…¨å±€ï¼ˆè·¨ç«™ç‚¹ï¼‰'],
                ['site', 'å½“å‰ç«™ç‚¹ï¼ˆæ¨èï¼‰'],
            ];

            const BAIDU_LAYOUT_MODE_OPTIONS = [
                ['single', 'å•åˆ—ï¼ˆé»˜è®¤ï¼‰'],
                ['double', 'åŒåˆ—'],
            ];

            const PAN_CODE_HISTORY_LIMIT_OPTIONS = [
                [30, '30 æ¡'],
                [50, '50 æ¡'],
                [100, '100 æ¡'],
                [200, '200 æ¡'],
                [300, '300 æ¡'],
                [500, '500 æ¡ï¼ˆé»˜è®¤ï¼‰'],
                [800, '800 æ¡'],
                [1000, '1000 æ¡'],
            ];

            const AUTO_UNFOLD_INTERVAL_OPTIONS = [
                ['50', '50msï¼ˆæ›´è€—èµ„æºï¼‰'],
                ['100', '100msï¼ˆé»˜è®¤ï¼‰'],
                ['150', '150ms'],
                ['200', '200ms'],
                ['350', '350ms'],
                ['500', '500ms'],
            ];

            const AUTO_UNFOLD_MAX_TICKS_OPTIONS = [
                ['50', 'çº¦ 5 ç§’'],
                ['100', 'çº¦ 10 ç§’ï¼ˆé»˜è®¤ï¼‰'],
                ['150', 'çº¦ 15 ç§’'],
                ['200', 'çº¦ 20 ç§’'],
                ['300', 'çº¦ 30 ç§’'],
            ];

            const UI_THEME_OPTIONS = [
                ['auto', 'è·Ÿéšç³»ç»Ÿ'],
                ['dark', 'æ·±è‰²'],
                ['light', 'æµ…è‰²'],
            ];

            const SETTINGS_LAYOUT_MODE_OPTIONS = [
                ['classic', 'ç»å…¸å¸ƒå±€'],
                ['commonFirst', 'å¸¸ç”¨ä¼˜å…ˆ'],
            ];

        const SETTINGS_LAYOUT_STYLE_OPTIONS = [
            ['comfortable', 'èˆ’é€‚ï¼ˆæ¨èï¼‰'],
            ['compact', 'ç´§å‡‘'],
        ];

            const MENU_DISPLAY_MODE_OPTIONS = [
                ['simple', 'ç²¾ç®€ï¼ˆæ¨èï¼‰'],
                ['full', 'å®Œæ•´ï¼ˆæ‰€æœ‰å¼€å…³ï¼‰'],
            ];

            const DEBUG_LOG_LEVEL_OPTIONS = [
                ['DEBUG', 'DEBUG - å…¨éƒ¨æ—¥å¿—'],
                ['INFO', 'INFO - å¸¸è§„ä¿¡æ¯'],
                ['WARN', 'WARN - è­¦å‘Šä¸é”™è¯¯'],
                ['ERROR', 'ERROR - ä»…é”™è¯¯'],
            ];

            const DEBUG_SYNC_INTERVAL_OPTIONS = [
                ['0', 'å®æ—¶ï¼ˆæ›´è€—èµ„æºï¼‰'],
                ['100', '100ms'],
                ['200', '200msï¼ˆé»˜è®¤ï¼‰'],
                ['350', '350ms'],
                ['500', '500ms'],
                ['1000', '1000ms'],
            ];

            function toggleRow(key, label, desc, extra) {
                const base = {
                    type: 'toggle',
                    key,
                    label,
                    desc,
                };
                if (extra && typeof extra === 'object') {
                    return Object.assign(base, extra);
                }
                return base;
            }

            function selectRow(key, label, desc, options, extra) {
                const base = {
                    type: 'select',
                    key,
                    label,
                    desc,
                    options,
                };
                if (extra && typeof extra === 'object') {
                    return Object.assign(base, extra);
                }
                return base;
            }

            function rowsFromTuples(tuples) {
                const rows = [];
                for (let i = 0; i < tuples.length; i++) {
                    const t = tuples[i];
                    if (!t || !t.length) continue;
                    if (t[0] === 'toggle') rows.push(toggleRow(t[1], t[2], t[3], t[4]));
                    else if (t[0] === 'select') rows.push(selectRow(t[1], t[2], t[3], t[4], t[5]));
                }
                return rows;
            }
            const BASIC_GROUP = {
                id: 'basic',
                title: 'ğŸ§© åŸºç¡€',
                rows: rowsFromTuples([
                    ['toggle', 'enabled', 'å¯ç”¨è„šæœ¬', 'æ§åˆ¶å½“å‰åŸŸåæ˜¯å¦å¯ç”¨æœ¬è„šæœ¬ï¼Œå…³é—­åé¡µé¢ä¿æŒç½‘ç«™åŸå§‹è¡Œä¸ºã€‚', { iconOn: 'âœ…', iconOff: 'âŒ' }],
                    ['toggle', 'passiveTipsEnabled', 'æ— æ„Ÿæç¤º', 'ç»Ÿä¸€æ§åˆ¶â€œå·²ç”Ÿæ•ˆ/å»é‡å®šå‘/è‡ªåŠ¨å±•å¼€â€ç­‰æ— æ„Ÿæç¤ºæ˜¯å¦æ˜¾ç¤ºã€‚', { iconOn: 'ğŸ””', iconOff: 'ğŸ”•' }],
                    ['select', 'passiveTipDurationMs', 'æ— æ„Ÿæç¤ºæ˜¾ç¤ºæ—¶é•¿', 'æ§åˆ¶æ— æ„Ÿæç¤ºçš„åœç•™æ—¶é—´ï¼Œæ—¶é•¿è¶Šé•¿è¶Šå®¹æ˜“æ³¨æ„ï¼Œä½†ä¹Ÿæ›´å å±å¹•ã€‚', PASSIVE_TIP_DURATION_OPTIONS, { icon: 'â±' }],
                    ['toggle', 'copyChineseUrlEnabled', 'å¤åˆ¶ä¸­æ–‡URL', 'è„šæœ¬æä¾›â€œå¤åˆ¶é“¾æ¥â€å…¥å£æ—¶ï¼Œä¼˜å…ˆå¤åˆ¶è§£ç åçš„ä¸­æ–‡ URLï¼ˆä¸å½±å“åœ°å€æ ç›´æ¥å¤åˆ¶ï¼‰ã€‚', { icon: 'ğŸ“‹' }],
                    ['select', 'copyCurrentUrlHotkey', 'å¿«æ·é”®å¤åˆ¶å½“å‰é¡µé“¾æ¥', 'åœ¨é¡µé¢å†…æŒ‰ä¸‹å¿«æ·é”®å³å¯å¤åˆ¶å½“å‰é¡µé“¾æ¥ï¼ˆæ”¯æŒå¤åˆ¶ä¸­æ–‡URLå¼€å…³ï¼‰ã€‚è‡ªå®šä¹‰å¿«æ·é”®è¯·åœ¨æ²¹çŒ´èœå•ä¸­è®¾ç½®ï¼›æµè§ˆå™¨åœ°å€æ èšç„¦æ—¶æ— æ³•è§¦å‘ã€‚', COPY_CURRENT_URL_HOTKEY_OPTIONS, { icon: 'âŒ¨ï¸' }],
                    ['toggle', 'visitedLinkColorEnabled', 'å·²è®¿é—®é“¾æ¥å˜è‰²', 'å¯¹å·²è®¿é—®è¿‡çš„é“¾æ¥æ ‡é¢˜è¿›è¡Œå˜è‰²å¤„ç†ï¼Œä»…å¯¹è„šæœ¬ç®¡ç†è¿‡çš„é“¾æ¥ç”Ÿæ•ˆã€‚', { icon: 'ğŸ¨' }],
                    ['select', 'visitedLinkColor', 'å·²è®¿é—®é“¾æ¥é¢œè‰²', 'é€‰æ‹©å·²è®¿é—®é“¾æ¥çš„æ ‡é¢˜é¢œè‰²ã€‚', VISITED_LINK_COLOR_OPTIONS, { icon: 'ğŸ¨' }],
                    ['select', 'visitedLinkHistoryScope', 'å·²è®¿é—®è®°å½•èŒƒå›´', 'æ§åˆ¶â€œå·²è®¿é—®â€è®°å½•æ˜¯å¦æŒ‰ç«™ç‚¹éš”ç¦»ã€‚æŒ‰ç«™ç‚¹æ›´ç¬¦åˆç›´è§‰ä¸”æ›´éšç§å‹å¥½ã€‚', VISITED_LINK_HISTORY_SCOPE_OPTIONS, { icon: 'ğŸ§­' }],
                    ['toggle', 'greasyForkVisitStatsEnabled', 'GreasyFork è„šæœ¬è®¿é—®ç»Ÿè®¡', 'è®°å½• GreasyFork è„šæœ¬è¯¦æƒ…é¡µè®¿é—®æ¬¡æ•°ï¼Œå¹¶åœ¨â€œå·²è®¿é—®é“¾æ¥ç»Ÿè®¡â€ä¸­å±•ç¤ºã€‚', { icon: 'ğŸ“Š' }],
                ]),
            };

            const READING_GROUP = {
                id: 'reading',
                title: 'ğŸ“– é˜…è¯»å¢å¼º',
                rows: rowsFromTuples([
                    ['toggle', 'autoUnfoldEnabled', 'è‡ªåŠ¨å±•å¼€å†…å®¹', 'è‡ªåŠ¨å±•å¼€å¤šç«™ç‚¹çš„â€œé˜…è¯»å…¨æ–‡/å±•å¼€å›ç­”/ç§»é™¤é®æŒ¡â€ç­‰éšè—å†…å®¹ã€‚', { iconOn: 'ğŸ”“', iconOff: 'ğŸ”’' }],
                    ['toggle', 'loginPopupBypassEnabled', 'éšè—ç™»å½•å¼¹çª—é®æŒ¡ï¼ˆé€šç”¨ï¼‰', 'å°è¯•ç§»é™¤é®æŒ¡å±‚ã€è§£é™¤æ»šåŠ¨é”ï¼Œä¼˜å…ˆé€‚é…çŸ¥ä¹ï¼›å¯èƒ½å½±å“ç½‘ç«™ç™»å½•å¼¹çª—ã€‚', { icon: 'ğŸ™ˆ' }],
                    ['select', 'autoUnfoldInterval', 'è‡ªåŠ¨å±•å¼€æ‰§è¡Œé—´éš”', 'æ§åˆ¶â€œè‡ªåŠ¨å±•å¼€å†…å®¹â€çš„æ‰§è¡Œé¢‘ç‡ã€‚é—´éš”è¶Šå°è¶ŠåŠæ—¶ï¼Œä½† DOM æ‰«ææ›´é¢‘ç¹ã€‚', AUTO_UNFOLD_INTERVAL_OPTIONS, { icon: 'â±' }],
                    ['select', 'autoUnfoldMaxTicks', 'è‡ªåŠ¨å±•å¼€æŒç»­æ—¶é•¿', 'æ§åˆ¶æœ€å¤šæ‰§è¡Œè½®æ•°ï¼Œåˆ°è¾¾åä¼šè‡ªåŠ¨åœæ­¢ï¼ˆè½®æ•° Ã— é—´éš”ï¼‰ã€‚', AUTO_UNFOLD_MAX_TICKS_OPTIONS, { icon: 'â³' }],
                ]),
            };

            const SEARCH_GROUP = {
                id: 'search',
                title: 'ğŸ” ç™¾åº¦æœç´¢',
                rows: rowsFromTuples([
                    ['toggle', 'baiduSearchEnhanceEnabled', 'ç™¾åº¦æœç´¢å¢å¼ºï¼ˆä¸»å¼€å…³ï¼‰', 'ä»…åœ¨ www.baidu.com / m.baidu.com ç”Ÿæ•ˆï¼šå‡€åŒ–é¡µé¢å¹¶æ”¯æŒå•åŒåˆ—å¸ƒå±€ã€‚', { icon: 'ğŸ”' }],
                    ['toggle', 'baiduHideHotSearch', 'éšè—çƒ­æœ/çƒ­ç‚¹', 'éšè—ç™¾åº¦é¦–é¡µ/æœç´¢é¡µå¸¸è§çƒ­æœä¸çƒ­ç‚¹æ¨¡å—ã€‚', { icon: 'ğŸ”¥' }],
                    ['toggle', 'baiduHideRightContent', 'éšè—å³ä¾§ç›¸å…³å†…å®¹', 'éšè—å³ä¾§â€œç›¸å…³å†…å®¹/æ¨è/ç™¾ç§‘å¡ç‰‡â€ç­‰åŒºåŸŸï¼Œæå‡é˜…è¯»ä¸“æ³¨ã€‚', { icon: 'ğŸ§¹' }],
                    ['select', 'baiduLayoutMode', 'æœç´¢ç»“æœå¸ƒå±€', 'åˆ‡æ¢æœç´¢ç»“æœä¸ºå•åˆ—æˆ–åŒåˆ—å±•ç¤ºï¼ˆä»… www.baidu.com ç”Ÿæ•ˆï¼‰ã€‚', BAIDU_LAYOUT_MODE_OPTIONS, { icon: 'ğŸ§±' }],
                    ['toggle', 'baiduStyleOptimizeEnabled', 'å±…ä¸­å¸ƒå±€ä¸æ ·å¼ä¼˜åŒ–ï¼ˆå‚è€ƒè„šæœ¬ï¼‰', 'ä½¿ç”¨å‚è€ƒè„šæœ¬çš„å±…ä¸­/å•åŒåˆ—å¸ƒå±€ä¸å¡ç‰‡æ ·å¼ï¼›å…³é—­ååªä¿ç•™å‡€åŒ–ç±»å¼€å…³ã€‚', { icon: 'ğŸ›' }],
                    ['toggle', 'baiduCleanAdsEnabled', 'å»å¹¿å‘Š/å‡€åŒ–', 'éšè—å¸¸è§æ¨å¹¿ã€å“ç‰Œå¹¿å‘Šä¸å¹²æ‰°æ¨¡å—ï¼ˆå°½é‡åªåšæ ·å¼éšè—ï¼‰ã€‚', { icon: 'ğŸ§¼' }],
                    ['toggle', 'baiduHideAiAnswerEnabled', 'å±è”½ AI å›ç­”/AI æ¨¡å—', 'éšè—ç™¾åº¦æœç´¢ä¸­å¸¸è§çš„ AI å›ç­”/AI æ¦‚è§ˆç­‰æ¨¡å—ã€‚', { icon: 'ğŸ¤–' }],
                    ['toggle', 'baiduPinOfficialEnabled', 'å®˜ç½‘ç½®é¡¶ï¼ˆå®éªŒï¼‰', 'å°†æ ‡æ³¨â€œå®˜ç½‘/å®˜æ–¹â€çš„ç»“æœå°½é‡ç§»åŠ¨åˆ°ç»“æœåˆ—è¡¨é¡¶éƒ¨ã€‚', { icon: 'ğŸ“Œ' }],
                ]),
            };

            const CSDN_GROUP = {
                id: 'csdn',
                title: 'ğŸƒ CSDN',
                rows: rowsFromTuples([
                    ['toggle', 'csdnStrongCopyEnabled', 'å¼ºåŠ›å¤åˆ¶è§£é”ï¼ˆä»… CSDNï¼‰', 'ä»…åœ¨ csdn.net ä¸‹ç”Ÿæ•ˆï¼šè§£é”é€‰æ‹©/å³é”®/å¤åˆ¶ï¼Œå¹¶å¯¹å¤åˆ¶å†…å®¹è¿›è¡Œè½»åº¦å‡€åŒ–ï¼ˆå»é™¤å¸¸è§æ¥æº/ç‰ˆæƒå°¾å·´ï¼‰ã€‚', { icon: 'ğŸ“‹' }],
                    ['toggle', 'csdnCleanPageEnabled', 'é¡µé¢å‡€åŒ–ï¼ˆä»… CSDNï¼‰', 'ä»…åœ¨ csdn.net ä¸‹ç”Ÿæ•ˆï¼šé€šè¿‡çº¯ CSS éšè—å¸¸è§å·¥å…·æ¡/ä¾§æ /æ¨èç­‰å¹²æ‰°åŒºåŸŸï¼Œä¸åšèŠ‚ç‚¹éå†ã€‚', { icon: 'ğŸ§¼' }],
                    ['toggle', 'csdnCleanHideTopToolbar', 'éšè—é¡¶éƒ¨å·¥å…·æ ', 'éšè—å¸¸è§é¡¶éƒ¨å¯¼èˆª/å·¥å…·æ¡ï¼ˆå¦‚ #csdn-toolbarã€.csdn-toolbar ç­‰ï¼‰ã€‚', { icon: 'â–«ï¸' }],
                    ['toggle', 'csdnCleanHideSideToolbar', 'éšè—ä¾§è¾¹å·¥å…·æ¡', 'éšè—å¸¸è§æ‚¬æµ®ä¾§è¾¹æ¡/å·¦ä¾§å·¥å…·ç®±ï¼ˆå¦‚ .csdn-side-toolbarã€.left-toolbox ç­‰ï¼‰ã€‚', { icon: 'â–«ï¸' }],
                    ['toggle', 'csdnCleanHideLoginPopup', 'éšè—ç™»å½•å¼¹å±‚', 'éšè—å¯èƒ½é®æŒ¡é˜…è¯»çš„ç™»å½•æç¤º/å¼¹å±‚å®¹å™¨ï¼ˆå¦‚ .passport-login-containerï¼‰ã€‚', { icon: 'â–«ï¸' }],
                    ['toggle', 'csdnCleanHideRecommend', 'éšè—æ¨èæ¨¡å—', 'éšè—æ¨è/æ‰“åˆ†/ç›¸å…³å†…å®¹ç­‰åŒºåŸŸï¼ˆå¦‚ .recommend-boxã€#recommendNps ç­‰ï¼‰ã€‚', { icon: 'â–«ï¸' }],
                    ['toggle', 'csdnCleanHideRightAside', 'éšè—å³ä¾§æ ', 'éšè—å³ä¾§æ–‡ç« ç›®å½•/çƒ­æ¦œ/å½’æ¡£ç­‰ä¾§æ åŒºåŸŸï¼ˆå¦‚ #rightAside ç­‰ï¼‰ã€‚', { icon: 'â–«ï¸' }],
                    ['toggle', 'csdnCleanHideAds', 'éšè—å¹¿å‘Šä½', 'éšè—å¸¸è§å¹¿å‘Šå®¹å™¨ï¼ˆå¦‚ .ad-boxã€.ad-wrapã€#kp_boxã€#asideAd ç­‰ï¼‰ï¼Œä»…æ³¨å…¥æ ·å¼ä¸éå† DOMã€‚', { icon: 'â–«ï¸' }],
                    ['toggle', 'csdnCenterContentEnabled', 'å…¨æ–‡å±…ä¸­ï¼ˆä»… CSDNï¼‰', 'å°†æ–‡ç« ä¸»ä½“é™åˆ¶å®½åº¦å¹¶å±…ä¸­æ˜¾ç¤ºï¼ˆå¦‚ #content_viewsã€.article-content ç­‰ï¼‰ï¼Œä¸å½±å“äº¤äº’ã€‚', { icon: 'ğŸ¯' }],
                    ['toggle', 'csdnCommentEnabled', 'éšè—è¯„è®ºåŒºï¼ˆä»… CSDNï¼‰', 'å¼€å¯åéšè—è¯„è®ºåŒºåŒºåŸŸï¼ˆ#pcCommentBox / #commentï¼‰ã€‚', { icon: 'ğŸ’¬' }],
                    ['toggle', 'csdnBottomArticleEnabled', 'éšè—åº•éƒ¨æ¨èæ–‡ç« ï¼ˆä»… CSDNï¼‰', 'å¼€å¯åéšè—åº•éƒ¨æ¨èæ–‡ç« åŒºåŸŸï¼ˆmain > div.recommend-box / #recommendï¼‰ã€‚', { icon: 'ğŸ“š' }],
                    ['toggle', 'csdnUnfreezeScrollEnabled', 'è§£é™¤æ»šåŠ¨é”ï¼ˆä»… CSDNï¼‰', 'ä»…åœ¨ csdn.net ä¸‹ç”Ÿæ•ˆï¼šä¿®å¤å¶å‘çš„æ»šåŠ¨è¢«é”ï¼ˆoverflow:hidden ç­‰ï¼‰ï¼Œå¿…è¦æ—¶çŸ­æ—¶è‡ªæ„ˆåè‡ªåŠ¨åœæ­¢ã€‚', { icon: 'ğŸ§Š' }],
                    ['toggle', 'csdnRedirectFastJumpEnabled', 'ä¸­è½¬é¡µç§’è·³ï¼ˆä»… CSDNï¼‰', 'ä»…åœ¨ link.csdn.net è¿™ç±»ä¸­è½¬é¡µç”Ÿæ•ˆï¼šè‡ªåŠ¨è·³è½¬åˆ°çœŸå®ç›®æ ‡åœ°å€ï¼Œé¿å…äºŒæ¬¡ç¡®è®¤ã€‚', { icon: 'â©' }],
                ]),
            };

                                        const QQMAIL_GROUP = {
                                            id: 'qqmail',
                                            title: 'âœ‰ï¸ QQé‚®ç®±',
                                            rows: rowsFromTuples([
                                                ['toggle', 'qqMailCleanVipBubbleEnabled', 'QQé‚®ç®±å»å¹¿å‘Šï¼ˆVIP æ°”æ³¡ï¼‰', 'éšè—â€œå¼€é€š VIP ä¼šå‘˜ï¼Œè®©é‚®ç®±æ›´å¥½ç”¨â€ç­‰æ‚¬æµ®æ¨å¹¿æ°”æ³¡ï¼ˆä»… QQ é‚®ç®±é¡µé¢ç”Ÿæ•ˆï¼‰ã€‚', { icon: 'âœ‰ï¸' }],
                                            ]),
                                        };

            const PAN_GROUP = {
                id: 'pan',
                title: 'ğŸ’¾ ç½‘ç›˜æå–ç ',
                rows: rowsFromTuples([
                    ['toggle', 'panCodeAssistEnabled', 'å¯ç”¨ç½‘ç›˜æå–ç åŠ©æ‰‹', 'è¯†åˆ«å¸¸è§ç½‘ç›˜é“¾æ¥ä¸â€œæå–ç /è®¿é—®ç /å¯†ç â€ç­‰ä¿¡æ¯ï¼Œæä¾›é“¾æ¥åˆå¹¶ä¸è‡ªåŠ¨å¡«å……èƒ½åŠ›ã€‚', { icon: 'ğŸ”' }],
                    ['toggle', 'panCodeLinkMergeEnabled', 'åˆå¹¶æå–ç åˆ°é“¾æ¥', 'ç‚¹å‡»ç½‘ç›˜é“¾æ¥æ—¶ï¼Œè‹¥ä»é™„è¿‘æ–‡å­—è¯†åˆ«åˆ°æå–ç ï¼Œä¼šå°†å…¶åˆå¹¶åˆ°é“¾æ¥å‚æ•°ä¸­ï¼Œæ–¹ä¾¿ç›´è¾¾ã€‚', { icon: 'ğŸ”—' }],
                    ['toggle', 'panCodeAutoFillEnabled', 'è‡ªåŠ¨å¡«å……æå–ç ', 'åœ¨ç½‘ç›˜åˆ†äº«é¡µè‡ªåŠ¨è¯†åˆ«å¹¶å¡«å……æå–ç ï¼ˆä¼˜å…ˆå– URL å‚æ•°ï¼Œå…¶æ¬¡å–æœ€è¿‘ç¼“å­˜ï¼‰ã€‚', { icon: 'âœï¸' }],
                    ['select', 'panCodeSmartSelectHotkey', 'å¿«æ·é”®è§¦å‘é€‰åŒºè¯†åˆ«', 'é€‰ä¸­æ–‡æœ¬åï¼ŒæŒ‰ä¸‹å¿«æ·é”®å¯æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡ç½‘ç›˜é€‰åŒºè¯†åˆ«ï¼ˆç­‰ä»·äº mouseup è§¦å‘ï¼‰ã€‚è‡ªå®šä¹‰å¿«æ·é”®è¯·åœ¨æ²¹çŒ´èœå•ä¸­è®¾ç½®ã€‚', PAN_CODE_SMART_SELECT_HOTKEY_OPTIONS, { icon: 'âŒ¨ï¸' }],
                    ['toggle', 'panCodeHistoryEnabled', 'è®°å½•ç½‘ç›˜å†å²è®°å½•', 'è®°å½•æœ€è¿‘è¯†åˆ«åˆ°çš„ç½‘ç›˜é“¾æ¥ä¸æå–ç ï¼Œä¾¿äºåœ¨è®¾ç½®é¢æ¿ä¸­å¿«é€ŸæŸ¥çœ‹ã€å¤åˆ¶ä¸æ”¶è—ã€‚', { icon: 'ğŸ—‚' }],
                    ['toggle', 'panCodeFavoritesEnabled', 'å¯ç”¨æ”¶è—', 'å…è®¸å°†å¸¸ç”¨ç½‘ç›˜é“¾æ¥åŠ å…¥æ”¶è—ã€‚å…³é—­åä»ä¿ç•™å·²æ”¶è—æ•°æ®ï¼Œä½†ä¸å†å±•ç¤ºæ”¶è—æ“ä½œã€‚', { icon: 'â­' }],
                    ['select', 'panCodeHistoryLimit', 'å†å²å®¹é‡', 'æ§åˆ¶ç½‘ç›˜å†å²è®°å½•çš„æœ€å¤§æ¡æ•°ï¼ˆè¶…å‡ºä¼šè‡ªåŠ¨æ·˜æ±°æœ€æ—§çš„ï¼‰ã€‚', PAN_CODE_HISTORY_LIMIT_OPTIONS, { icon: 'ğŸ“Œ' }],
                ]),
            };

            const HOVER_GROUP = {
                id: 'hover',
                title: 'ğŸ§· æ‚¬æµ®æç¤º',
                rows: rowsFromTuples([
                    ['toggle', 'netdiskHoverRealUrlEnabled', 'æ‚¬æµ®æ˜¾ç¤ºçœŸå®é“¾æ¥ï¼ˆä»…ç½‘ç›˜ï¼‰', 'ä¸â€œæ‚¬æµ®æ˜¾ç¤ºå®Œæ•´ URLâ€å…±ç”¨åŒä¸€æœºåˆ¶ï¼Œä¼˜å…ˆæ˜¾ç¤ºç½‘ç›˜çœŸå®é“¾æ¥ï¼Œä¸å½±å“ç‚¹å‡»è¡Œä¸ºã€‚', { icon: 'ğŸ§·' }],
                    ['toggle', 'textLinkHoverFullUrlEnabled', 'æ‚¬æµ®æ˜¾ç¤ºå®Œæ•´ URL', 'ä¸â€œæ‚¬æµ®æ˜¾ç¤ºçœŸå®é“¾æ¥ï¼ˆä»…ç½‘ç›˜ï¼‰â€å…±ç”¨åŒä¸€æœºåˆ¶ï¼Œä¼˜å…ˆçº§æ›´ä½ï¼›ç”¨äºæ ‡é¢˜é“¾æ¥å¿«é€Ÿè¯†åˆ«ç›®æ ‡åœ°å€ã€‚', { icon: 'ğŸ§·' }],
                ]),
            };

            const PIN_GROUP = {
                id: 'pin',
                title: 'ğŸ§· ç½®é¡¶ / ç½®åº•',
                rows: rowsFromTuples([
                    ['toggle', 'pinScrollEnabled', 'ç½®é¡¶/ç½®åº•æŒ‰é’®', 'åœ¨é¡µé¢å³ä¸‹è§’æ˜¾ç¤ºå¯æ‹–æ‹½çš„ä¸Šä¸‹æ»šåŠ¨æŒ‰é’®ï¼Œæ–¹ä¾¿é•¿é¡µé¢å¿«é€Ÿå›åˆ°é¡¶éƒ¨æˆ–æ»šåŠ¨åˆ°åº•éƒ¨ã€‚', { icon: 'ğŸ§·' }],
                ]),
            };

            const STRATEGY_GROUP = {
                id: 'strategy',
                title: 'ğŸ§  ç­–ç•¥',
                rows: rowsFromTuples([
                    ['toggle', 'onlyExternalNewTab', 'ä»…ç«™å¤–é“¾æ¥æ–°æ ‡ç­¾é¡µ', 'åŒåŸŸåé“¾æ¥ä½¿ç”¨å½“å‰æ ‡ç­¾ï¼Œä»…å¤–ç«™é“¾æ¥å¼ºåˆ¶æ–°æ ‡ç­¾é¡µï¼Œé€‚åˆç«™å†…è·³è½¬è¾ƒå¤šçš„ç«™ç‚¹ã€‚', { icon: 'ğŸŒ' }],
                ]),
            };

            const REDIRECT_GROUP = {
                id: 'redirect',
                title: 'ğŸ”— è·³è½¬ä¼˜åŒ–',
                rows: rowsFromTuples([
                    ['toggle', 'smartRedirectEnabled', 'å¯ç”¨æ™ºèƒ½å»é‡å®šå‘', 'å°è¯•è·³è¿‡å¸¸è§ç»Ÿè®¡/ä¸­è½¬é“¾æ¥ï¼Œç›´è¾¾ç›®æ ‡é¡µé¢ã€‚é‡åˆ°ç«™ç‚¹å¼‚å¸¸æ—¶å¯ä»¥å…ˆå…³é—­æœ¬åŠŸèƒ½æµ‹è¯•ã€‚', { icon: 'ğŸš€' }],
                    ['toggle', 'smartRedirectCleanLink', 'æ¸…ç†é“¾æ¥é‡å®šå‘', 'åœ¨ç‚¹å‡»å‰è§£æå¸¸è§é‡å®šå‘é“¾æ¥ä¸­çš„çœŸå®åœ°å€ï¼Œä»…å¯¹éƒ¨åˆ†ç«™ç‚¹ç”Ÿæ•ˆã€‚', { icon: 'ğŸ§¹' }],
                    ['toggle', 'smartRedirectAutoJump', 'ä¸­è½¬é¡µè‡ªåŠ¨è·³è½¬', 'åœ¨å¸¸è§ä¸­è½¬/ç­‰å¾…é¡µé¢ä¸Šè‡ªåŠ¨è·³è½¬åˆ°ç›®æ ‡åœ°å€ï¼Œå¯èƒ½ä¸ç™»å½•/éªŒè¯é¡µå†²çªï¼›å¦‚é‡å¼‚å¸¸å¯å…³é—­ã€‚', { icon: 'â©' }],
                    ['toggle', 'smartShortLinkEnabled', 'çŸ­é“¾è‡ªåŠ¨è¿˜åŸ', 'å¯¹å¸¸è§çŸ­é“¾æœåŠ¡åœ¨åå°è§£æä¸€æ¬¡çœŸå®åœ°å€ï¼Œåœ¨æ–°æ ‡ç­¾é¡µç›´æ¥æ‰“å¼€ç›®æ ‡é¡µé¢ï¼Œå‡å°‘å¤šæ¬¡ä¸­è½¬ã€‚', { icon: 'ğŸ”—' }],
                ]),
            };

            const APPEARANCE_GROUP = {
                id: 'appearance',
                title: 'ğŸ¨ å¤–è§‚',
                rows: rowsFromTuples([
                    ['select', 'uiTheme', 'è®¾ç½®é¢æ¿ä¸»é¢˜', 'åªå½±å“æœ¬è®¾ç½®é¢æ¿çš„æ·±è‰²/æµ…è‰²å¤–è§‚ï¼Œä¸ä¼šä¿®æ”¹ç½‘é¡µæœ¬èº«çš„ä¸»é¢˜ã€‚', UI_THEME_OPTIONS, { icon: 'ğŸŒ“' }],
                    ['select', 'settingsLayoutMode', 'è®¾ç½®é¢æ¿å¸ƒå±€', 'æ§åˆ¶è®¾ç½®é¢æ¿åˆ†ç»„çš„æ˜¾ç¤ºé¡ºåºï¼šç»å…¸å¸ƒå±€æ›´ååˆ†ç±»ï¼›å¸¸ç”¨ä¼˜å…ˆæ›´åé«˜é¢‘åŠŸèƒ½é›†ä¸­ã€‚', SETTINGS_LAYOUT_MODE_OPTIONS, { icon: 'ğŸ§­' }],
                    ['select', 'settingsLayoutStyle', 'è®¾ç½®é¢æ¿å¯†åº¦', 'èˆ’é€‚æ¨¡å¼æ›´æ¸…æ™°æ˜“è¯»ï¼›ç´§å‡‘æ¨¡å¼æ›´çœç©ºé—´ï¼Œé€‚åˆå°å±æˆ–é‡åº¦ä½¿ç”¨ã€‚', SETTINGS_LAYOUT_STYLE_OPTIONS, { icon: 'ğŸ“' }],
                    ['select', 'menuDisplayMode', 'æ²¹çŒ´èœå•æ˜¾ç¤º', 'ç²¾ç®€æ¨¡å¼å‡å°‘èœå•é¡¹ï¼Œé¿å…åˆ—è¡¨è¿‡é•¿ï¼›å®Œæ•´æ¨¡å¼å±•ç¤ºæ›´å¤šå¿«é€Ÿå¼€å…³ã€‚', MENU_DISPLAY_MODE_OPTIONS, { icon: 'ğŸ“‹' }],
                ]),
            };

            const EXCEPTIONS_GROUP = {
                id: 'exceptions',
                title: 'ğŸ§¯ ä¾‹å¤–',
                rows: rowsFromTuples([
                    ['toggle', 'keepOnclickSelf', 'onclick é“¾æ¥ç”¨å½“å‰é¡µ', 'éƒ¨åˆ†ç«™ç‚¹ç”¨ JS å¤„ç† a æ ‡ç­¾ç‚¹å‡»ï¼ˆå¼¹å±‚ã€åŸ‹ç‚¹ç­‰ï¼‰ï¼Œå¼€å¯åè¿™ç±»é“¾æ¥ä»åœ¨å½“å‰é¡µæ‰“å¼€ï¼Œé¿å…è¢«å¼ºåˆ¶è·³æ–°æ ‡ç­¾ã€‚', { icon: 'ğŸ–±' }],
                    ['toggle', 'keepNonHttpSelf', 'é http(s) é“¾æ¥ç”¨å½“å‰é¡µ', 'å¯¹ mailto:, tel: ç­‰ç‰¹æ®Šåè®®ä¿æŒåŸç”Ÿè¡Œä¸ºï¼Œä¸å¼ºåˆ¶æ–°æ ‡ç­¾é¡µã€‚', { icon: 'ğŸ”—' }],
                    ['toggle', 'keepHashSelf', '# é”šç‚¹é“¾æ¥ç”¨å½“å‰é¡µ', 'ä»…åœ¨å½“å‰é¡µé¢å†…è·³è½¬ä½ç½®ï¼ˆå¦‚ç›®å½•/è¿”å›é¡¶éƒ¨ï¼‰ï¼Œä¸é€‚åˆä½œä¸ºæ–°æ ‡ç­¾ï¼Œå¼€å¯åè¿™ç±»é“¾æ¥ä¿æŒå½“å‰é¡µã€‚', { icon: '#' }],
                    ['toggle', 'keepEmptyHrefSelf', 'æ—  href é“¾æ¥ç”¨å½“å‰é¡µ', 'ç”¨äºæŒ‰é’®å¼ a æ ‡ç­¾æˆ–ä»…ç»‘å®šäº‹ä»¶çš„å…ƒç´ ï¼ˆhref ä¸ºç©º/ç¼ºå¤±ï¼‰ï¼Œé¿å…è¢«è¯¯å½“æˆæ™®é€šé“¾æ¥æ–°æ ‡ç­¾æ‰“å¼€ã€‚', { icon: 'âˆ…' }],
                    ['toggle', 'keepFormSelf', 'form é»˜è®¤ç”¨å½“å‰é¡µ', 'è¡¨å•æäº¤é€šå¸¸ä¾èµ–å½“å‰é¡µåˆ·æ–°æˆ–è·³è½¬ï¼Œå¼€å¯åä¸å—å…¨å±€ base target=_blank å½±å“ã€‚', { icon: 'ğŸ§¾' }],
                ]),
            };

            const OBSERVER_GROUP = {
                id: 'observer',
                title: 'ğŸ§· é€‚é… / ç›‘å¬',
                rows: rowsFromTuples([
                    ['toggle', 'enableDiscuz', 'Discuz è®ºå›å¼ºåˆ¶å‹¾é€‰æ–°çª—', 'ä»…åœ¨æ£€æµ‹åˆ° Discuz! è®ºå›ç»“æ„æ—¶ç”Ÿæ•ˆï¼Œè‡ªåŠ¨å‹¾é€‰é¡µé¢ä¸­çš„â€œæ–°çª—â€é€‰é¡¹ã€‚', { icon: 'ğŸ§·' }],
                    ['toggle', 'enableObserver', 'ç›‘å¬åŠ¨æ€åŠ è½½é“¾æ¥', 'å¯¹ AJAX/ç€‘å¸ƒæµç­‰åŠ¨æ€æ’å…¥çš„é“¾æ¥åŒæ ·åº”ç”¨è„šæœ¬è§„åˆ™ï¼Œé€‚åˆé•¿åˆ—è¡¨ã€è¯„è®ºåŒºç­‰ä¸æ–­åŠ è½½å†…å®¹çš„é¡µé¢ã€‚', { icon: 'ğŸ‘€' }],
                ]),
            };

            const TEXT_GROUP = {
                id: 'text',
                title: 'ğŸ”— æ–‡æœ¬é“¾æ¥',
                rows: rowsFromTuples([
                    ['toggle', 'enableTextLinkify', 'æ–‡æœ¬é“¾æ¥è½¬æ¢å™¨', 'å°†çº¯æ–‡æœ¬ä¸­çš„ URL è‡ªåŠ¨è½¬æ¢ä¸ºå¯ç‚¹å‡»é“¾æ¥ï¼Œé€‚åˆæ”»ç•¥ã€è¯´æ˜æ–‡æ¡£ç­‰å‡ºç°è£¸é“¾æ¥çš„é¡µé¢ã€‚', { icon: 'ğŸ”—' }],
                ]),
            };

            const DEBUG_GROUP = {
                id: 'debug',
                title: 'ğŸ è°ƒè¯•',
                rows: rowsFromTuples([
                    ['toggle', 'debugOverlay', 'è°ƒè¯•æ‚¬æµ®çª—', 'æ˜¾ç¤ºå¯æ‹–åŠ¨çš„è°ƒè¯•é¢æ¿ï¼Œè®°å½•ç‚¹å‡»å†³ç­–ä¸è·³è½¬ç»“æœï¼Œä¾¿äºæ’æŸ¥è„šæœ¬æ˜¯å¦å‘½ä¸­é¢„æœŸè§„åˆ™ã€‚', { icon: 'ğŸ' }],
                    ['select', 'debugLogLevel', 'è°ƒè¯•æ—¥å¿—ç­‰çº§', 'æ§åˆ¶è°ƒè¯•æ—¥å¿—çš„æœ€å°çº§åˆ«ã€‚DEBUG æ˜¾ç¤ºå…¨éƒ¨æ—¥å¿—ï¼ŒINFO æ˜¾ç¤ºå…³é”®ä¿¡æ¯ï¼ŒWARN/ERROR ä»…æ˜¾ç¤ºå‘Šè­¦æˆ–é”™è¯¯ã€‚', DEBUG_LOG_LEVEL_OPTIONS, { icon: 'ğŸ“Š' }],
                    ['select', 'debugSyncInterval', 'æ—¥å¿—åŒæ­¥åˆ·æ–°é—´éš”', 'æ§åˆ¶è°ƒè¯•æ—¥å¿—è·¨æ ‡ç­¾é¡µåŒæ­¥çš„åˆ·æ–°é¢‘ç‡ã€‚é—´éš”è¶Šå°è¶Šå®æ—¶ï¼Œä½†å†™å…¥ä¸é€šçŸ¥é¢‘ç‡ä¹Ÿæ›´é«˜ã€‚', DEBUG_SYNC_INTERVAL_OPTIONS, { icon: 'â±' }],
                ]),
            };

            const SETTINGS_UI_GROUPS = [
                BASIC_GROUP,
                READING_GROUP,
                SEARCH_GROUP,
                CSDN_GROUP,
                QQMAIL_GROUP,
                PAN_GROUP,
                HOVER_GROUP,
                PIN_GROUP,
                STRATEGY_GROUP,
                REDIRECT_GROUP,
                APPEARANCE_GROUP,
                EXCEPTIONS_GROUP,
                OBSERVER_GROUP,
                TEXT_GROUP,
                DEBUG_GROUP,
            ];

            function findSettingRow(key) {
                const k = String(key);
                for (let i = 0; i < SETTINGS_UI_GROUPS.length; i++) {
                    const group = SETTINGS_UI_GROUPS[i];
                    const rows = group && group.rows;
                    if (!rows) continue;
                    for (let j = 0; j < rows.length; j++) {
                        const row = rows[j];
                        if (row && row.key === k) return row;
                    }
                }
                return null;
            }

            function validateSettingsSchema(defaults, groups) {
                try {
                    const defaultKeys = Object.keys(defaults || {});
                    const defaultSet = new Set(defaultKeys.map(String));
                    const uiKeys = [];
                    const duplicates = [];
                    const seen = new Set();
                    const incomplete = [];
                    const selectNoOptions = [];
                    for (let i = 0; i < (groups || []).length; i++) {
                        const g = groups[i] || {};
                        const rows = Array.isArray(g.rows) ? g.rows : [];
                        for (let j = 0; j < rows.length; j++) {
                            const r = rows[j] || {};
                            const k = r.key != null ? String(r.key) : '';
                            const t = r.type != null ? String(r.type) : '';
                            const label = r.label != null ? String(r.label) : '';
                            const desc = r.desc != null ? String(r.desc) : '';
                            if (k) {
                                uiKeys.push(k);
                                if (seen.has(k)) duplicates.push(k);
                                else seen.add(k);
                            }
                            if (!k || !t || !label || desc == null) incomplete.push(k || `index_${i}_${j}`);
                            if (t === 'select') {
                                const opts = Array.isArray(r.options) ? r.options : [];
                                if (!opts.length) selectNoOptions.push(k || `index_${i}_${j}`);
                            }
                        }
                    }
                    const uiSet = new Set(uiKeys.map(String));
                    const missingUi = [];
                    const missingDefault = [];
                    defaultSet.forEach((k) => {
                        if (!uiSet.has(k)) missingUi.push(k);
                    });
                    uiSet.forEach((k) => {
                        if (!defaultSet.has(k)) missingDefault.push(k);
                    });
                    if (missingUi.length > 0) {
                        try { console.warn('settings key has no UI row:', missingUi.join(',')); } catch (e) {}
                    }
                    if (missingDefault.length > 0) {
                        try { console.warn('UI row has no default:', missingDefault.join(',')); } catch (e) {}
                    }
                    if (duplicates.length > 0) {
                        try { console.warn('duplicate UI keys:', Array.from(new Set(duplicates)).join(',')); } catch (e) {}
                    }
                    if (incomplete.length > 0) {
                        try { console.warn('incomplete UI rows:', incomplete.join(',')); } catch (e) {}
                    }
                    if (selectNoOptions.length > 0) {
                        try { console.warn('select rows missing options:', selectNoOptions.join(',')); } catch (e) {}
                    }
                } catch (e) {}
            }

            function migrateLegacyLocalStorageOnce() {
                if (migrateLegacyLocalStorageOnce.ran) return;
                migrateLegacyLocalStorageOnce.ran = true;
                const missing = { __newtab_pro_missing: 1 };
                const migrateKey = (keyRaw, validator) => {
                    const key = String(keyRaw || '').trim();
                    if (!key) return false;
                    let cur = missing;
                    try {
                        cur = getValue(key, missing);
                    } catch (e) {
                        cur = missing;
                    }
                    if (cur !== missing) return false;
                    let raw = null;
                    try {
                        raw = localStorage.getItem(key);
                    } catch (e) {
                        raw = null;
                    }
                    if (raw == null) return false;
                    let parsed = safeJsonParse(raw, null);
                    if (parsed == null) parsed = String(raw);
                    if (typeof validator === 'function' && !validator(parsed)) return false;
                    try {
                        setValue(key, parsed);
                    } catch (e) {
                        return false;
                    }
                    try {
                        localStorage.removeItem(key);
                    } catch (e) {}
                    return true;
                };
                const migrateLocalStorageKey = (fromKeyRaw, toKeyRaw, validator) => {
                    const fromKey = String(fromKeyRaw || '').trim();
                    const toKey = String(toKeyRaw || '').trim();
                    if (!fromKey || !toKey) return false;
                    let hasTo = false;
                    try {
                        hasTo = localStorage.getItem(toKey) != null;
                    } catch (e) {
                        hasTo = true;
                    }
                    if (hasTo) return false;
                    let raw = null;
                    try {
                        raw = localStorage.getItem(fromKey);
                    } catch (e2) {
                        raw = null;
                    }
                    if (raw == null) return false;
                    const parsed = safeJsonParse(raw, null);
                    if (typeof validator === 'function' && !validator(parsed)) return false;
                    try {
                        localStorage.setItem(toKey, raw);
                    } catch (e3) {
                        return false;
                    }
                    try {
                        localStorage.removeItem(fromKey);
                    } catch (e4) {}
                    return true;
                };
                try {
                    const keys = Object.keys(DEFAULT_SETTINGS || {});
                    for (let i = 0; i < keys.length; i++) migrateKey(keys[i]);
                } catch (e) {}
                try { migrateKey('visitedLinkHistory', (v) => v && typeof v === 'object' && Array.isArray(v.items)); } catch (e) {}
                try { migrateKey('greasyForkVisitStats', (v) => v && typeof v === 'object' && v.scripts && typeof v.scripts === 'object'); } catch (e) {}
                try { migrateKey('newtab-pro-pan-code-cache', (v) => v && typeof v === 'object' && Array.isArray(v.items)); } catch (e) {}
                try { migrateKey('newtab-pro-pan-code-history', (v) => v && typeof v === 'object' && Array.isArray(v.items)); } catch (e) {}
                try { migrateKey('newtab-pro-pan-code-favorites', (v) => v && typeof v === 'object' && Array.isArray(v.items)); } catch (e) {}
                try { migrateKey('configAuditLog', (v) => Array.isArray(v)); } catch (e) {}
                try { migrateLocalStorageKey('domainVisitCounts', `${STORAGE_PREFIX}domainVisitCounts`, (v) => v && typeof v === 'object' && !Array.isArray(v)); } catch (e) {}
            }

            migrateLegacyLocalStorageOnce();
            validateSettingsSchema(DEFAULT_SETTINGS, SETTINGS_UI_GROUPS);
            const settings = loadSettings(DEFAULT_SETTINGS);
            registerMenus(settings, DEFAULT_SETTINGS);

            let observerStop = null;
            let textLinkifyStop = null;
            let clickInterceptorStop = null;
            let debugOverlayStop = null;
            let autoUnfoldStop = null;
            let csdnStrongCopyStop = null;
            let csdnClipboardBypassStop = null;
            let csdnCleanPageStop = null;
            let csdnCleanPageCssSig = '';
            let csdnCommentStop = null;
            let csdnBottomArticleStop = null;
            let csdnUnfreezeScrollStop = null;
            let csdnLoginJumpGuardStop = null;
            let qqMailCleanVipBubbleStop = null;
            let loginPopupBypassStop = null;
            let panCodeAssistStop = null;
            let itskCloudQueryAutoJumpStop = null;
            let baiduSearchEnhanceStop = null;
            let baiduSearchEnhanceCssSig = '';
            let baiduPinOfficialStop = null;
            let baiduAiAutoExpandStop = null;
            let baiduPaginationPatchStop = null;
            let baiduRecommendListCleanupStop = null;
            let baiduOriginalHeadHtml = '';
            let baiduHeadPatched = false;
            const BAIDU_HIDE_AI_BODY_CLASS = 'newtab-pro-hide-ai';
            const BAIDU_AI_TOGGLE_ID = 'newtab-pro-baidu-ai-toggle';
            const BAIDU_DARK_BODY_CLASS = 'newtab-pro-baidu-dark-mode';
            const BAIDU_FLOAT_DARK_KEY = 'baiduFloatingDarkMode';
            const BAIDU_FLOAT_ROOT_ID = 'newtab-pro-baidu-float-controls';
            const BAIDU_FLOAT_BTN_ID = 'newtab-pro-baidu-float-btn';
            const BAIDU_FLOAT_PANEL_ID = 'newtab-pro-baidu-float-panel';
            const BAIDU_FLOAT_POSITION_KEY = 'baiduFloatingPanelPosition';
            let baiduFloatControlsStop = null;
            let runtimeActive = false;
            let settingsPanelOpening = false;
            let settingsPanelLastOpenAt = 0;
            let smartRedirectAutoJumpDone = false;

            const SCRIPT_LABEL = 'æ–°æ ‡ç­¾é¡µProÂ·å…¨ç«™ç½‘é¡µå¢å¼ºå·¥å…·ç®±';
            const SCRIPT_VERSION = '1.5.343';
            const SCRIPT_UPDATE_URL = (function() {
                try {
                    if (typeof GM_info === 'object' && GM_info && GM_info.script) {
                        if (GM_info.scriptUpdateURL) return GM_info.scriptUpdateURL;
                        if (GM_info.script.updateURL) return GM_info.script.updateURL;
                        if (GM_info.script.downloadURL) return GM_info.script.downloadURL;
                    }
                } catch (e) {}
                return '';
            })();

            const CONFIG_VERSION = 1;
            const TEXT_LINKIFY_MAX_NODES_PER_RUN = 200;
            const A_OBSERVER_MAX_NODES_PER_FLUSH = 200;
            const A_OBSERVER_MAX_PENDING_NODES = 1200;
            const PASSIVE_TIP_STYLE_ID = 'newtab-pro-passive-tip-style';
            const PASSIVE_TIP_ROOT_ID = 'newtab-pro-passive-tip-root';

            const PassiveTipState = {
                root: null,
                lastSig: '',
                lastAt: 0,
                genericTimer: 0,
            };
            const SelectionClickSuppressState = { until: 0, keys: [] };
            const SettingsPanelCache = {
                panHistoryHtml: '',
                panFavoritesHtml: '',
                visitedStatsHtml: '',
                configAuditHtml: '',
            };
            const SmartShortLinkSessionCache = new Map();
            const HostListCompileCache = new Map();
            const HostListResultCache = new Map();
            const TEXT_LINKIFY_PREFIXES = [
                'http://',
                'https://',
                'ftp://',
                'thunder://',
                'ed2k://',
                'magnet:',
                'mailto:',
                'tel:',
                'sms:',
            ];
            const TEXT_LINKIFY_FILE_EXTS = [
                '.zip',
                '.rar',
                '.7z',
                '.exe',
                '.pdf',
                '.docx',
                '.doc',
                '.xlsx',
                '.xls',
                '.pptx',
                '.ppt',
                '.mp4',
                '.mp3',
                '.jpg',
                '.png',
                '.gif',
                '.txt',
                '.json',
                '.js',
                '.css',
            ];
            const TEXT_LINKIFY_PUNCTUATIONS = 'ï¼Œã€‚ï¼ï¼Ÿã€ï¼›ï¼šâ€â€œâ€˜â€™ï¼ˆï¼‰ã€ã€‘ã€Šã€‹â€¦';
            let CombinedTextLinkifyRegexCache = null;
            function escapeRegExpGlobal(s) {
                return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }
            function getAnchorsUnder(root) {
                if (!root || root.nodeType !== 1) return [];
                if (root.tagName === 'A') return [root];
                if (typeof root.getElementsByTagName === 'function') {
                    const list = root.getElementsByTagName('a');
                    const out = [];
                    for (let i = 0; i < list.length; i++) out.push(list[i]);
                    return out;
                }
                if (typeof root.querySelectorAll === 'function') {
                    const list = root.querySelectorAll('a');
                    const out = [];
                    for (let i = 0; i < list.length; i++) out.push(list[i]);
                    return out;
                }
                return [];
            }
            function renderSimpleTable(headers, rowsHtml) {
                const th = Array.isArray(headers) ? headers.map((h) => `<th>${escapeHtml(String(h))}</th>`).join('') : '';
                const body = Array.isArray(rowsHtml) ? rowsHtml.join('') : String(rowsHtml || '');
                return `<table class="configAuditTable"><thead><tr>${th}</tr></thead><tbody>${body}</tbody></table>`;
            }
            function hostListParse(raw) {
                return parseHostListTokens(raw);
            }
            function hostListToTextarea(list) {
                const arr = Array.isArray(list) ? list : [];
                const out = [];
                for (let i = 0; i < arr.length; i++) out.push(`${i + 1}ï¼š${arr[i]}`);
                return out.join('\n');
            }
            function hostListSyncTextarea(el) {
                if (!el) return;
                el.value = hostListToTextarea(hostListParse(el.value));
            }
            function hostListBindTextarea(el, binder) {
                if (!el) return;
                const bind = typeof binder === 'function' ? binder : addListener;
                bind(el, 'blur', () => hostListSyncTextarea(el), { passive: true });
                bind(el, 'paste', () => setTimeout(() => hostListSyncTextarea(el), 0), { passive: true });
                bind(el, 'keydown', (e) => {
                    if (e && e.key === 'Enter') setTimeout(() => hostListSyncTextarea(el), 0);
                }, { passive: true });
            }
            function incMetric(name, delta) {
                try {
                    if (!DebugState.metrics) DebugState.metrics = {};
                    DebugState.metrics[name] = (DebugState.metrics[name] || 0) + (delta || 1);
                } catch (e) {}
            }
            function isPassivePreferred(type) {
                const t = String(type || '').toLowerCase();
                return t === 'touchstart' || t === 'touchmove' || t === 'touchend' || t === 'wheel' || t === 'scroll';
            }
            function addListener(target, type, handler, opts) {
                try {
                    const passive = opts && typeof opts.passive === 'boolean' ? opts.passive : isPassivePreferred(type);
                    const capture = opts && typeof opts.capture === 'boolean' ? opts.capture : true;
                    target.addEventListener(type, handler, { passive, capture });
                } catch (e) {}
            }
            function removeListener(target, type, handler, opts) {
                try {
                    const passive = opts && typeof opts.passive === 'boolean' ? opts.passive : isPassivePreferred(type);
                    const capture = opts && typeof opts.capture === 'boolean' ? opts.capture : true;
                    target.removeEventListener(type, handler, { passive, capture });
                } catch (e) {}
            }
            function scheduleIdleRafTimeout(runLabel, runner, idleTimeout, rafFallback, timeoutMs) {
                if (typeof requestIdleCallback === 'function') {
                    try {
                        return requestIdleCallback(() => withErrorBoundary(runLabel, runner), { timeout: idleTimeout || 600 });
                    } catch (e) {}
                }
                if (typeof requestAnimationFrame === 'function' && rafFallback !== false) {
                    try {
                        return requestAnimationFrame(() => withErrorBoundary(runLabel, runner));
                    } catch (e) {}
                }
                return setTimeout(() => withErrorBoundary(runLabel, runner), timeoutMs || 50);
            }
            function nowPerfMs() {
                try {
                    if (performance && typeof performance.now === 'function') return performance.now();
                } catch (e) {}
                return Date.now();
            }
            function recordPerf(name, ms, extra) {
                try {
                    if (!DebugState.perf) DebugState.perf = { settings: {}, samples: [], kpi: { openMs: 120, layoutMs: 80, styleMs: 60, renderMs: 120 } };
                    const p = DebugState.perf;
                    const s = p.settings || (p.settings = {});
                    const k = String(name || '');
                    if (k) s[k] = ms;
                    const list = Array.isArray(p.samples) ? p.samples : (p.samples = []);
                    list.push({ t: Date.now(), k, ms, x: extra || null });
                    if (list.length > 80) list.splice(0, list.length - 80);
                    updateDebugMetricsUI();
                    if (typeof DebugState.onPerf === 'function') DebugState.onPerf();
                } catch (e) {}
            }
            function measureDomDepth(rootEl, maxNodes) {
                const root = rootEl instanceof Element ? rootEl : null;
                const limit = typeof maxNodes === 'number' && maxNodes > 0 ? Math.floor(maxNodes) : 6000;
                if (!root) return 0;
                let maxDepth = 0;
                let seen = 0;
                const stack = [{ n: root, d: 1 }];
                while (stack.length && seen < limit) {
                    const it = stack.pop();
                    if (!it || !it.n) continue;
                    seen++;
                    if (it.d > maxDepth) maxDepth = it.d;
                    const kids = it.n.children;
                    if (!kids || !kids.length) continue;
                    for (let i = kids.length - 1; i >= 0; i--) {
                        const c = kids[i];
                        if (c) stack.push({ n: c, d: it.d + 1 });
                    }
                }
                return maxDepth;
            }
            const SHORTLINK_DEBOUNCE_DEFAULT_MS = 800;
            const SHORTLINK_CACHE_TTL_MS = 10000;
            const SHORTLINK_CACHE_CLEAN_INTERVAL_MS = 30000;
            let shortLinkCacheCleanupTimer = 0;
            function computeBudgetMs(deadline, minMs = 4, maxMs = 12, fallbackMs = 8) {
                try {
                    if (deadline && typeof deadline.timeRemaining === 'function') {
                        const r = deadline.timeRemaining();
                        if (typeof r === 'number' && r > 0) return Math.min(maxMs, Math.max(minMs, r));
                    }
                } catch (e) {}
                return fallbackMs;
            }
            function getShortLinkDebounceMs(s) {
                try {
                    const v = s && typeof s.shortLinkDebounceMs === 'number' ? s.shortLinkDebounceMs : SHORTLINK_DEBOUNCE_DEFAULT_MS;
                    if (v > 0 && v < 5000) return v;
                } catch (e) {}
                return SHORTLINK_DEBOUNCE_DEFAULT_MS;
            }
            const HostProfileRules = [
                { hosts: ['*.zhihu.com'], flushLimit: 180, pendingLimit: 1000, textLimitMax: 180 },
                { hosts: ['weibo.com', '*.weibo.com'], flushLimit: 180, pendingLimit: 1000, textLimitMax: 180 },
                { hosts: ['*.csdn.net'], flushLimit: 200, pendingLimit: 1000, textLimitMax: 200 },
            ];
            // hostMatchesRule å·²ç”± matchHostList ç»Ÿä¸€æ›¿ä»£
            function getHostProfile() {
                const host = getCurrentHost();
                for (let i = 0; i < HostProfileRules.length; i++) {
                    const r = HostProfileRules[i];
                    if (r && Array.isArray(r.hosts)) {
                        const raw = r.hosts.join(',');
                        if (matchHostList(host, raw)) return r;
                    }
                }
                return null;
            }
            function getCombinedTextLinkifyRegex() {
                if (CombinedTextLinkifyRegexCache) return CombinedTextLinkifyRegexCache;
                const prefixAlt = TEXT_LINKIFY_PREFIXES.map(escapeRegExpGlobal).join('|');
                const rawLinkPattern = `(?:${prefixAlt})[^\\s<>"'${TEXT_LINKIFY_PUNCTUATIONS}]*`;
                CombinedTextLinkifyRegexCache = new RegExp(`\\[[^\\]]*?\\]\\((https?:\\/\\/[^\\s)]+)\\)|\\bwww\\.[^\\s<>"'${TEXT_LINKIFY_PUNCTUATIONS}]*|${rawLinkPattern}`, 'gi');
                return CombinedTextLinkifyRegexCache;
            }
            function getObserverFlushLimit() {
                const p = getHostProfile();
                if (settings && settings.safeModeEnabled) return Math.min(120, (p && p.flushLimit) || A_OBSERVER_MAX_NODES_PER_FLUSH);
                if (p && typeof p.flushLimit === 'number' && p.flushLimit > 0) return p.flushLimit;
                return A_OBSERVER_MAX_NODES_PER_FLUSH;
            }
            function getObserverPendingLimit() {
                const p = getHostProfile();
                if (settings && settings.safeModeEnabled) return Math.min(600, (p && p.pendingLimit) || A_OBSERVER_MAX_PENDING_NODES);
                if (p && typeof p.pendingLimit === 'number' && p.pendingLimit > 0) return p.pendingLimit;
                return A_OBSERVER_MAX_PENDING_NODES;
            }

            function getTextLinkifyRunLimit() {
                try {
                    const n = (document && document.body && document.body.childElementCount) ? document.body.childElementCount : 0;
                    const p = getHostProfile();
                    if (settings && settings.safeModeEnabled) {
                        if (n > 2000) return 120;
                        if (n > 800) return 150;
                        return 180;
                    }
                    if (p && typeof p.textLimitMax === 'number' && p.textLimitMax > 0) {
                        if (n > 2000) return Math.min(150, p.textLimitMax);
                        if (n > 800) return Math.min(200, p.textLimitMax);
                        return Math.min(250, p.textLimitMax);
                    }
                    if (n > 2000) return 150;
                    if (n > 800) return 200;
                    return 250;
                } catch (e) {
                    return 200;
                }
            }

            const SMART_REDIRECT_TIP_STORAGE_KEY = 'newtab-pro-smart-redirect-tip';
            const SMART_REDIRECT_TIP_CROSS_KEY = 'smartRedirectTipCross';
            const PAN_CODE_CACHE_STORAGE_KEY = 'newtab-pro-pan-code-cache';
            const PAN_CODE_HISTORY_STORAGE_KEY = 'newtab-pro-pan-code-history';
            const PAN_CODE_FAVORITES_STORAGE_KEY = 'newtab-pro-pan-code-favorites';
            const PAN_CODE_PENDING_STORAGE_KEY = 'newtab-pro-pan-code-pending';
            const PAN_CODE_FAILURE_STORAGE_KEY = 'newtab-pro-pan-code-failures';
            const PAN_CODE_AUTOFILL_LOCK_KEY = 'newtab-pro-pan-code-autofill-lock';
            const PAN_CODE_PROVIDER_TABLE = [
                { key: 'baidu', provider: 'ç™¾åº¦ç½‘ç›˜', queryKey: 'pwd', hosts: ['pan.baidu.com', 'yun.baidu.com', 'eyun.baidu.com'] },
                { key: 'aliyun', provider: 'é˜¿é‡Œäº‘ç›˜', queryKey: 'pwd', hosts: ['www.aliyundrive.com', 'www.alipan.com', 'alywp.net'] },
                { key: '123pan', provider: '123ç›˜', queryKey: 'pwd', hosts: ['123pan.com', 'www.123pan.com'] },
                { key: 'quark', provider: 'å¤¸å…‹ç½‘ç›˜', queryKey: '', hosts: ['pan.quark.cn', 'drive.quark.cn'] },
                { key: 'uc', provider: 'UC ç½‘ç›˜', queryKey: '', hosts: ['drive.uc.cn'] },
                { key: '189', provider: 'å¤©ç¿¼äº‘ç›˜', queryKey: '', hosts: ['cloud.189.cn'] },
                { key: 'weiyun', provider: 'è…¾è®¯å¾®äº‘', queryKey: '', hosts: ['share.weiyun.com', 'weiyun.com', 'www.weiyun.com'] },
                { key: 'xunlei', provider: 'è¿…é›·äº‘ç›˜', queryKey: '', hosts: ['pan.xunlei.com', 'www.pan.xunlei.com'] },
                { key: 'caiyun', provider: 'å’Œå½©äº‘', queryKey: '', hosts: ['caiyun.139.com', 'yun.139.com', 'pan.139.com'] },
                {
                    key: 'ctfile',
                    provider: 'åŸé€šç½‘ç›˜',
                    queryKey: '',
                    hosts: ['www.ctfile.com', 'ctfile.com', '545c.com', 'u062.com', 'ghpym.com'],
                    matchHost: (h) => {
                        const host = String(h || '').trim().toLowerCase();
                        if (!host) return false;
                        return (
                            host === 'ctfile.com' ||
                            host.endsWith('.ctfile.com') ||
                            host === '545c.com' ||
                            host.endsWith('.545c.com') ||
                            host === 'u062.com' ||
                            host.endsWith('.u062.com') ||
                            host === 'ghpym.com' ||
                            host.endsWith('.ghpym.com')
                        );
                    },
                },
                { key: 'cowtransfer', provider: 'å¥¶ç‰›å¿«ä¼ ', queryKey: '', hosts: ['www.cowtransfer.com', 'cowtransfer.com'] },
                { key: 'wenshushu', provider: 'æ–‡å”å”', queryKey: '', hosts: ['www.wenshushu.cn', 'wenshushu.cn', 'ws28.cn'] },
                { key: 'flowus', provider: 'FlowUs', queryKey: '', hosts: ['flowus.cn', 'www.flowus.cn'], matchHost: (h) => String(h || '').toLowerCase().endsWith('.flowus.cn') },
                { key: 'lanzou', provider: 'è“å¥äº‘', queryKey: 'pwd', matchHost: (h) => /lanzou|lanzn|lanzx|lanpv/i.test(String(h || '')) },
                {
                    key: '360',
                    provider: '360äº‘ç›˜',
                    queryKey: '',
                    hosts: ['yunpan.360.cn', 'link.yunpan.360.cn', 'yunpan.com', 'www.yunpan.com'],
                    matchHost: (h) => {
                        const host = String(h || '').trim().toLowerCase();
                        if (!host) return false;
                        return host === 'yunpan.360.cn' || host.endsWith('.yunpan.360.cn') || host === 'yunpan.com' || host.endsWith('.yunpan.com');
                    },
                },
                { key: 'wo', provider: 'è”é€šäº‘ç›˜', queryKey: '', hosts: ['pan.wo.cn', 'panservice.mail.wo.cn'] },
                { key: 'jianguoyun', provider: 'åšæœäº‘', queryKey: '', hosts: ['www.jianguoyun.com'] },
                { key: 'vdisk', provider: 'å¾®ç›˜', queryKey: '', hosts: ['vdisk.weibo.com'] },
                { key: 'mega', provider: 'Mega', queryKey: '', hosts: ['mega.nz', 'mega.co.nz'] },
                {
                    key: '115',
                    provider: '115 ç½‘ç›˜',
                    queryKey: '',
                    matchHost: (h) => {
                        const host = String(h || '').trim().toLowerCase();
                        if (!host) return false;
                        return (
                            host === '115.com' ||
                            host.endsWith('.115.com') ||
                            host === '115cdn.com' ||
                            host.endsWith('.115cdn.com') ||
                            host === 'anxia.com' ||
                            host.endsWith('.anxia.com')
                        );
                    },
                },
            ];
            const PanCodeProviderIndex = (function() {
                const exactMap = new Map();
                const matchers = [];
                for (let i = 0; i < PAN_CODE_PROVIDER_TABLE.length; i++) {
                    const row = PAN_CODE_PROVIDER_TABLE[i];
                    if (!row || !row.key || !row.provider) continue;
                    const info = { provider: String(row.provider), key: String(row.key), queryKey: String(row.queryKey || '') };
                    const hosts = Array.isArray(row.hosts) ? row.hosts : [];
                    for (let j = 0; j < hosts.length; j++) {
                        const h = String(hosts[j] || '').trim().toLowerCase();
                        if (!h) continue;
                        exactMap.set(h, info);
                    }
                    if (typeof row.matchHost === 'function') matchers.push({ test: row.matchHost, info });
                }
                return { exactMap, matchers };
            })();
            const SmartRedirectHintState = {
                anchorTip: new WeakMap(),
                tipRecheckAllowed: false,
                tipRecheckCleanup: null,
            };

            function stashSmartRedirectTip(message) {
                if (!isTopWindow()) return;
                const msg = String(message || '').trim();
                if (!msg) return;
                try {
                    sessionStorage.setItem(SMART_REDIRECT_TIP_STORAGE_KEY, JSON.stringify({ msg, t: Date.now() }));
                } catch (e) {}
            }

            function consumeSmartRedirectTip(shouldShow) {
                if (!isTopWindow()) return false;
                let raw = '';
                try {
                    raw = sessionStorage.getItem(SMART_REDIRECT_TIP_STORAGE_KEY) || '';
                } catch (e) {
                    raw = '';
                }
                if (!raw) return false;
                try {
                    sessionStorage.removeItem(SMART_REDIRECT_TIP_STORAGE_KEY);
                } catch (e) {}
                const data = safeJsonParse(raw, null);
                const msg = data && typeof data === 'object' ? String(data.msg || '').trim() : '';
                const t = data && typeof data === 'object' && typeof data.t === 'number' ? data.t : 0;
                if (!msg) return false;
                if (t && Date.now() - t > 30000) return false;
                if (!shouldShow) return false;
                showPassiveTip(msg);
                return true;
            }

            function normalizeTipUrl(href) {
                const raw = String(href || '').trim();
                if (!raw) return '';
                try {
                    return new URL(raw).href;
                } catch (e) {
                    return raw;
                }
            }

            function buildTipUrlVariants(href) {
                const base = normalizeTipUrl(href);
                if (!base) return [];
                const set = new Set();
                const addHref = (h) => {
                    const s = String(h || '').trim();
                    if (!s) return;
                    if (set.size >= 18) return;
                    set.add(s);
                };
                const addUrl = (u) => {
                    try {
                        addHref(u.href);
                    } catch (e) {}
                };
                let u;
                try {
                    u = new URL(base);
                } catch (e) {
                    addHref(base);
                    return Array.from(set);
                }

                const trackingKey = (k) => {
                    const key = String(k || '');
                    if (!key) return false;
                    if (/^utm_/i.test(key)) return true;
                    return /^(spm|spm_id_from|from|source|src|ref|referer|referrer|share|share_source|share_id|share_token|track|tracking|channel|scene|vd_source|business_id|from_source)$/i.test(key);
                };
                const withNoHash = (src) => {
                    const n = new URL(src.href);
                    n.hash = '';
                    return n;
                };
                const withNoSearch = (src) => {
                    const n = new URL(src.href);
                    n.search = '';
                    n.hash = '';
                    return n;
                };
                const withSortedSearch = (src) => {
                    const entries = [];
                    try {
                        for (const [k, v] of src.searchParams.entries()) entries.push([k, v]);
                    } catch (e) {}
                    if (!entries.length) return null;
                    entries.sort((a, b) => (a[0] === b[0] ? (a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0) : a[0] < b[0] ? -1 : 1));
                    const n = new URL(src.href);
                    n.search = '';
                    for (let i = 0; i < entries.length; i++) n.searchParams.append(entries[i][0], entries[i][1]);
                    return n;
                };
                const withCleanTracking = (src) => {
                    const n = new URL(src.href);
                    if (!n.searchParams) return null;
                    const keys = [];
                    try {
                        for (const k of n.searchParams.keys()) keys.push(k);
                    } catch (e) {}
                    if (!keys.length) return null;
                    let changed = false;
                    for (let i = 0; i < keys.length; i++) {
                        const k = keys[i];
                        if (!trackingKey(k)) continue;
                        try {
                            n.searchParams.delete(k);
                            changed = true;
                        } catch (e) {}
                    }
                    if (!changed) return null;
                    return n;
                };
                const addSlashVariants = (src) => {
                    const pathname = String(src.pathname || '');
                    if (!pathname || pathname === '/') return;
                    if (pathname.endsWith('/')) {
                        const n = new URL(src.href);
                        n.pathname = pathname.replace(/\/+$/, '');
                        addUrl(n);
                    } else {
                        const n = new URL(src.href);
                        n.pathname = `${pathname}/`;
                        addUrl(n);
                    }
                };
                const addSchemeVariants = (src) => {
                    const p = String(src.protocol || '').toLowerCase();
                    if (p !== 'http:' && p !== 'https:') return;
                    const n = new URL(src.href);
                    n.protocol = p === 'http:' ? 'https:' : 'http:';
                    addUrl(n);
                };
                const addWwwVariants = (src) => {
                    const host = String(src.hostname || '').toLowerCase();
                    if (!host || host === 'localhost') return;
                    if (/^\d{1,3}(\.\d{1,3}){3}$/.test(host)) return;
                    if (host.startsWith('www.')) {
                        const n = new URL(src.href);
                        n.hostname = host.slice(4);
                        addUrl(n);
                        return;
                    }
                    const n = new URL(src.href);
                    n.hostname = `www.${host}`;
                    addUrl(n);
                };

                addUrl(u);
                addUrl(withNoHash(u));
                addUrl(withNoSearch(u));

                const sorted = withSortedSearch(u);
                if (sorted) {
                    addUrl(sorted);
                    addUrl(withNoHash(sorted));
                    addUrl(withNoSearch(sorted));
                }

                const cleaned = withCleanTracking(u);
                if (cleaned) {
                    addUrl(cleaned);
                    addUrl(withNoHash(cleaned));
                    addUrl(withNoSearch(cleaned));
                    const cleanedSorted = withSortedSearch(cleaned);
                    if (cleanedSorted) {
                        addUrl(cleanedSorted);
                        addUrl(withNoHash(cleanedSorted));
                        addUrl(withNoSearch(cleanedSorted));
                    }
                }

                addSlashVariants(u);
                if (sorted) addSlashVariants(sorted);
                if (cleaned) addSlashVariants(cleaned);

                const snapshot = Array.from(set);
                for (let i = 0; i < snapshot.length && set.size < 18; i++) {
                    let v;
                    try {
                        v = new URL(snapshot[i]);
                    } catch (e) {
                        continue;
                    }
                    addSchemeVariants(v);
                    addWwwVariants(v);
                }
                return Array.from(set);
            }

            function stopSmartRedirectTipRecheck() {
                if (!SmartRedirectHintState.tipRecheckCleanup) return;
                try {
                    SmartRedirectHintState.tipRecheckCleanup();
                } catch (e) {}
                SmartRedirectHintState.tipRecheckCleanup = null;
            }

            function ensureSmartRedirectTipRecheck() {
                if (!isTopWindow()) return;
                if (SmartRedirectHintState.tipRecheckCleanup) return;
                const startAt = Date.now();
                const historyObj = window.history;
                const origPushState = historyObj && typeof historyObj.pushState === 'function' ? historyObj.pushState : null;
                const origReplaceState = historyObj && typeof historyObj.replaceState === 'function' ? historyObj.replaceState : null;
                let stopped = false;

                const tryConsume = () => {
                    if (stopped) return;
                    if (!SmartRedirectHintState.tipRecheckAllowed) return;
                    if (Date.now() - startAt > 30500) return cleanup();
                    if (consumeSmartRedirectTipForUrl(location.href, true)) return cleanup();
                };
                const onChange = () => setTimeout(tryConsume, 0);

                const timers = [];
                const schedule = (ms) => {
                    try {
                        const t = setTimeout(tryConsume, ms);
                        timers.push(t);
                    } catch (e) {}
                };

                const cleanup = () => {
                    if (stopped) return;
                    stopped = true;
                    try {
                        window.removeEventListener('hashchange', onChange, true);
                        window.removeEventListener('popstate', onChange, true);
                    } catch (e) {}
                    for (let i = 0; i < timers.length; i++) {
                        try {
                            clearTimeout(timers[i]);
                        } catch (e) {}
                    }
                    try {
                        if (historyObj && origPushState) historyObj.pushState = origPushState;
                        if (historyObj && origReplaceState) historyObj.replaceState = origReplaceState;
                    } catch (e) {}
                    SmartRedirectHintState.tipRecheckCleanup = null;
                };

                SmartRedirectHintState.tipRecheckCleanup = cleanup;
                try {
                    window.addEventListener('hashchange', onChange, true);
                    window.addEventListener('popstate', onChange, true);
                } catch (e) {}
                tryConsume();
                schedule(220);
                schedule(850);
                schedule(2200);
                schedule(5200);
                schedule(12000);
                schedule(22000);

                try {
                    if (historyObj && origPushState) {
                        historyObj.pushState = function() {
                            const r = origPushState.apply(this, arguments);
                            onChange();
                            return r;
                        };
                    }
                    if (historyObj && origReplaceState) {
                        historyObj.replaceState = function() {
                            const r = origReplaceState.apply(this, arguments);
                            onChange();
                            return r;
                        };
                    }
                } catch (e) {}
            }

            function scheduleGenericActiveTip(message) {
                if (!isTopWindow()) return;
                if (PassiveTipState.genericTimer) {
                    try {
                        clearTimeout(PassiveTipState.genericTimer);
                    } catch (e) {}
                    PassiveTipState.genericTimer = 0;
                }
                const msg = String(message || '').trim();
                try {
                    PassiveTipState.genericTimer = setTimeout(() => {
                        PassiveTipState.genericTimer = 0;
                        if (!runtimeActive) return;
                        if (consumeSmartRedirectTipForUrl(location.href, true)) return;
                        showPassiveTip(msg || 'æ–°æ ‡ç­¾é¡µProï¼šå·²ç”Ÿæ•ˆ');
                    }, 700);
                } catch (e) {}
            }

            const VISITED_ATTR = 'data-newtab-open-links-visited';
            const VISITED_ELIGIBLE_ATTR = 'data-newtab-open-links-visited-eligible';
            const VISITED_HISTORY_STORAGE_KEY = 'visitedLinkHistory';
            const GREASYFORK_VISIT_STATS_STORAGE_KEY = 'greasyForkVisitStats';
            const VisitedLinkState = {
                loaded: false,
                map: new Map(),
                saveTimer: 0,
                sortedDirty: true,
                sortedEntries: null,
            };
            const GreasyForkVisitStatsState = {
                loaded: false,
                data: null,
                saveTimer: 0,
            };

            function ensureGreasyForkVisitStatsLoaded() {
                if (GreasyForkVisitStatsState.loaded) return;
                GreasyForkVisitStatsState.loaded = true;
                GreasyForkVisitStatsState.data = {
                    v: 1,
                    t: 0,
                    scripts: {},
                    summary: { totalScripts: 0, totalVisits: 0, first: 0, last: 0 },
                };
                const raw = getValue(GREASYFORK_VISIT_STATS_STORAGE_KEY, null);
                const data = raw && typeof raw === 'object' ? raw : null;
                if (!data) return;
                const scriptsRaw = data.scripts && typeof data.scripts === 'object' ? data.scripts : null;
                const summaryRaw = data.summary && typeof data.summary === 'object' ? data.summary : null;
                const nextScripts = {};
                const ids = scriptsRaw ? Object.keys(scriptsRaw) : [];
                for (let i = 0; i < ids.length; i++) {
                    const id = String(ids[i] || '').trim();
                    if (!/^\d+$/.test(id)) continue;
                    const it = scriptsRaw[id];
                    if (!it) continue;
                    let c = 0;
                    let first = 0;
                    let last = 0;
                    if (Array.isArray(it)) {
                        c = typeof it[0] === 'number' ? it[0] : 0;
                        first = typeof it[1] === 'number' ? it[1] : 0;
                        last = typeof it[2] === 'number' ? it[2] : 0;
                    } else if (typeof it === 'object') {
                        c = typeof it.c === 'number' ? it.c : 0;
                        first = typeof it.first === 'number' ? it.first : 0;
                        last = typeof it.last === 'number' ? it.last : 0;
                    }
                    if (!c || !last) continue;
                    if (!first) first = last;
                    nextScripts[id] = [c, first, last];
                }
                const next = GreasyForkVisitStatsState.data;
                next.t = typeof data.t === 'number' ? data.t : 0;
                next.scripts = nextScripts;
                if (summaryRaw) {
                    next.summary = {
                        totalScripts: typeof summaryRaw.totalScripts === 'number' ? summaryRaw.totalScripts : 0,
                        totalVisits: typeof summaryRaw.totalVisits === 'number' ? summaryRaw.totalVisits : 0,
                        first: typeof summaryRaw.first === 'number' ? summaryRaw.first : 0,
                        last: typeof summaryRaw.last === 'number' ? summaryRaw.last : 0,
                    };
                }
                if (!next.summary.totalScripts || !next.summary.totalVisits || !next.summary.last) {
                    recomputeGreasyForkSummary(next);
                }
            }

            function recomputeGreasyForkSummary(data) {
                const scripts = (data && data.scripts) || {};
                const ids = Object.keys(scripts);
                let totalVisits = 0;
                let first = 0;
                let last = 0;
                for (let i = 0; i < ids.length; i++) {
                    const it = scripts[ids[i]];
                    if (!it || !Array.isArray(it)) continue;
                    const c = typeof it[0] === 'number' ? it[0] : 0;
                    const f = typeof it[1] === 'number' ? it[1] : 0;
                    const l = typeof it[2] === 'number' ? it[2] : 0;
                    if (!c || !l) continue;
                    totalVisits += c;
                    if (f && (!first || f < first)) first = f;
                    if (l && l > last) last = l;
                }
                data.summary = { totalScripts: ids.length, totalVisits, first, last };
            }

            function flushGreasyForkVisitStatsToStorage() {
                if (!GreasyForkVisitStatsState.saveTimer) return;
                try {
                    clearTimeout(GreasyForkVisitStatsState.saveTimer);
                } catch (e) {}
                GreasyForkVisitStatsState.saveTimer = 0;
                ensureGreasyForkVisitStatsLoaded();
                const data = GreasyForkVisitStatsState.data;
                if (!data) return;
                data.t = Date.now();
                try {
                    setValue(GREASYFORK_VISIT_STATS_STORAGE_KEY, data);
                } catch (e) {}
            }

            function scheduleFlushGreasyForkVisitStats() {
                if (GreasyForkVisitStatsState.saveTimer) return;
                try {
                    GreasyForkVisitStatsState.saveTimer = setTimeout(flushGreasyForkVisitStatsToStorage, 600);
                } catch (e) {
                    GreasyForkVisitStatsState.saveTimer = 0;
                }
            }

            function extractGreasyForkScriptId(urlRaw) {
                const s = String(urlRaw || '').trim();
                if (!s || s.indexOf('greasyfork.org') === -1) return '';
                let u;
                try {
                    u = new URL(s, location.href);
                } catch (e) {
                    return '';
                }
                const host = String(u.hostname || '').trim().toLowerCase();
                if (!host || !(host === 'greasyfork.org' || host.endsWith('.greasyfork.org'))) return '';
                const path = String(u.pathname || '');
                const m = /^\/(?:[a-zA-Z-]+\/)?scripts\/(\d+)(?:[\/-]|$)/.exec(path);
                return m ? String(m[1] || '') : '';
            }

            function recordGreasyForkScriptVisitIfNeeded(href, currentSettings, now) {
                if (!currentSettings || !currentSettings.greasyForkVisitStatsEnabled) return;
                const id = extractGreasyForkScriptId(href);
                if (!id) return;
                ensureGreasyForkVisitStatsLoaded();
                const data = GreasyForkVisitStatsState.data;
                if (!data) return;
                const scripts = data.scripts || (data.scripts = {});
                const existing = scripts[id];
                if (existing && Array.isArray(existing)) {
                    existing[0] = (typeof existing[0] === 'number' ? existing[0] : 0) + 1;
                    existing[2] = now;
                } else {
                    scripts[id] = [1, now, now];
                }
                const summary = data.summary || (data.summary = { totalScripts: 0, totalVisits: 0, first: 0, last: 0 });
                summary.totalVisits = (typeof summary.totalVisits === 'number' ? summary.totalVisits : 0) + 1;
                if (!existing) summary.totalScripts = (typeof summary.totalScripts === 'number' ? summary.totalScripts : 0) + 1;
                if (!summary.first || now < summary.first) summary.first = now;
                if (!summary.last || now > summary.last) summary.last = now;
                if (summary.totalScripts > 3200) {
                    trimGreasyForkScriptsToMax(data, 3000);
                    recomputeGreasyForkSummary(data);
                }
                scheduleFlushGreasyForkVisitStats();
            }

            function trimGreasyForkScriptsToMax(data, max) {
                const scripts = (data && data.scripts) || {};
                const ids = Object.keys(scripts);
                const limit = typeof max === 'number' && max > 0 ? Math.floor(max) : 3000;
                if (ids.length <= limit) return;
                const list = [];
                for (let i = 0; i < ids.length; i++) {
                    const id = ids[i];
                    const it = scripts[id];
                    const last = it && Array.isArray(it) && typeof it[2] === 'number' ? it[2] : 0;
                    list.push([id, last]);
                }
                list.sort((a, b) => (a[1] || 0) - (b[1] || 0));
                const removeCount = Math.max(0, list.length - limit);
                for (let i = 0; i < removeCount; i++) {
                    delete scripts[list[i][0]];
                }
            }

            function getGreasyForkScriptVisitCountByUrl(urlRaw) {
                const url = String(urlRaw || '').trim();
                if (!url || url.indexOf('greasyfork.org') === -1) return null;
                const id = extractGreasyForkScriptId(url);
                if (!id) return null;
                ensureGreasyForkVisitStatsLoaded();
                const data = GreasyForkVisitStatsState.data;
                const it = data && data.scripts ? data.scripts[id] : null;
                if (!it || !Array.isArray(it)) return null;
                const c = typeof it[0] === 'number' ? it[0] : 0;
                return c > 0 ? c : null;
            }

            function getGreasyForkVisitSummary() {
                ensureGreasyForkVisitStatsLoaded();
                const data = GreasyForkVisitStatsState.data;
                const s = data && data.summary ? data.summary : null;
                if (!s || !s.totalVisits) return null;
                return {
                    totalScripts: typeof s.totalScripts === 'number' ? s.totalScripts : 0,
                    totalVisits: typeof s.totalVisits === 'number' ? s.totalVisits : 0,
                    first: typeof s.first === 'number' ? s.first : 0,
                    last: typeof s.last === 'number' ? s.last : 0,
                };
            }

            function applyVisitedLinkColor(runtimeShouldActive, currentSettings) {
                const styleId = 'newtab-open-links-visited-link-style';
                const managedAttr = 'data-newtab-open-links-managed';
                const existing = document.getElementById(styleId);
                const shouldEnable = Boolean(runtimeShouldActive) && Boolean(currentSettings && currentSettings.visitedLinkColorEnabled);
                if (!shouldEnable) {
                    if (existing) existing.remove();
                    return;
                }
                let color = String((currentSettings && currentSettings.visitedLinkColor) || '').trim();
                if (!/^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(color)) color = '#8b5cf6';
                const css = `a[${managedAttr}][${VISITED_ELIGIBLE_ATTR}="1"]:visited{color:${color} !important;}a[${VISITED_ATTR}="1"][${VISITED_ELIGIBLE_ATTR}="1"],a[${VISITED_ATTR}="1"][${VISITED_ELIGIBLE_ATTR}="1"] *{color:${color} !important;}`;
                if (existing && existing.textContent === css) return;
                const style = existing || document.createElement('style');
                style.id = styleId;
                style.type = 'text/css';
                style.textContent = css;
                try {
                    (document.head || document.documentElement || document.body || document).appendChild(style);
                } catch (e) {}
            }

            function normalizeVisitedHrefKey(href) {
                const base = normalizeTipUrl(href);
                if (!base) return '';
                let u;
                try {
                    u = new URL(base);
                } catch (e) {
                    return base.split('#')[0];
                }
                try {
                    u.hash = '';
                } catch (e) {}
                const trackingKey = (k) => {
                    const key = String(k || '');
                    if (!key) return false;
                    if (/^utm_/i.test(key)) return true;
                    return /^(spm|spm_id_from|from|source|src|ref|referer|referrer|share|share_source|share_id|share_token|track|tracking|channel|scene|vd_source|business_id|from_source)$/i.test(key);
                };
                let changed = false;
                try {
                    const keys = [];
                    for (const k of u.searchParams.keys()) keys.push(k);
                    for (let i = 0; i < keys.length; i++) {
                        const k = keys[i];
                        if (!trackingKey(k)) continue;
                        u.searchParams.delete(k);
                        changed = true;
                    }
                } catch (e) {}
                if (changed && String(u.search || '') === '?') {
                    try {
                        u.search = '';
                    } catch (e) {}
                }
                try {
                    return u.href;
                } catch (e) {
                    return base.split('#')[0];
                }
            }

            function resolveVisitedHistoryScope(currentSettings) {
                const v = String((currentSettings && currentSettings.visitedLinkHistoryScope) || '').trim().toLowerCase();
                return v === 'site' ? 'site' : 'global';
            }

            function buildVisitedHistoryKey(href, currentSettings, pageHost) {
                const key = normalizeVisitedHrefKey(href);
                if (!key) return '';
                if (resolveVisitedHistoryScope(currentSettings) !== 'site') return key;
                const host = String(pageHost || getCurrentHost() || '').trim().toLowerCase();
                return host ? `${host}|${key}` : key;
            }

            function ensureVisitedLinkStateLoaded() {
                if (VisitedLinkState.loaded) return;
                VisitedLinkState.loaded = true;
                VisitedLinkState.sortedDirty = true;
                VisitedLinkState.sortedEntries = null;
                const raw = getValue(VISITED_HISTORY_STORAGE_KEY, null);
                const data = raw && typeof raw === 'object' ? raw : null;
                const items = data && Array.isArray(data.items) ? data.items : [];
                const now = Date.now();
                const maxAgeMs = 180 * 24 * 60 * 60 * 1000;
                for (let i = 0; i < items.length; i++) {
                    const it = items[i];
                    if (!it || !Array.isArray(it)) continue;
                    const key = String(it[0] || '').trim();
                    const t = typeof it[1] === 'number' ? it[1] : 0;
                    if (!key || !t) continue;
                    if (now - t > maxAgeMs) continue;
                    VisitedLinkState.map.set(key, t);
                }
                if (VisitedLinkState.map.size > 3000) {
                    const entries = Array.from(VisitedLinkState.map.entries());
                    entries.sort((a, b) => a[1] - b[1]);
                    VisitedLinkState.map.clear();
                    for (let i = Math.max(0, entries.length - 3000); i < entries.length; i++) VisitedLinkState.map.set(entries[i][0], entries[i][1]);
                    VisitedLinkState.sortedDirty = true;
                    VisitedLinkState.sortedEntries = null;
                }
            }

            function getVisitedEntriesSorted() {
                ensureVisitedLinkStateLoaded();
                if (!VisitedLinkState.sortedDirty && Array.isArray(VisitedLinkState.sortedEntries)) return VisitedLinkState.sortedEntries;
                const entries = Array.from(VisitedLinkState.map.entries());
                entries.sort((a, b) => (b[1] || 0) - (a[1] || 0));
                VisitedLinkState.sortedEntries = entries;
                VisitedLinkState.sortedDirty = false;
                return entries;
            }

            function flushVisitedLinkStateToStorage() {
                if (!VisitedLinkState.saveTimer) return;
                try {
                    clearTimeout(VisitedLinkState.saveTimer);
                } catch (e) {}
                VisitedLinkState.saveTimer = 0;
                const now = Date.now();
                const entries = Array.from(VisitedLinkState.map.entries());
                entries.sort((a, b) => b[1] - a[1]);
                VisitedLinkState.sortedEntries = entries;
                VisitedLinkState.sortedDirty = false;
                const items = [];
                for (let i = 0; i < entries.length && i < 3000; i++) items.push([entries[i][0], entries[i][1]]);
                try {
                    setValue(VISITED_HISTORY_STORAGE_KEY, { v: 1, t: now, items });
                } catch (e) {}
            }

            function scheduleFlushVisitedLinkState() {
                if (VisitedLinkState.saveTimer) return;
                try {
                    VisitedLinkState.saveTimer = setTimeout(flushVisitedLinkStateToStorage, 600);
                } catch (e) {
                    VisitedLinkState.saveTimer = 0;
                }
            }

            function recordVisitedHref(href, currentSettings, pageHost) {
                const scope = resolveVisitedHistoryScope(currentSettings);
                const key = buildVisitedHistoryKey(href, currentSettings, pageHost);
                if (!key) return;
                ensureVisitedLinkStateLoaded();
                const now = Date.now();
                try {
                    recordGreasyForkScriptVisitIfNeeded(href, currentSettings, now);
                } catch (e) {}
                if (scope === 'site') {
                    const globalKey = normalizeVisitedHrefKey(href);
                    if (globalKey && globalKey !== key && VisitedLinkState.map.has(globalKey)) VisitedLinkState.map.delete(globalKey);
                }
                if (VisitedLinkState.map.has(key)) VisitedLinkState.map.delete(key);
                VisitedLinkState.map.set(key, now);
                VisitedLinkState.sortedDirty = true;
                VisitedLinkState.sortedEntries = null;
                if (VisitedLinkState.map.size > 3200) {
                    const entries = Array.from(VisitedLinkState.map.entries());
                    entries.sort((a, b) => a[1] - b[1]);
                    VisitedLinkState.map.clear();
                    for (let i = Math.max(0, entries.length - 3000); i < entries.length; i++) VisitedLinkState.map.set(entries[i][0], entries[i][1]);
                    VisitedLinkState.sortedDirty = true;
                    VisitedLinkState.sortedEntries = null;
                }
                scheduleFlushVisitedLinkState();
            }

            function repairDoubleSchemeUrl(href) {
                let s = String(href || '').trim();
                if (!s) return '';
                const fixOneSlash = (x) => String(x || '').replace(/^https?:\/(?!\/)/i, (m) => `${m}/`);
                s = fixOneSlash(s);
                for (let i = 0; i < 2; i++) {
                    const m = /^(https?:\/\/)(https?:\/\/.+)$/i.exec(s);
                    if (!m) break;
                    s = fixOneSlash(m[2]);
                }
                return s;
            }

            function resolveAbsoluteHref(hrefRaw, anchorEl) {
                const raw = hrefRaw == null ? '' : String(hrefRaw).trim();
                if (!raw) return '';
                if (raw.indexOf('://') !== -1) return repairDoubleSchemeUrl(raw);
                if (raw.startsWith('//')) return `${location.protocol}${repairDoubleSchemeUrl(raw)}`;
                if (raw[0] === '/') return `${location.origin}${repairDoubleSchemeUrl(raw)}`;
                if (raw[0] === '?') return `${location.origin}${location.pathname}${repairDoubleSchemeUrl(raw)}`;
                if (raw[0] === '#') return `${location.origin}${location.pathname}${location.search}${repairDoubleSchemeUrl(raw)}`;
                try {
                    if (anchorEl && anchorEl.href) return repairDoubleSchemeUrl(String(anchorEl.href));
                } catch (e) {}
                try {
                    return repairDoubleSchemeUrl(new URL(raw, location.href).href);
                } catch (e) {
                    return '';
                }
            }

            function isVisitedColorEligibleAnchor(anchor, absoluteHref) {
                if (!anchor || anchor.tagName !== 'A') return false;
                let hrefRaw = '';
                try {
                    const hrefAttr = anchor.getAttribute('href');
                    hrefRaw = hrefAttr == null ? '' : String(hrefAttr).trim();
                } catch (e) {
                    hrefRaw = '';
                }
                const href = String(absoluteHref || '').trim() || (() => {
                    try {
                        return String(anchor.href || '').trim();
                    } catch (e) {
                        return '';
                    }
                })();
                if (!href) return false;
                if (hrefRaw && hrefRaw[0] === '#') return false;
                if (/^(?:javascript|data):/i.test(href)) return false;
                try {
                    const u = new URL(href, location.href);
                    const cur = new URL(location.href);
                    if (u.origin === cur.origin && u.pathname === cur.pathname) return false;
                } catch (e) {}
                try {
                    const u = new URL(href, location.href);
                    const provider = getPanCodeProviderInfoByHost(String(u.hostname || ''));
                    if (provider) return true;
                } catch (e) {}
                const tokenRe = /(?:^|[\s_-])(nav|navbar|header|footer|breadcrumb|crumb|pagination|pager|tabs?|tablist|filter|sort|order|category|categories|tags?|menu|menubar|toolbar|sidebar)(?:$|[\s_-])/i;
                let el = anchor;
                for (let i = 0; el && i < 7; i++) {
                    try {
                        const tn = String(el.tagName || '').toUpperCase();
                        if (tn === 'NAV' || tn === 'HEADER' || tn === 'FOOTER' || tn === 'ASIDE') return false;
                        const role = el.getAttribute ? String(el.getAttribute('role') || '').toLowerCase() : '';
                        if (role === 'navigation' || role === 'menu' || role === 'menubar' || role === 'tablist' || role === 'tab' || role === 'toolbar') return false;
                        const id = el.id ? String(el.id) : '';
                        const cls = el.className ? String(el.className) : '';
                        if ((id || cls) && tokenRe.test(` ${id} ${cls} `)) return false;
                    } catch (e) {}
                    el = el.parentElement;
                }
                return true;
            }

            function syncVisitedEligibleAttrForAnchor(anchor, currentSettings, pageHost, absoluteHref) {
                if (!anchor || anchor.tagName !== 'A') return false;
                const enabled = Boolean(currentSettings && currentSettings.visitedLinkColorEnabled);
                if (!enabled) {
                    try {
                        if (anchor.hasAttribute(VISITED_ELIGIBLE_ATTR)) anchor.removeAttribute(VISITED_ELIGIBLE_ATTR);
                        if (anchor.hasAttribute(VISITED_ATTR)) anchor.removeAttribute(VISITED_ATTR);
                    } catch (e) {}
                    return false;
                }
                const eligible = isVisitedColorEligibleAnchor(anchor, absoluteHref);
                if (eligible) {
                    try {
                        if (anchor.getAttribute(VISITED_ELIGIBLE_ATTR) !== '1') anchor.setAttribute(VISITED_ELIGIBLE_ATTR, '1');
                    } catch (e) {}
                    return true;
                }
                try {
                    if (anchor.hasAttribute(VISITED_ELIGIBLE_ATTR)) anchor.removeAttribute(VISITED_ELIGIBLE_ATTR);
                    if (anchor.hasAttribute(VISITED_ATTR)) anchor.removeAttribute(VISITED_ATTR);
                } catch (e) {}
                return false;
            }

            function syncVisitedAttrForAnchor(anchor, currentSettings, pageHost, absoluteHref) {
                if (!anchor || anchor.tagName !== 'A') return;
                if (!syncVisitedEligibleAttrForAnchor(anchor, currentSettings, pageHost, absoluteHref)) return;
                const href = String(absoluteHref || '') || (() => {
                    try {
                        return anchor.href || '';
                    } catch (e) {
                        return '';
                    }
                })();
                const key = buildVisitedHistoryKey(href, currentSettings, pageHost);
                if (!key) return;
                ensureVisitedLinkStateLoaded();
                let visited = VisitedLinkState.map.has(key);
                if (!visited && resolveVisitedHistoryScope(currentSettings) === 'site') {
                    const globalKey = normalizeVisitedHrefKey(href);
                    if (globalKey && VisitedLinkState.map.has(globalKey)) visited = true;
                }
                if (visited) {
                    if (anchor.getAttribute(VISITED_ATTR) !== '1') anchor.setAttribute(VISITED_ATTR, '1');
                } else {
                    if (anchor.hasAttribute(VISITED_ATTR)) anchor.removeAttribute(VISITED_ATTR);
                }
            }

            function pruneCrossTips(list, now) {
                const t0 = typeof now === 'number' ? now : Date.now();
                const arr = Array.isArray(list) ? list : [];
                const next = [];
                for (let i = 0; i < arr.length; i++) {
                    const it = arr[i];
                    if (!it || typeof it !== 'object') continue;
                    const msg = String(it.msg || '').trim();
                    const url = normalizeTipUrl(it.url);
                    const t = typeof it.t === 'number' ? it.t : 0;
                    if (!msg || !url || !t) continue;
                    if (t0 - t > 30000) continue;
                    next.push({ msg, url, t });
                }
                if (next.length <= 5) return next;
                return next.slice(next.length - 5);
            }

            function stashSmartRedirectTipForUrl(message, href) {
                if (!isTopWindow()) return;
                const msg = String(message || '').trim();
                if (!msg) return;
                const urls = buildTipUrlVariants(href);
                if (!urls.length) return;
                const now = Date.now();
                let list = getValue(SMART_REDIRECT_TIP_CROSS_KEY, []);
                list = pruneCrossTips(list, now);
                for (let i = 0; i < urls.length; i++) list.push({ msg, url: urls[i], t: now });
                try {
                    setValue(SMART_REDIRECT_TIP_CROSS_KEY, list);
                } catch (e) {}
            }

            function consumeSmartRedirectTipForUrl(href, shouldShow) {
                if (!isTopWindow()) return false;
                if (!shouldShow) return false;
                const urls = buildTipUrlVariants(href);
                if (!urls.length) return false;
                const now = Date.now();
                let list = getValue(SMART_REDIRECT_TIP_CROSS_KEY, []);
                list = pruneCrossTips(list, now);
                let hit = null;
                const rest = [];
                for (let i = 0; i < list.length; i++) {
                    const it = list[i];
                    if (!hit && it && urls.indexOf(it.url) !== -1) {
                        hit = it;
                        continue;
                    }
                    rest.push(it);
                }
                if (!hit) {
                    try {
                        if (rest.length !== list.length) setValue(SMART_REDIRECT_TIP_CROSS_KEY, rest);
                    } catch (e) {}
                    return false;
                }
                try {
                    setValue(SMART_REDIRECT_TIP_CROSS_KEY, rest);
                } catch (e) {}
                showPassiveTip(hit.msg);
                return true;
            }

            function ensurePassiveTipStyle() {
                const existing = document.getElementById(PASSIVE_TIP_STYLE_ID);
                if (existing) return;
                const style = document.createElement('style');
                style.id = PASSIVE_TIP_STYLE_ID;
                style.type = 'text/css';
                style.textContent = `
                    #${PASSIVE_TIP_ROOT_ID}{position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:2147483645;pointer-events:none;display:flex;flex-direction:column;align-items:center;gap:8px;max-width:min(560px,calc(100vw - 24px));}
                    #${PASSIVE_TIP_ROOT_ID} .nptip{font:12px/1.2 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;padding:6px 10px;border-radius:999px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;opacity:0;transform:translateY(-6px);transition:opacity .18s ease,transform .18s ease;background:rgba(17,18,20,.78);color:#f3f4f6;box-shadow:0 6px 18px rgba(0,0,0,.22);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);}
                    #${PASSIVE_TIP_ROOT_ID} .nptip[data-visible="1"]{opacity:1;transform:translateY(0);}
                    @media (prefers-color-scheme: light){
                        #${PASSIVE_TIP_ROOT_ID} .nptip{background:rgba(255,255,255,.82);color:#111214;box-shadow:0 6px 18px rgba(0,0,0,.12);}
                    }
                `;
                try {
                    (document.head || document.documentElement || document.body || document).appendChild(style);
                } catch (e) {}
            }

            function ensurePassiveTipRoot() {
                if (!isTopWindow()) return null;
                const existing = document.getElementById(PASSIVE_TIP_ROOT_ID);
                if (existing) return existing;
                ensurePassiveTipStyle();
                const root = document.createElement('div');
                root.id = PASSIVE_TIP_ROOT_ID;
                try {
                    (document.body || document.documentElement || document).appendChild(root);
                } catch (e) {
                    try {
                        (document.documentElement || document).appendChild(root);
                    } catch (e2) {}
                }
                return root;
            }

            function showPassiveTip(message) {
                if (!settings.passiveTipsEnabled) return;
                const msg = String(message || '').trim();
                if (!msg) return;
                let durationMs = Number(settings.passiveTipDurationMs);
                if (!Number.isFinite(durationMs)) durationMs = 1200;
                durationMs = Math.max(200, Math.min(20000, Math.round(durationMs)));
                const dedupeWindowMs = Math.max(2500, Math.min(60000, durationMs + 1200));
                const now = Date.now();
                const sig = msg;
                if (sig === PassiveTipState.lastSig && now - PassiveTipState.lastAt < dedupeWindowMs) return;
                PassiveTipState.lastSig = sig;
                PassiveTipState.lastAt = now;

                const root = ensurePassiveTipRoot();
                if (!root) return;
                PassiveTipState.root = root;

                const generic = 'æ–°æ ‡ç­¾é¡µProï¼šå·²ç”Ÿæ•ˆ';
                const isSmartRedirectTip = msg.indexOf('æ™ºèƒ½å»é‡å®šå‘å·²ç”Ÿæ•ˆ') === 0;
                if (msg === generic) {
                    try {
                        for (let i = root.childNodes.length - 1; i >= 0; i--) {
                            const n = root.childNodes[i];
                            const t = n && n.textContent ? String(n.textContent).trim() : '';
                            if (t && t.indexOf('æ™ºèƒ½å»é‡å®šå‘å·²ç”Ÿæ•ˆ') === 0) return;
                        }
                    } catch (e) {}
                } else if (isSmartRedirectTip) {
                    try {
                        for (let i = root.childNodes.length - 1; i >= 0; i--) {
                            const n = root.childNodes[i];
                            const t = n && n.textContent ? String(n.textContent).trim() : '';
                            if (t === generic) n.remove();
                        }
                    } catch (e) {}
                }

                const tip = document.createElement('div');
                tip.className = 'nptip';
                tip.textContent = msg;
                root.appendChild(tip);

                while (root.childNodes.length > 3) {
                    try {
                        root.removeChild(root.firstChild);
                    } catch (e) {
                        break;
                    }
                }

                requestAnimationFrame(() => {
                    tip.setAttribute('data-visible', '1');
                });

                setTimeout(() => {
                    tip.removeAttribute('data-visible');
                    setTimeout(() => {
                        try {
                            tip.remove();
                        } catch (e) {}
                    }, 220);
                }, durationMs);
            }

            let selfCheckRan = false;

            function runSelfCheckOnce() {
                if (selfCheckRan) return;
                selfCheckRan = true;
                try {
                    const meta = typeof GM_info === 'object' && GM_info ? GM_info.scriptMetaStr : '';
                    if (meta && /github\.com\/XIU2\/UserScript/i.test(String(meta))) {
                        debugLog('selfCheck', { type: 'forbiddenMeta', match: 'github.com/XIU2/UserScript', version: SCRIPT_VERSION }, 'WARN');
                    }
                    const gmVer = typeof GM_info === 'object' && GM_info && GM_info.script ? GM_info.script.version : '';
                    if (gmVer && String(gmVer).trim() !== String(SCRIPT_VERSION)) {
                        debugLog('selfCheck', { type: 'versionMismatch', gm: String(gmVer), code: SCRIPT_VERSION }, 'WARN');
                    }
                } catch (e) {}
                try {
                    const defaultsKeys = Object.keys(DEFAULT_SETTINGS || {});
                    const schemaKeys = new Set();
                    const groups = Array.isArray(SETTINGS_UI_GROUPS) ? SETTINGS_UI_GROUPS : [];
                    for (let i = 0; i < groups.length; i++) {
                        const g = groups[i];
                        const rows = g && Array.isArray(g.rows) ? g.rows : [];
                        for (let j = 0; j < rows.length; j++) {
                            const r = rows[j];
                            if (!r || typeof r !== 'object') continue;
                            const k = r.key != null ? String(r.key) : '';
                            if (k) schemaKeys.add(k);
                        }
                    }
                    const manualKeys = new Set(['excludeDomains', 'textLinkifyIncludeHosts', 'textLinkifyExcludeHosts']);
                    const missing = [];
                    for (let i = 0; i < defaultsKeys.length; i++) {
                        const k = defaultsKeys[i];
                        if (schemaKeys.has(k) || manualKeys.has(k)) continue;
                        missing.push(k);
                    }
                    const extra = [];
                    schemaKeys.forEach((k) => {
                        if (!Object.prototype.hasOwnProperty.call(DEFAULT_SETTINGS, k)) extra.push(k);
                    });
                    if (missing.length || extra.length) {
                        debugLog(
                            'selfCheck',
                            { type: 'settingsUiCoverage', missing, extra, defaultsCount: defaultsKeys.length, schemaCount: schemaKeys.size },
                            missing.length ? 'ERROR' : 'WARN'
                        );
                    } else {
                        debugLog('selfCheck', { type: 'settingsUiCoverage', ok: true, defaultsCount: defaultsKeys.length }, 'INFO');
                    }
                } catch (e) {}
                try {
                    runThemeSyncUnitTestsOnce();
                } catch (e) {}
                try {
                    runAutoUnfoldUnitTestsOnce();
                } catch (e) {}
                try {
                    runPanCodeUnitTestsOnce();
                } catch (e) {}
            }

            safeApplyRuntimeSettings();
            try {
                EventRegistry.add(window, 'DOMContentLoaded', safeApplyRuntimeSettings, true);
                EventRegistry.add(window, 'load', safeApplyRuntimeSettings, true);
            } catch (e) {}

            function safeApplyRuntimeSettings() {
                try {
                    applyRuntimeSettings();
                    safeApplyRuntimeSettings._retryCount = 0;
                } catch (e) {
                    const retryCount = (safeApplyRuntimeSettings._retryCount || 0) + 1;
                    safeApplyRuntimeSettings._retryCount = retryCount;
                    const message = e && e.message ? String(e.message) : String(e);
                    try {
                        debugLog('applyRuntimeSettingsError', { retryCount, error: message }, 'ERROR');
                    } catch (e2) {}
                    if (!safeApplyRuntimeSettings._reported) {
                        safeApplyRuntimeSettings._reported = true;
                        try {
                            console.error(`[${SCRIPT_LABEL}] applyRuntimeSettings å‘ç”Ÿå¼‚å¸¸ï¼š${message}`);
                        } catch (e3) {}
                    }
                    if (retryCount <= 3) {
                        try {
                            setTimeout(safeApplyRuntimeSettings, 0);
                        } catch (e4) {}
                    }
                }
            }

            function normalizeSettingValue(key, value, defaultValue) {
                const t = typeof defaultValue;
                if (t === 'boolean') {
                    if (typeof value === 'boolean') return value;
                    if (typeof value === 'string') {
                        const s = value.trim().toLowerCase();
                        if (s === 'true') return true;
                        if (s === 'false') return false;
                    }
                    if (typeof value === 'number') {
                        if (value === 1) return true;
                        if (value === 0) return false;
                    }
                    return defaultValue;
                }
                if (t === 'number') {
                    if (typeof value === 'number' && Number.isFinite(value)) return value;
                    if (typeof value === 'string' && value.trim() !== '') {
                        const n = Number(value);
                        if (Number.isFinite(n)) return n;
                    }
                    return defaultValue;
                }
                if (t === 'string') {
                    if (value == null) return defaultValue;
                    return String(value);
                }
                return defaultValue;
            }

            function loadSettings(defaults) {
                const result = {};
                const keys = Object.keys(defaults);
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const raw = getValue(key, defaults[key]);
                    result[key] = normalizeSettingValue(key, raw, defaults[key]);
                }
                return result;
            }

            /**
             * è¯»å–å•ä¸ªè®¾ç½®å€¼ï¼Œä¼˜å…ˆä½¿ç”¨ GM_getValueï¼Œå…¶æ¬¡ä½¿ç”¨ localStorage
             */
            function getValue(key, defaultValue) {
                if (typeof GM_getValue === 'function') {
                    try {
                        const k = String(key || '');
                        const missing = '__newtab_pro_gm_missing__';
                        const v = GM_getValue(k, missing);
                        if (v !== missing) return v;
                    } catch (e) {}
                }
                try {
                    const raw = localStorage.getItem(`${STORAGE_PREFIX}${key}`);
                    if (raw == null) return defaultValue;
                    return safeJsonParse(raw, defaultValue);
                } catch (e) {
                    return defaultValue;
                }
            }

            /**
             * å†™å…¥å•ä¸ªè®¾ç½®å€¼ï¼Œä¼˜å…ˆä½¿ç”¨ GM_setValueï¼Œå…¶æ¬¡ä½¿ç”¨ localStorage
             */
            function setValue(key, value) {
                if (typeof GM_setValue === 'function') {
                    try {
                        GM_setValue(key, value);
                        return;
                    } catch (e) {}
                }
                try {
                    localStorage.setItem(`${STORAGE_PREFIX}${key}`, JSON.stringify(value));
                } catch (e) {}
            }

            /**
             * é‡ç½®æ‰€æœ‰è®¾ç½®ä¸ºé»˜è®¤å€¼
             */
            function resetValues(defaults) {
                for (const key of Object.keys(defaults)) {
                    if (typeof GM_deleteValue === 'function') {
                        try {
                            GM_deleteValue(key);
                        } catch (e) {
                            try {
                                localStorage.removeItem(`${STORAGE_PREFIX}${key}`);
                            } catch (e2) {}
                        }
                    } else {
                        try {
                            localStorage.removeItem(`${STORAGE_PREFIX}${key}`);
                        } catch (e) {}
                    }
                }
            }

            function getCurrentHost() {
                return String(location.hostname || '').toLowerCase();
            }

            function parseHostListTokens(raw) {
                const lines = String(raw || '')
                    .split(/[\n\r]+/g)
                    .map((s) => String(s || '').trim())
                    .filter(Boolean);
                const parts = [];
                const tryNormalizeUrl = (s) => {
                    const text = String(s || '').trim();
                    if (!text) return '';
                    if (/^https?:\/\//i.test(text)) {
                        try {
                            const u = new URL(text);
                            return String(u.hostname || '').trim();
                        } catch (e) {
                            return '';
                        }
                    }
                    return text;
                };
                for (let i = 0; i < lines.length; i++) {
                    let s = lines[i];
                    s = s.replace(/^\s*\d+\s*[ï¼š:]\s*/g, '');
                    s = tryNormalizeUrl(s);
                    if (!s) continue;
                    const segs = s.split(/[,ï¼Œ]+/g);
                    for (let j = 0; j < segs.length; j++) {
                        let t = String(segs[j] || '').trim();
                        if (!t) continue;
                        if (t[0] === '/' && t.lastIndexOf('/') > 0) {
                            parts.push(t);
                            continue;
                        }
                        if (t[0] === '.') t = t.slice(1);
                        if (!t) continue;
                        if (t.startsWith('*.')) {
                            parts.push('*.' + t.slice(2).toLowerCase());
                            continue;
                        }
                        parts.push(t.toLowerCase());
                    }
                }
                const seen = new Set();
                const out = [];
                for (let i = 0; i < parts.length; i++) {
                    const t = parts[i];
                    if (!t) continue;
                    if (seen.has(t)) continue;
                    seen.add(t);
                    out.push(t);
                }
                return out;
            }

            function normalizeHostListRaw(raw) {
                const list = parseHostListTokens(raw);
                return list.length ? list.join(',') : '';
            }

            function resolveUiTheme(value) {
                const v = String(value || '').toLowerCase();
                if (v === 'light' || v === 'dark') return v;
                try {
                    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    return prefersDark ? 'dark' : 'light';
                } catch (e) {
                    return 'dark';
                }
            }

            let themeUnitTestsRan = false;

            function runThemeSyncUnitTestsOnce() {
                if (themeUnitTestsRan) return;
                themeUnitTestsRan = true;

                const parseHex = (hex) => {
                    const h = String(hex || '').replace(/^#/, '');
                    if (h.length === 3) {
                        const r = parseInt(h[0] + h[0], 16);
                        const g = parseInt(h[1] + h[1], 16);
                        const b = parseInt(h[2] + h[2], 16);
                        return [r, g, b];
                    }
                    if (h.length === 6) {
                        const r = parseInt(h.slice(0, 2), 16);
                        const g = parseInt(h.slice(2, 4), 16);
                        const b = parseInt(h.slice(4, 6), 16);
                        return [r, g, b];
                    }
                    return null;
                };

                const srgbToLinear = (v) => {
                    const x = v / 255;
                    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
                };

                const relLum = ([r, g, b]) => 0.2126 * srgbToLinear(r) + 0.7152 * srgbToLinear(g) + 0.0722 * srgbToLinear(b);

                const contrastRatio = (a, b) => {
                    const l1 = relLum(a);
                    const l2 = relLum(b);
                    const hi = Math.max(l1, l2);
                    const lo = Math.min(l1, l2);
                    return (hi + 0.05) / (lo + 0.05);
                };

                const tokens = {
                    dark: { bg: '#111214', fg: '#f3f4f6' },
                    light: { bg: '#ffffff', fg: '#111827' },
                };

                const checks = [];
                for (const key of Object.keys(tokens)) {
                    const t = tokens[key];
                    const bg = parseHex(t.bg);
                    const fg = parseHex(t.fg);
                    if (!bg || !fg) {
                        checks.push({ theme: key, ok: false, reason: 'colorParseFail' });
                        continue;
                    }
                    const ratio = contrastRatio(bg, fg);
                    checks.push({ theme: key, ok: ratio >= 4.5, ratio: Number(ratio.toFixed(2)) });
                }

                const failed = checks.filter((c) => !c.ok);
                if (failed.length) debugLog('test', { name: 'themeSync', ok: false, failed }, 'ERROR');
                else debugLog('test', { name: 'themeSync', ok: true, checks }, 'INFO');

                const tests = [];
                const assertEqual = (name, actual, expected) => {
                    tests.push({ name, ok: actual === expected, actual, expected });
                };

                assertEqual('normalizeSettingValue.boolStringTrue', normalizeSettingValue('enabled', 'true', true), true);
                assertEqual('normalizeSettingValue.boolStringFalse', normalizeSettingValue('enabled', 'false', true), false);
                assertEqual('normalizeSettingValue.boolNumberZero', normalizeSettingValue('enabled', 0, true), false);
                assertEqual('normalizeSettingValue.boolNumberOne', normalizeSettingValue('enabled', 1, false), true);
                assertEqual('normalizeSettingValue.numberString', normalizeSettingValue('limit', '42', 0), 42);
                assertEqual('normalizeSettingValue.numberInvalid', Number.isNaN(normalizeSettingValue('limit', 'x', 5)), false);
                assertEqual('normalizeSettingValue.stringNull', normalizeSettingValue('uiTheme', null, 'dark'), 'dark');
                assertEqual('normalizeSettingValue.stringValue', normalizeSettingValue('uiTheme', 'light', 'dark'), 'light');

                try {
                    const origin = location.origin;
                    const path = location.pathname;
                    const search = location.search;
                    assertEqual('resolveAbsoluteHref.absolute', resolveAbsoluteHref('https://example.com/a', null), 'https://example.com/a');
                    assertEqual('resolveAbsoluteHref.protocolRelative', resolveAbsoluteHref('//example.com/a', null), `${location.protocol}//example.com/a`);
                    assertEqual('resolveAbsoluteHref.root', resolveAbsoluteHref('/a', null), `${origin}/a`);
                    assertEqual('resolveAbsoluteHref.query', resolveAbsoluteHref('?q=1', null), `${origin}${path}?q=1`);
                    assertEqual('resolveAbsoluteHref.hash', resolveAbsoluteHref('#x', null), `${origin}${path}${search}#x`);
                    const a = document.createElement('a');
                    a.href = 'https://a.example/x';
                    assertEqual('resolveAbsoluteHref.anchorHrefPriority', resolveAbsoluteHref('foo', a), 'https://a.example/x');
                    const expectedRel = new URL('foo/bar', location.href).href;
                    assertEqual('resolveAbsoluteHref.relativeBase', resolveAbsoluteHref('foo/bar', null), expectedRel);
                    assertEqual('resolveAbsoluteHref.doubleSchemeFix', resolveAbsoluteHref('https://https://example.com/a', null), 'https://example.com/a');
                } catch (e) {
                    tests.push({ name: 'resolveAbsoluteHref.error', ok: false, error: String(e && e.message ? e.message : e) });
                }

                const hostMatchCases = [
                    { host: 'example.com', raw: 'example.com', expect: true },
                    { host: 'sub.example.com', raw: 'example.com', expect: true },
                    { host: 'demo.com', raw: 'example.com', expect: false },
                    { host: 'foo.bar.com', raw: '*.bar.com', expect: true },
                    { host: 'bar.com', raw: '*.bar.com', expect: true },
                ];
                for (let i = 0; i < hostMatchCases.length; i++) {
                    const c = hostMatchCases[i];
                    assertEqual(
                        `matchHostList.${i}`,
                        (() => {
                            try {
                                return matchHostList(c.host, c.raw);
                            } catch (e) {
                                return false;
                            }
                        })(),
                        c.expect
                    );
                }

                try {
                    const key = 'test_log_roundtrip';
                    const sample = [{ time: 't', action: 'x' }];
                    setValue(key, sample);
                    const roundtrip = getValue(key, null);
                    assertEqual('logRoundtrip.isArray', Array.isArray(roundtrip), true);
                } catch (e) {
                    tests.push({ name: 'logRoundtrip.error', ok: false, error: String(e && e.message ? e.message : e) });
                }

                try {
                    const key2 = 'test_configAudit_roundtrip';
                    const sample2 = [{ time: 't', action: 'settingsDiff', detail: 'd', host: 'h', version: '1' }];
                    setValue(key2, sample2);
                    const roundtrip2 = getValue(key2, null);
                    assertEqual('configAuditRoundtrip.isArray', Array.isArray(roundtrip2), true);
                } catch (e) {
                    tests.push({ name: 'configAuditRoundtrip.error', ok: false, error: String(e && e.message ? e.message : e) });
                }

                const failedCore = tests.filter((t) => t.ok === false);
                if (failedCore.length) debugLog('test', { name: 'coreLogic', ok: false, failed: failedCore }, 'ERROR');
                else debugLog('test', { name: 'coreLogic', ok: true, checks: tests }, 'INFO');
            }

            let autoUnfoldUnitTestsRan = false;

            function runAutoUnfoldUnitTestsOnce() {
                if (autoUnfoldUnitTestsRan) return;
                autoUnfoldUnitTestsRan = true;

                const results = [];
                const push = (name, ok, detail) => results.push({ name, ok, detail });
                const el = (root, sel) => root.querySelector(sel);
                const els = (root, sel) => Array.from(root.querySelectorAll(sel));

                try {
                    const host = document.implementation && document.implementation.createHTMLDocument
                        ? document.implementation.createHTMLDocument('autoUnfoldTest')
                        : null;
                    if (!host) throw new Error('createHTMLDocument ä¸å¯ç”¨');
                    const root = host.body;
                    root.innerHTML =
                        '<div class="mask"></div>' +
                        '<div class="content" style="height:10px;min-height:10px;max-height:10px"></div>' +
                        '<div class="scroll" style="overflow:hidden"></div>' +
                        '<div class="cls remove-me"></div>' +
                        '<button class="btn"></button>' +
                        '<button class="btn2"></button>';

                    els(root, '.mask').forEach((n) => (n.style.display = 'block'));
                    els(root, '.content').forEach((n) => (n.style.height = '10px'));
                    els(root, '.scroll').forEach((n) => (n.style.overflow = 'hidden'));
                    els(root, '.cls').forEach((n) => n.classList.add('remove-me'));

                    els(root, '.mask').forEach((n) => (n.style.display = 'none'));
                    push('autoUnfold.display', el(root, '.mask').style.display === 'none');

                    const c = el(root, '.content');
                    c.style.setProperty('height', 'unset', 'important');
                    c.style.setProperty('min-height', 'unset', 'important');
                    c.style.setProperty('max-height', 'unset', 'important');
                    push(
                        'autoUnfold.height',
                        c.style.getPropertyValue('height') === 'unset' &&
                            c.style.getPropertyPriority('height') === 'important' &&
                            c.style.getPropertyValue('min-height') === 'unset' &&
                            c.style.getPropertyPriority('min-height') === 'important'
                    );

                    const s = el(root, '.scroll');
                    s.style.setProperty('overflow', 'unset', 'important');
                    push('autoUnfold.overflow', s.style.getPropertyValue('overflow') === 'unset' && s.style.getPropertyPriority('overflow') === 'important');

                    const cl = el(root, '.cls');
                    cl.classList.remove('remove-me');
                    push('autoUnfold.classList', !cl.classList.contains('remove-me'));

                    let count1 = 0;
                    const b1 = el(root, '.btn');
                    b1.addEventListener('click', () => count1++);
                    if (b1.getAttribute('opened') !== 'yes') {
                        b1.click();
                        b1.setAttribute('opened', 'yes');
                    }
                    if (b1.getAttribute('opened') !== 'yes') {
                        b1.click();
                        b1.setAttribute('opened', 'yes');
                    }
                    push('autoUnfold.clickOnce', count1 === 1);

                    let count2 = 0;
                    const b2 = el(root, '.btn2');
                    b2.addEventListener('click', () => count2++);
                    b2.click();
                    b2.click();
                    push('autoUnfold.multiClick', count2 === 2);
                } catch (e) {
                    push('autoUnfold.unitTestError', false, String(e && e.message ? e.message : e));
                }

                const failed = results.filter((r) => !r.ok);
                if (failed.length) debugLog('test', { name: 'autoUnfold', ok: false, failed }, 'ERROR');
                else debugLog('test', { name: 'autoUnfold', ok: true, checks: results }, 'INFO');
            }

            let panCodeUnitTestsRan = false;

            function runPanCodeUnitTestsOnce() {
                if (panCodeUnitTestsRan) return;
                panCodeUnitTestsRan = true;
                const cases = [
                    ['æå–ç ï¼šabcd', 'abcd'],
                    ['æå–ç : abcd', 'abcd'],
                    ['è®¿é—®ç ã€a1B2ã€‘', 'a1B2'],
                    ['å¯†ç =Z9x8', 'Z9x8'],
                    ['å£ä»¤ ( 1a2B )', '1a2B'],
                    ['abcd æå–ç ', 'abcd'],
                    ['æå–ç¢¼ï¼šã€ABCDã€‘', 'ABCD'],
                    ['code: 1a2b', '1a2b'],
                    ['pwd- a1b2', 'a1b2'],
                    ['æå–ç ï¼šabc', ''],
                    ['æå–ç ï¼šabcd123456', ''],
                    ['æ²¡æœ‰æå–ç çš„æ–‡æœ¬', ''],
                ];
                const results = [];
                for (let i = 0; i < cases.length; i++) {
                    const [text, expected] = cases[i];
                    let got = '';
                    try {
                        got = extractPanCodeFromText(text);
                    } catch (e) {
                        got = '';
                    }
                    results.push({ name: `panCode.case.${i + 1}`, ok: got === expected, expected, got, text });
                }
                const failed = results.filter((r) => !r.ok);
                if (failed.length) debugLog('test', { name: 'panCode', ok: false, failed }, 'ERROR');
                else debugLog('test', { name: 'panCode', ok: true, checks: results }, 'INFO');
            }

            function formatDateTimeForDisplay(date) {
                const d = date || new Date();
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                const h = String(d.getHours()).padStart(2, '0');
                const mi = String(d.getMinutes()).padStart(2, '0');
                const s = String(d.getSeconds()).padStart(2, '0');
                return `${y}.${m}.${day} - ${h}:${mi}:${s}`;
            }

            function formatDateTimeForFile(date) {
                return formatDateTimeForDisplay(date).replace(/:/g, '-');
            }

            /**
             * æ³¨å†Œæ²¹çŒ´èœå•é¡¹ï¼Œæ–¹ä¾¿å¿«é€Ÿå¼€å…³è„šæœ¬å’ŒåŠŸèƒ½
             */
            function registerMenus(current, defaults) {
                if (typeof GM_registerMenuCommand !== 'function') return;

                const toggleAndReload = (key) => {
                    setValue(key, !current[key]);
                    location.reload();
                };
                const safeShowMenuTip = (text) => {
                    try {
                        if (settings && settings.passiveTipsEnabled) return showPassiveTip(text);
                    } catch (e) {}
                    try {
                        alert(text);
                    } catch (e2) {}
                };

                GM_registerMenuCommand('âš™ æ‰“å¼€è®¾ç½®é¢æ¿', () => openSettingsPanel(defaults));
                GM_registerMenuCommand(`ğŸ“‹ å¤åˆ¶å½“å‰é¡µé“¾æ¥ï¼ˆ${current && current.copyChineseUrlEnabled ? 'ä¸­æ–‡' : 'åŸå§‹'}ï¼‰`, async () => {
                    const text = normalizeUrlForClipboard(location.href, Boolean(current && current.copyChineseUrlEnabled));
                    const ok = await copyTextToClipboard(text);
                    try {
                        showPassiveTip(ok ? 'å·²å¤åˆ¶å½“å‰é¡µé“¾æ¥' : 'å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™');
                    } catch (e) {}
                });
                GM_registerMenuCommand(
                    `${current && current.copyChineseUrlEnabled ? 'âœ…' : 'âŒ'} å¤åˆ¶ä¸­æ–‡URLï¼š${current && current.copyChineseUrlEnabled ? 'å¼€å¯' : 'å…³é—­'}ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰`,
                    () => toggleAndReload('copyChineseUrlEnabled')
                );
                GM_registerMenuCommand('âŒ¨ è®¾ç½®å¿«æ·é”®ï¼šå¤åˆ¶å½“å‰é¡µé“¾æ¥', () => {
                    const mode = settings && settings.copyCurrentUrlHotkey ? String(settings.copyCurrentUrlHotkey) : 'off';
                    const custom = settings && settings.copyCurrentUrlHotkeyCustom ? String(settings.copyCurrentUrlHotkeyCustom) : '';
                    const curText = getCopyCurrentUrlHotkeyDisplay(mode, custom);
                    let input = '';
                    try {
                        input = prompt(
                            `è¯·è¾“å…¥å¿«æ·é”®ï¼Œä¾‹å¦‚ï¼šAlt+Shift+C æˆ– Ctrl+Alt+U\nè¦æ±‚ï¼šè‡³å°‘åŒ…å«ä¸€ä¸ªä¿®é¥°é”®ï¼ˆCtrl/Alt/Shift/Winï¼‰\nç•™ç©º=å…³é—­\nå½“å‰ï¼š${curText}`,
                            curText === 'å…³é—­' ? 'Alt+Shift+C' : curText
                        );
                    } catch (e) {
                        input = '';
                    }
                    if (input == null) return;
                    const text = String(input || '').trim();
                    if (!text) {
                        setValue('copyCurrentUrlHotkey', 'off');
                        setValue('copyCurrentUrlHotkeyCustom', '');
                        settings.copyCurrentUrlHotkey = 'off';
                        settings.copyCurrentUrlHotkeyCustom = '';
                        applyCopyCurrentUrlHotkey(Boolean(settings.enabled) && !isExcludedDomain(settings.excludeDomains), settings);
                        return safeShowMenuTip('å·²å…³é—­å¿«æ·é”®ï¼šå¤åˆ¶å½“å‰é¡µé“¾æ¥');
                    }
                    const parsed = parseHotkeyText(text);
                    if (!parsed) return safeShowMenuTip('å¿«æ·é”®æ ¼å¼æ— æ•ˆï¼Œè¯·è¾“å…¥å¦‚ Alt+Shift+C');
                    if (!parsed.hasModifier) return safeShowMenuTip('ä¸ºé¿å…å†²çªï¼Œå¿«æ·é”®å¿…é¡»åŒ…å« Ctrl/Alt/Shift/Win è‡³å°‘ä¸€ä¸ª');
                    if (isBrowserReservedHotkey(parsed.normalized)) {
                        return safeShowMenuTip(`è¯¥å¿«æ·é”®ä¸æµè§ˆå™¨å¸¸ç”¨å¿«æ·é”®å†²çªï¼š${parsed.display}\nè¯·æ¢ä¸€ä¸ªç»„åˆé”®ï¼Œä¾‹å¦‚ Alt+Shift+U`);
                    }
                    if (parsed.usesMeta) {
                        safeShowMenuTip('æç¤ºï¼šWin/Cmd é”®åœ¨æµè§ˆå™¨é‡Œå¯èƒ½æ— æ³•è¢«è„šæœ¬æ•è·ï¼Œå»ºè®®ä¼˜å…ˆç”¨ Ctrl/Alt/Shift ç»„åˆ');
                    }
                    setValue('copyCurrentUrlHotkey', 'custom');
                    setValue('copyCurrentUrlHotkeyCustom', parsed.display);
                    settings.copyCurrentUrlHotkey = 'custom';
                    settings.copyCurrentUrlHotkeyCustom = parsed.display;
                    applyCopyCurrentUrlHotkey(Boolean(settings.enabled) && !isExcludedDomain(settings.excludeDomains), settings);
                    safeShowMenuTip(`å·²è®¾ç½®å¿«æ·é”®ï¼š${parsed.display}`);
                });
                GM_registerMenuCommand(`${current.enabled ? 'âœ…' : 'âŒ'} å¯ç”¨è„šæœ¬ï¼š${current.enabled ? 'å¼€å¯' : 'å…³é—­'}ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰`, () => toggleAndReload('enabled'));
                GM_registerMenuCommand(
                    `${current.debugOverlay ? 'âœ…' : 'âŒ'} è°ƒè¯•æ‚¬æµ®çª—ï¼š${current.debugOverlay ? 'å¼€å¯' : 'å…³é—­'}ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰`,
                    () => toggleAndReload('debugOverlay')
                );
                const menuMode = current && current.menuDisplayMode === 'full' ? 'full' : 'simple';
                GM_registerMenuCommand(`ğŸ“‹ èœå•æ¨¡å¼ï¼š${menuMode === 'full' ? 'å®Œæ•´' : 'ç²¾ç®€'}ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰`, () => {
                    setValue('menuDisplayMode', menuMode === 'full' ? 'simple' : 'full');
                    location.reload();
                });
                const host = getCurrentHost();
                if (host) {
                    const ignoredSites = readLoginPopupBypassIgnoredSites();
                    const ignored = ignoredSites.indexOf(host) !== -1;
                    const enabledForSite = !ignored;
                    GM_registerMenuCommand(
                        `${enabledForSite ? 'âœ…' : 'ğŸš«'} éšè—ç™»å½•é®æŒ¡ï¼ˆæœ¬ç½‘ç«™ï¼‰ï¼š${enabledForSite ? 'ç”Ÿæ•ˆ' : 'å¿½ç•¥'}ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰`,
                        () => {
                        const list = readLoginPopupBypassIgnoredSites();
                        const next = ignored
                            ? list.filter((x) => x !== host)
                            : Array.from(new Set(list.concat([host]).filter(Boolean)));
                        setValue(LOGIN_POPUP_BYPASS_IGNORED_KEY, next);
                        location.reload();
                        }
                    );
                }
                if (menuMode === 'full') {
                    GM_registerMenuCommand(`${current.passiveTipsEnabled ? 'âœ…' : 'âŒ'} æ— æ„Ÿæç¤ºï¼š${current.passiveTipsEnabled ? 'å¼€å¯' : 'å…³é—­'}`, () =>
                        toggleAndReload('passiveTipsEnabled')
                    );
                    GM_registerMenuCommand(`${current.pinScrollEnabled ? 'âœ…' : 'âŒ'} ç½®é¡¶/ç½®åº•æŒ‰é’®ï¼š${current.pinScrollEnabled ? 'å¼€å¯' : 'å…³é—­'}`, () =>
                        toggleAndReload('pinScrollEnabled')
                    );
                    GM_registerMenuCommand(`${current.autoUnfoldEnabled ? 'âœ…' : 'âŒ'} è‡ªåŠ¨å±•å¼€å†…å®¹ï¼š${current.autoUnfoldEnabled ? 'å¼€å¯' : 'å…³é—­'}`, () =>
                        toggleAndReload('autoUnfoldEnabled')
                    );
                    GM_registerMenuCommand(
                        `${current.loginPopupBypassEnabled ? 'âœ…' : 'âŒ'} éšè—ç™»å½•é®æŒ¡ï¼ˆå…¨å±€ï¼‰ï¼š${current.loginPopupBypassEnabled ? 'å¼€å¯' : 'å…³é—­'}`,
                        () => toggleAndReload('loginPopupBypassEnabled')
                    );
                    GM_registerMenuCommand(
                        `${current.panCodeAssistEnabled ? 'âœ…' : 'âŒ'} ç½‘ç›˜æå–ç åŠ©æ‰‹ï¼š${current.panCodeAssistEnabled ? 'å¼€å¯' : 'å…³é—­'}`,
                        () => toggleAndReload('panCodeAssistEnabled')
                    );
                    GM_registerMenuCommand(
                        `${current.panCodeAutoFillEnabled ? 'âœ…' : 'âŒ'} ç½‘ç›˜æå–ç è‡ªåŠ¨å¡«å……ï¼š${current.panCodeAutoFillEnabled ? 'å¼€å¯' : 'å…³é—­'}`,
                        () => toggleAndReload('panCodeAutoFillEnabled')
                    );
                    GM_registerMenuCommand('ğŸ§· é‡æ–°æ³¨å…¥ç½®é¡¶/ç½®åº•æŒ‰é’®', () => {
                        try {
                            stopGoTopBottomControls();
                        } catch (e) {}
                        try {
                            startGoTopBottomControls();
                        } catch (e2) {}
                    });
                    GM_registerMenuCommand('ğŸ§· å–æ¶ˆå¿½ç•¥å½“å‰ç½‘ç«™ï¼ˆç½®é¡¶/ç½®åº•ï¼‰', () => {
                        const host = getCurrentHost();
                        if (!host) return;
                        try {
                            const key = 'goTBIgnoredSites';
                            let list = getValue(key, []);
                            if (!Array.isArray(list)) list = [];
                            const next = list
                                .map((x) => String(x || '').trim().toLowerCase())
                                .filter(Boolean)
                                .filter((x) => x !== host);
                            setValue(key, next);
                        } catch (e) {}
                        try {
                            const legacy = safeJsonParse(localStorage.getItem('btnScript_ignoredSites') || '[]', []);
                            if (Array.isArray(legacy) && legacy.length) {
                                const nextLegacy = legacy
                                    .map((x) => String(x || '').trim().toLowerCase())
                                    .filter(Boolean)
                                    .filter((x) => x !== host);
                                localStorage.setItem('btnScript_ignoredSites', JSON.stringify(nextLegacy));
                            }
                        } catch (e2) {}
                        location.reload();
                    });
                }

                GM_registerMenuCommand('ğŸš« æ·»åŠ å½“å‰åŸŸååˆ°é»‘åå•', () => {
                    const hostname = getCurrentHost();
                    if (!hostname) return;
                    const list = parseHostListTokens(getValue('excludeDomains', defaults.excludeDomains));
                    if (!list.includes(hostname)) list.push(hostname);
                    setValue('excludeDomains', list.join(','));
                    location.reload();
                });

                const visitedScope = current && current.visitedLinkHistoryScope === 'site' ? 'site' : 'global';
                const visitedHost = getCurrentHost();
                const visitedScopeLabel = visitedScope === 'site' && visitedHost ? 'å½“å‰ç«™ç‚¹' : 'å…¨å±€';

                GM_registerMenuCommand(`ğŸ§¹ æ¸…ç©ºå·²è®¿é—®è®°å½•ï¼ˆ${visitedScopeLabel}ï¼‰`, () => {
                    const scope = current && current.visitedLinkHistoryScope === 'site' ? 'site' : 'global';
                    const host = getCurrentHost();
                    const hint = scope === 'site' && host ? `å½“å‰ç«™ç‚¹ï¼ˆ${host}ï¼‰` : 'å…¨å±€ï¼ˆè·¨ç«™ç‚¹ï¼‰';
                    const ok = confirm(`ç¡®å®šè¦æ¸…ç©ºâ€œå·²è®¿é—®é“¾æ¥å˜è‰²â€çš„å†å²è®°å½•å—ï¼Ÿ\nèŒƒå›´ï¼š${hint}`);
                    if (!ok) return;
                    try {
                        if (scope !== 'site' || !host) {
                            setValue(VISITED_HISTORY_STORAGE_KEY, { v: 1, t: Date.now(), items: [] });
                        } else {
                            const raw = getValue(VISITED_HISTORY_STORAGE_KEY, null);
                            const data = raw && typeof raw === 'object' ? raw : null;
                            const items = data && Array.isArray(data.items) ? data.items : [];
                            const prefix = `${host}|`;
                            const next = [];
                            for (let i = 0; i < items.length; i++) {
                                const it = items[i];
                                if (!it || !Array.isArray(it)) continue;
                                const k = String(it[0] || '');
                                if (k.startsWith(prefix)) continue;
                                next.push(it);
                            }
                            setValue(VISITED_HISTORY_STORAGE_KEY, { v: 1, t: Date.now(), items: next });
                        }
                    } catch (e) {}
                    location.reload();
                });

                GM_registerMenuCommand('âš™ æ¢å¤é»˜è®¤è®¾ç½®', () => {
                    resetValues(defaults);
                    location.reload();
                });
            }

            /**
             * æ‰“å¼€è®¾ç½®é¢æ¿ï¼ˆä½¿ç”¨ç‹¬ç«‹é®ç½©ä¸ shadow DOM éš”ç¦»æ ·å¼ï¼‰
             */
            function openSettingsPanel(defaults) {
                if (!isTopWindow()) return;
                const __openNow = Date.now();
                if (__openNow - (settingsPanelLastOpenAt || 0) < 350) return;
                settingsPanelLastOpenAt = __openNow;
                const tryCloseSettingsPanelHost = (el) => {
                    if (!el) return false;
                    try {
                        const fn = el.__nph_close;
                        if (typeof fn === 'function') {
                            fn();
                            return true;
                        }
                    } catch (e) {}
                    try {
                        el.remove();
                        return true;
                    } catch (e) {}
                    return false;
                };
                try {
                    const list = document.querySelectorAll('#newtab-open-links-settings-panel');
                    for (let i = 1; i < list.length; i++) tryCloseSettingsPanelHost(list[i]);
                } catch (e) {}
                const existing = document.getElementById('newtab-open-links-settings-panel');
                if (existing) {
                    let focused = false;
                    try {
                        const root = existing.shadowRoot || existing;
                        const panel = root.querySelector && root.querySelector('.panel');
                        if (panel && typeof panel.focus === 'function') {
                            panel.focus();
                            focused = true;
                        }
                    } catch (e) {}
                    if (focused) return;
                    if (!tryCloseSettingsPanelHost(existing)) return;
                }
                if (settingsPanelOpening) return;
                settingsPanelOpening = true;
                const __perfStart = (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now());

                const current = loadSettings(defaults);
                const hostname = String(location.hostname || '').trim().toLowerCase();
                const appliedTheme = resolveUiTheme(current.uiTheme);
                let uiVersion = SCRIPT_VERSION;
                try {
                    if (typeof GM_info === 'object' && GM_info && GM_info.script && GM_info.script.version) {
                        uiVersion = String(GM_info.script.version);
                    }
                } catch (e) {}
                const getExportFileName = () => {
                    const ts = formatDateTimeForFile(new Date());
                    return `æ–°æ ‡ç­¾é¡µPro-è®¾ç½®-${ts}.json`;
                };
                const getConfigAuditExportFileName = () => {
                    const ts = formatDateTimeForFile(new Date());
                    return `æ–°æ ‡ç­¾é¡µPro-é…ç½®æ—¥å¿—-${ts}.json`;
                };

                let host = null;
                try {
                    host = document.createElement('div');
                    host.id = 'newtab-open-links-settings-panel';
                    host.style.position = 'fixed';
                    host.style.inset = '0';
                    host.style.zIndex = '2147483646';
                    host.setAttribute('role', 'dialog');
                    host.setAttribute('aria-modal', 'true');

                    const root = host.attachShadow ? host.attachShadow({ mode: 'open' }) : host;

                    (document.documentElement || document.body).appendChild(host);

                    let closed = false;
                    let destroyVirtualViews = null;
                    let panelLifecycle = null;
                    let updatePerfBadgeUi = null;
                    let navRaf = 0;
                    let searchRaf = 0;
                    let navBatchRaf = 0;
                    let navBatchKey = '';
                    let navBatchSubmenu = '';
                    let submenuScrollRaf = 0;
                    let submenuScrollKey = '';
                    let submenuScrollSubmenu = '';
                    let layoutApplyRaf = 0;
                    let lastNavClickAt = 0;
                    let lastNavScrollAt = 0;

                    const getNavScrollBehavior = () => {
                        const now = Date.now();
                        const delta = now - (lastNavScrollAt || 0);
                        lastNavScrollAt = now;
                        return delta < 180 ? 'auto' : 'smooth';
                    };

                    const close = () => {
                        if (closed) return;
                        closed = true;
                        navRaf = 0;
                        searchRaf = 0;
                        navBatchRaf = 0;
                        navBatchKey = '';
                        navBatchSubmenu = '';
                        submenuScrollRaf = 0;
                        submenuScrollKey = '';
                        submenuScrollSubmenu = '';
                        layoutApplyRaf = 0;
                        try {
                            if (updatePerfBadgeUi && DebugState.onPerf === updatePerfBadgeUi) DebugState.onPerf = null;
                        } catch (e) {}
                        try {
                            if (panelLifecycle && typeof panelLifecycle.dispose === 'function') panelLifecycle.dispose();
                        } catch (e) {}
                        try {
                            if (typeof destroyVirtualViews === 'function') destroyVirtualViews();
                        } catch (e) {}
                        destroyVirtualViews = null;
                        try {
                            host.__nph_close = null;
                        } catch (e) {}
                        try {
                            host.remove();
                        } catch (e) {}
                        settingsPanelOpening = false;
                    };

                    try {
                        host.__nph_close = close;
                    } catch (e) {}

                const normalizeHexColor = (colorRaw, fallback) => {
                    let color = String(colorRaw || '').trim();
                    if (!/^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(color)) color = '';
                    return color || String(fallback || '#8b5cf6');
                };
                const visitedColor = normalizeHexColor(current && current.visitedLinkColor, '#8b5cf6');

                const css = `
                    :host { all: initial; }
                    .backdrop {
                        --panel-bg: #111214;
                        --panel-fg: #f3f4f6;
                        --panel-border: rgba(255,255,255,.12);
                        --panel-shadow: rgba(0,0,0,.55);
                        --header-bg: rgba(255,255,255,.04);
                        --divider: rgba(255,255,255,.08);
                        --section-border: rgba(255,255,255,.10);
                        --section-bg: rgba(255,255,255,.045);
                        --hover-bg: rgba(255,255,255,.065);
                        --control-border: rgba(255,255,255,.14);
                        --control-bg: rgba(255,255,255,.055);
                        --control-hover-bg: rgba(255,255,255,.10);
                        --textarea-bg: rgba(0,0,0,.18);
                        --focus: rgba(99,102,241,.45);
                        --btn-primary-border: rgba(99,102,241,.55);
                        --btn-primary-bg: rgba(99,102,241,.20);
                        --btn-primary-hover: rgba(99,102,241,.28);
                        --btn-danger-border: rgba(239,68,68,.55);
                        --btn-danger-bg: rgba(239,68,68,.16);
                        --btn-danger-hover: rgba(239,68,68,.22);
                        --scrollbar-thumb: rgba(148,163,184,.55);
                        --scrollbar-thumb-hover: rgba(148,163,184,.9);
                        --host-chip-fg: #e5e7ff;
                        --host-chip-bg: rgba(129,140,248,.28);
                        --host-chip-border: rgba(129,140,248,.85);
                        --visited-color: ${visitedColor};
                        position: fixed;
                        inset: 0;
                        background: rgba(0,0,0,.55);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 18px;
                        box-sizing: border-box;
                        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
                    }
                    .backdrop[data-theme="light"] {
                        --panel-bg: #ffffff;
                        --panel-fg: #111827;
                        --panel-border: rgba(17,24,39,.14);
                        --panel-shadow: rgba(0,0,0,.30);
                        --header-bg: rgba(17,24,39,.03);
                        --divider: rgba(17,24,39,.12);
                        --section-border: rgba(17,24,39,.12);
                        --section-bg: rgba(17,24,39,.03);
                        --hover-bg: rgba(17,24,39,.05);
                        --control-border: rgba(17,24,39,.18);
                        --control-bg: rgba(17,24,39,.03);
                        --control-hover-bg: rgba(17,24,39,.06);
                        --textarea-bg: rgba(17,24,39,.03);
                        --focus: rgba(99,102,241,.35);
                        --scrollbar-thumb: rgba(148,163,184,.7);
                        --scrollbar-thumb-hover: rgba(148,163,184,1);
                        --host-chip-fg: #111827;
                        --host-chip-bg: rgba(191,219,254,.75);
                        --host-chip-border: rgba(59,130,246,.85);
                        background: rgba(0,0,0,.35);
                    }
                    .panel {
                        width: min(760px, 100%);
                        max-height: min(88vh, 880px);
                        background: var(--panel-bg);
                        color: var(--panel-fg);
                        border: 0;
                        border-radius: 14px;
                        overflow: hidden;
                        box-shadow: 0 18px 60px var(--panel-shadow);
                        display: flex;
                        flex-direction: column;
                    }
                    .panel:focus { outline: none; }
                    .header {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 10px;
                        padding: 12px 14px;
                        background: var(--header-bg);
                        border-bottom: 1px solid var(--divider);
                    }
                    .headerLeft { min-width: 0; flex: 1 1 auto; }
                    .headerQuickBar {
                        flex: 0 0 auto;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    .quickMenuWrap { position: relative; }
                    .quickMenu {
                        position: absolute;
                        top: calc(100% + 8px);
                        right: 0;
                        width: 280px;
                        padding: 10px;
                        border-radius: 12px;
                        border: 1px solid var(--section-border);
                        background: var(--panel-bg);
                        box-shadow: 0 18px 60px var(--panel-shadow);
                        opacity: 0;
                        transform: translateY(-4px);
                        pointer-events: none;
                        transition: opacity .14s ease, transform .14s ease;
                        z-index: 2;
                    }
                    .quickMenu[data-open="1"] {
                        opacity: 1;
                        transform: translateY(0);
                        pointer-events: auto;
                    }
                    .quickMenuBody { display: grid; gap: 10px; }
                    .quickMenuRow {
                        display: grid;
                        grid-template-columns: 1fr auto;
                        gap: 10px;
                        align-items: start;
                        padding: 8px 10px;
                        border-radius: 10px;
                        border: 1px solid var(--section-border);
                        background: var(--section-bg);
                    }
                    .quickMenuLabel {
                        display: inline-flex;
                        align-items: flex-start;
                        gap: 8px;
                        font-size: 12px;
                        font-weight: 600;
                        min-width: 0;
                        line-height: 1.25;
                    }
                    .quickMenuLabelText {
                        overflow: visible;
                        text-overflow: clip;
                        white-space: normal;
                        opacity: .92;
                    }
                    .quickMenuRow select {
                        min-width: 120px;
                    }
                    .title {
                        font-size: 14px;
                        font-weight: 650;
                        letter-spacing: .2px;
                        display: flex;
                        align-items: center;
                        gap: 10px;
                    }
                    .headerRight {
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    .versionBadge {
                        font-size: 11px;
                        opacity: .82;
                        padding: 2px 8px;
                        border-radius: 999px;
                        border: 1px solid var(--section-border);
                    }
                    .perfBadge {
                        font-size: 11px;
                        opacity: .82;
                        padding: 2px 8px;
                        border-radius: 999px;
                        border: 1px solid var(--section-border);
                        user-select: none;
                        white-space: nowrap;
                    }
                    .perfBadge[data-bad="1"] {
                        border-color: rgba(239,68,68,.6);
                        color: rgba(239,68,68,.95);
                    }
                    .subtitle {
                        font-size: 12px;
                        opacity: .7;
                        margin-top: 2px;
                        display: flex;
                        align-items: center;
                        flex-wrap: wrap;
                        gap: 6px;
                    }
                    .subtitleHost {
                        font-weight: 650;
                        padding: 1px 8px;
                        border-radius: 999px;
                        border: 1px solid var(--host-chip-border);
                        background: var(--host-chip-bg);
                        color: var(--host-chip-fg);
                        letter-spacing: .1px;
                    }
                    .close {
                        appearance: none;
                        border: 1px solid var(--control-border);
                        background: var(--control-bg);
                        color: inherit;
                        padding: 6px 10px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-size: 12px;
                    }
                    .close:hover { background: var(--control-hover-bg); }
                    .content {
                        padding: 10px 12px 12px;
                        overflow: auto;
                        align-items: start;
                        scrollbar-width: thin;
                        scrollbar-color: var(--scrollbar-thumb) transparent;
                        transition: opacity .3s ease, transform .3s ease;
                        transform: none;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                        align-content: start;
                        line-height: 1.45;
                    }
                    .content[data-style="compact"] { padding: 10px; gap: 8px; }
                    .content[data-style="compact"] .section { padding: 8px; }
                    .content[data-style="compact"] .sectionTitle { margin-bottom: 6px; font-size: 13px; }
                    .content[data-style="compact"] .row { padding: 6px 6px; gap: 8px; }
                    .content[data-style="compact"] .label { font-size: 12px; }
                    .content[data-style="compact"] .desc { font-size: 11px; }
                    .content { contain: layout paint style; will-change: auto; }
                    .content[data-switching="1"] {
                        opacity: .25;
                        transform: scale(.995);
                        will-change: opacity, transform;
                        transition: opacity .3s ease, transform .3s ease;
                    }
                    .content[data-anim="switch"] { opacity: .2; transform: scale(.995); }
                    .configAuditWrapper { max-height: 360px; overflow: auto; border-radius: 10px; }
                    .vtSpacerRow td { padding: 0 !important; border: 0 !important; }
                    @media (min-width: 980px) { .panel { width: min(1180px, 100%); } }
                    .content::-webkit-scrollbar {
                        width: 8px;
                    }
                    .content::-webkit-scrollbar-track {
                        background: transparent;
                    }
                    .content::-webkit-scrollbar-thumb {
                        border-radius: 999px;
                        background: var(--scrollbar-thumb);
                    }
                    .content::-webkit-scrollbar-thumb:hover {
                        background: var(--scrollbar-thumb-hover);
                    }
                    @keyframes ntp_spin { 0%{transform:rotate(0deg)}100%{transform:rotate(360deg)} }
                    .ntp_loader { display:inline-flex; align-items:center; gap:8px; font-size:12px; opacity:.8; }
                    .ntp_loader .ring { width:14px; height:14px; border-radius:999px; border:2px solid var(--divider); border-top-color: var(--btn-primary-border); animation: ntp_spin 1s linear infinite; }
                    .visitedCards { display: grid; grid-template-columns: 1fr; gap: 8px; }
                    .visitedCards .card { border: 1px solid var(--section-border); border-radius: 10px; background: var(--section-bg); padding: 8px 10px; break-inside: avoid; box-shadow: inset 3px 0 0 var(--visited-color); }
                    .visitedCards .meta { display:flex; gap:8px; font-size:12px; opacity:.8; align-items: center; }
                    .visitedCards .url { margin-top:4px; font-size:12px; word-break: break-all; }
                    .visitedCards .ops { margin-top:6px; display:flex; gap:6px; }
                    .visitedMark { width: 8px; height: 8px; border-radius: 999px; background: var(--visited-color); display: inline-block; flex: 0 0 auto; }
                    .visitedSiteCell { display: inline-flex; align-items: center; gap: 6px; }
                    .subDetails[data-submenu="visitedStats"] .subBody { grid-template-columns: 1fr; }
                    .subDetails[data-submenu="visitedStats"] .configAuditWrapper { overflow: auto; max-height: 360px; }
                    .subDetails[data-submenu="panHistory"] .subBody,
                    .subDetails[data-submenu="panFavorites"] .subBody { grid-template-columns: 1fr; }
                    .subDetails[data-submenu="panHistory"] .configAuditWrapper,
                    .subDetails[data-submenu="panFavorites"] .configAuditWrapper { overflow: auto; max-height: 360px; }
                    .panCards { display: grid; grid-template-columns: 1fr; gap: 8px; }
                    .panCards .card { border: 1px solid var(--section-border); border-radius: 10px; background: var(--section-bg); padding: 8px 10px; }
                    .panCards .meta { display:flex; gap:8px; font-size:12px; opacity:.82; align-items: center; }
                    .panCards .line { margin-top: 4px; font-size: 12px; }
                    .panCards .code { font-weight: 650; letter-spacing: .2px; }
                    .panCards .href { word-break: break-all; opacity: .9; }
                    .panCards .ops { margin-top: 6px; display:flex; gap:6px; flex-wrap: wrap; }
                    .panProviderBadge {
                        display: inline-flex;
                        align-items: center;
                        gap: 6px;
                        padding: 1px 8px;
                        border-radius: 999px;
                        border: 1px solid rgba(148,163,184,.35);
                        background: rgba(148,163,184,.14);
                        color: inherit;
                        font-weight: 650;
                        letter-spacing: .1px;
                        white-space: nowrap;
                    }
                    .panProviderBadge::before {
                        content: '';
                        width: 7px;
                        height: 7px;
                        border-radius: 999px;
                        background: currentColor;
                        opacity: .95;
                        flex: 0 0 auto;
                    }
                    .panProviderBadge[data-key="baidu"] { border-color: rgba(59,130,246,.45); background: rgba(59,130,246,.14); color: rgba(59,130,246,.95); }
                    .panProviderBadge[data-key="aliyun"] { border-color: rgba(249,115,22,.45); background: rgba(249,115,22,.14); color: rgba(249,115,22,.95); }
                    .panProviderBadge[data-key="123pan"] { border-color: rgba(34,197,94,.45); background: rgba(34,197,94,.14); color: rgba(34,197,94,.95); }
                    .panProviderBadge[data-key="quark"] { border-color: rgba(168,85,247,.45); background: rgba(168,85,247,.14); color: rgba(168,85,247,.95); }
                    .panProviderBadge[data-key="uc"] { border-color: rgba(16,185,129,.45); background: rgba(16,185,129,.14); color: rgba(16,185,129,.95); }
                    .panProviderBadge[data-key="189"] { border-color: rgba(234,179,8,.45); background: rgba(234,179,8,.14); color: rgba(234,179,8,.95); }
                    .panProviderBadge[data-key="weiyun"] { border-color: rgba(14,165,233,.45); background: rgba(14,165,233,.14); color: rgba(14,165,233,.95); }
                    .panProviderBadge[data-key="xunlei"] { border-color: rgba(37,99,235,.45); background: rgba(37,99,235,.14); color: rgba(37,99,235,.95); }
                    .panProviderBadge[data-key="caiyun"] { border-color: rgba(239,68,68,.45); background: rgba(239,68,68,.12); color: rgba(239,68,68,.95); }
                    .panProviderBadge[data-key="ctfile"] { border-color: rgba(148,163,184,.45); background: rgba(148,163,184,.12); color: rgba(71,85,105,.95); }
                    .panProviderBadge[data-key="cowtransfer"] { border-color: rgba(244,63,94,.45); background: rgba(244,63,94,.12); color: rgba(244,63,94,.95); }
                    .panProviderBadge[data-key="wenshushu"] { border-color: rgba(100,116,139,.45); background: rgba(100,116,139,.12); color: rgba(100,116,139,.95); }
                    .panProviderBadge[data-key="lanzou"] { border-color: rgba(2,132,199,.45); background: rgba(2,132,199,.12); color: rgba(2,132,199,.95); }
                    .panProviderBadge[data-key="115"] { border-color: rgba(15,118,110,.45); background: rgba(15,118,110,.12); color: rgba(15,118,110,.95); }
                    .section {
                        border: 1px solid var(--section-border);
                        border-radius: 12px;
                        background: var(--section-bg);
                        padding: 10px;
                        min-width: 0;
                        width: 100%;
                        max-width: 980px;
                        margin: 0 auto;
                        content-visibility: auto;
                        contain-intrinsic-size: 180px;
                    }
                    .sectionTitle {
                        font-size: 14px;
                        font-weight: 650;
                        margin-bottom: 10px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    .row {
                        display: grid;
                        grid-template-columns: 22px 1fr auto;
                        gap: 10px;
                        align-items: start;
                        padding: 8px 8px;
                        border-radius: 10px;
                    }
                    .row:hover { background: var(--hover-bg); }
                    .row > div:last-child { display: flex; justify-content: flex-end; align-items: center; }
                    .row > label.toggle { justify-self: end; align-self: center; }
                    .subDetails {
                        margin: 2px 6px 6px 34px;
                        border: 1px dashed var(--section-border);
                        border-radius: 10px;
                        background: var(--control-bg);
                        padding: 7px 9px;
                    }
                    .subDetails > summary {
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 650;
                        opacity: .88;
                        list-style: none;
                        outline: none;
                    }
                    .subDetails > summary::-webkit-details-marker { display: none; }
                    .subDetails[open] > summary { margin-bottom: 6px; }
                    .subDetails .subBody { display: grid; gap: 8px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
                    .subDetails .row { padding: 10px; border: 1px solid var(--section-border); border-radius: 12px; background: var(--control-bg); transition: background .14s ease, border-color .14s ease, box-shadow .14s ease; box-shadow: 0 1px 0 rgba(15,23,42,.06); }
                    .icon { width: 22px; text-align: center; opacity: .9; }
                    .label { font-size: 13px; font-weight: 600; }
                    .desc { font-size: 12px; opacity: .82; margin-top: 4px; line-height: 1.55; }
                    .subDetails .row:hover { background: var(--control-hover-bg); box-shadow: 0 2px 8px rgba(15,23,42,.08); }
                    .subDetails .row:focus-within { outline: none; border-color: var(--btn-primary-border); box-shadow: 0 0 0 2px rgba(37,99,235,.25), 0 4px 10px rgba(15,23,42,.10); }
                    .subDetails .row[data-checked="1"] { border-color: var(--btn-primary-border); background: var(--btn-primary-bg); }
                    .subDetails .row input[type="checkbox"] { width: 16px; height: 16px; margin-top: 2px; }
                    .section[data-active="1"] { content-visibility: visible; contain-intrinsic-size: auto; }
                    @media (max-width: 640px) {
                        .subDetails .subBody { grid-template-columns: 1fr; }
                    }
                    .subDetails[data-submenu="exceptions"] .subBody { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 8px; }
                    @media (max-width: 640px) {
                        .subDetails[data-submenu="exceptions"] .subBody { grid-template-columns: 1fr; }
                    }
                    .subDetails[data-submenu="csdnCleanPageEnabled"] .subBody { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 8px; }
                    @media (max-width: 640px) {
                        .subDetails[data-submenu="csdnCleanPageEnabled"] .subBody { grid-template-columns: 1fr; }
                    }
                    .toggle {
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        user-select: none;
                        font-size: 12px;
                        opacity: .9;
                    }
                    input[type="checkbox"] { width: 16px; height: 16px; margin: 0; cursor: pointer; }
                    .field {
                        display: grid;
                        gap: 8px;
                        padding: 8px 8px;
                    }
                    textarea {
                        width: 100%;
                        min-height: 66px;
                        resize: vertical;
                        border-radius: 10px;
                        border: 1px solid var(--control-border);
                        background: var(--textarea-bg);
                        color: inherit;
                        padding: 10px 10px;
                        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                        font-size: 12px;
                        box-sizing: border-box;
                    }
                    textarea:focus { outline: 2px solid var(--focus); outline-offset: 1px; }
                    select {
                        border-radius: 10px;
                        border: 1px solid var(--control-border);
                        background: var(--textarea-bg);
                        color: inherit;
                        padding: 7px 10px;
                        font-size: 12px;
                        cursor: pointer;
                    }
                    select:focus { outline: 2px solid var(--focus); outline-offset: 1px; }
                    @media (max-width: 560px) {
                        .row { grid-template-columns: 22px 1fr; }
                        .row > div:last-child,
                        .row > label.toggle {
                            grid-column: 2;
                            justify-self: start;
                            margin-top: 6px;
                        }
                        .row > div:last-child { width: 100%; justify-content: flex-start; }
                        .row select { width: 100%; }
                    }
                    .buttons {
                        display: flex;
                        gap: 8px;
                        justify-content: flex-end;
                        padding: 10px 14px;
                        border-top: 1px solid var(--divider);
                        background: var(--section-bg);
                    }
                    .btn {
                        appearance: none;
                        border: 1px solid var(--control-border);
                        background: var(--control-bg);
                        color: inherit;
                        padding: 8px 10px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-size: 12px;
                    }
                    .btnTiny {
                        padding: 5px 8px;
                        border-radius: 8px;
                        font-size: 11px;
                    }
                    .btn {
                        transition: background .14s ease, transform .14s ease;
                    }
                    .btn:hover { background: var(--control-hover-bg); transform: translateY(-0.5px); }
                    .btnPrimary {
                        border-color: var(--btn-primary-border);
                        background: var(--btn-primary-bg);
                    }
                    .btnPrimary:hover { background: var(--btn-primary-hover); }
                    .btnDanger {
                        border-color: var(--btn-danger-border);
                        background: var(--btn-danger-bg);
                    }
                    .btnDanger:hover { background: var(--btn-danger-hover); }
                    .hint {
                        font-size: 12px;
                        opacity: .75;
                        line-height: 1.35;
                    }
                    .miniBtns { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
                    .iconBtns { display: flex; gap: 8px; justify-content: flex-end; }
                    .iconBtn {
                        appearance: none;
                        width: 38px;
                        height: 38px;
                        border-radius: 12px;
                        border: 1px solid var(--control-border);
                        background: var(--control-bg);
                        color: inherit;
                        cursor: pointer;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0;
                        transition: transform .14s ease, background .14s ease, color .14s ease;
                    }
                    .iconBtn:hover { background: var(--control-hover-bg); color: rgba(99,102,241,1); }
                    .iconBtn:active { transform: scale(.94); }
                    .iconBtn:disabled { opacity: .45; cursor: not-allowed; }
                    .iconBtn svg { width: 24px; height: 24px; display: block; }
                    .iconBtn.isClicked { animation: iconBtnPulse .22s ease; }
                    @keyframes iconBtnPulse {
                        0% { transform: scale(1); }
                        45% { transform: scale(.92); }
                        100% { transform: scale(1); }
                    }
                    .configAuditTitle {
                        font-size: 12px;
                        font-weight: 600;
                        padding: 6px 8px;
                        border-bottom: 1px solid var(--divider);
                        background: var(--header-bg);
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 8px;
                        flex-wrap: wrap;
                    }
                    .configAuditWrapper {
                        margin-top: 0;
                        border-radius: 10px;
                        border: 1px solid var(--section-border);
                        max-height: 220px;
                        overflow: hidden;
                    }
                    .configAuditBody {
                        max-height: 220px;
                        overflow: auto;
                    }
                    .configAuditControls {
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        flex-wrap: wrap;
                        justify-content: flex-end;
                    }
                    .configAuditSearch {
                        font-size: 12px;
                        padding: 3px 6px;
                        border-radius: 6px;
                        border: 1px solid var(--divider);
                        background: var(--textarea-bg);
                        color: var(--panel-fg);
                        min-width: 80px;
                        max-width: 180px;
                        flex: 1 1 120px;
                    }
                    .configAuditTable {
                        width: 100%;
                        border-collapse: collapse;
                        font-size: 12px;
                        min-width: 260px;
                    }
                    .configAuditTable th {
                        padding: 6px 8px;
                        text-align: left;
                        border-bottom: 1px solid var(--divider);
                        white-space: nowrap;
                    }
                    .configAuditTable td {
                        padding: 6px 8px;
                        text-align: left;
                        border-bottom: 1px solid var(--divider);
                        white-space: normal;
                    }
                    .configAuditTable td:last-child { white-space: nowrap; }
                    .configAuditTable tbody tr:nth-child(odd) { background: var(--section-bg); }
                    .configAuditTable tbody tr:nth-child(even) { background: var(--hover-bg); }
                    .configAuditTable tbody tr:hover { background: var(--control-hover-bg); }
                    .configAuditTable tbody tr[data-draft="1"] {
                        opacity: .65;
                    }
                    .configAuditDraftBadge {
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: 4px;
                        padding: 0 6px;
                        border-radius: 999px;
                        border: 1px solid var(--divider);
                        font-size: 11px;
                    }
                    .countBadge {
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: 6px;
                        padding: 0 6px;
                        border-radius: 999px;
                        border: 1px solid var(--divider);
                        font-size: 11px;
                        opacity: .85;
                    }
                    .configAuditEmpty {
                        font-size: 12px;
                        opacity: .75;
                        padding: 6px 8px;
                    }
                    .toastRoot {
                        position: fixed;
                        left: 50%;
                        bottom: 18px;
                        transform: translateX(-50%);
                        display: flex;
                        flex-direction: column;
                        gap: 6px;
                        align-items: center;
                        pointer-events: none;
                        z-index: 60;
                    }
                    .toast {
                        max-width: 420px;
                        padding: 8px 14px;
                        border-radius: 9999px;
                        font-size: 12px;
                        line-height: 1.4;
                        box-shadow: 0 10px 30px var(--panel-shadow);
                        opacity: 0;
                        transform: translateY(10px);
                        transition: opacity .18s ease, transform .18s ease;
                        pointer-events: none;
                        white-space: nowrap;
                        text-overflow: ellipsis;
                        overflow: hidden;
                    }
                    .toast[data-visible="1"] {
                        opacity: 1;
                        transform: translateY(0);
                    }
                    .toast-info {
                        background: rgba(15,23,42,.96);
                        color: #e5e7eb;
                    }
                    .toast-error {
                        background: rgba(239,68,68,.96);
                        color: #f9fafb;
                    }
                    .toast-warn {
                        background: rgba(234,179,8,.96);
                        color: #111827;
                    }
                `;

                const renderRowFromSchema = (key) => {
                    const row = findSettingRow(key);
                    if (!row) return '';
                    if (row.type === 'toggle') {
                        const value = Boolean(current[key]);
                        const hasVariant = row.iconOn || row.iconOff;
                        let icon = row.icon || '';
                        if (hasVariant) icon = value ? (row.iconOn || row.icon || '') : (row.iconOff || row.icon || '');
                        return renderToggleRow(row.key, icon, row.label, row.desc);
                    }
                    if (row.type === 'select') {
                        const icon = row.icon || '';
                        const options = Array.isArray(row.options) ? row.options : [];
                        return renderSelectRow(row.key, icon, row.label, row.desc, options);
                    }
                    return '';
                };

                const renderQuickMenuSelectFromSchema = (key, title) => {
                    const row = findSettingRow(key);
                    if (!row || row.type !== 'select') return '';
                    const icon = row.icon || '';
                    const currentValue = String(current[key] ?? '');
                    const options = Array.isArray(row.options) ? row.options : [];
                    const opts = options
                        .map(([value, text]) => {
                            const v = String(value);
                            const selected = v === currentValue ? 'selected' : '';
                            return `<option value="${escapeHtml(v)}" ${selected}>${escapeHtml(String(text))}</option>`;
                        })
                        .join('');
                    const label = title || row.label || key;
                    return `
                        <div class="quickMenuRow" title="${escapeHtml(String(label))}">
                            <div class="quickMenuLabel">
                                <span>${escapeHtml(String(icon))}</span>
                                <span class="quickMenuLabelText">${escapeHtml(String(label))}</span>
                            </div>
                            <select data-field="${escapeHtml(String(key))}">${opts}</select>
                        </div>
                    `;
                };

                const draftConfigAudits = [];

                function escapeHtml(s) {
                    return String(s)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#039;');
                }

                const shorten = (textRaw, max) => {
                    const s = String(textRaw || '');
                    const n = typeof max === 'number' && max > 0 ? Math.floor(max) : 56;
                    if (!s) return '';
                    if (s.length <= n) return s;
                    return s.slice(0, Math.max(0, n - 1)) + 'â€¦';
                };
                const renderLoader = (text) => {
                    const t = String(text || 'æ­£åœ¨åŠ è½½â€¦');
                    return `<span class="ntp_loader"><span class="ring"></span><span>${escapeHtml(t)}</span></span>`;
                };

                const renderPanCodeTable = (items, favoritesSet, searchRaw, mode) => {
                    const search = String(searchRaw || '').trim().toLowerCase();
                    const list = Array.isArray(items) ? items : [];
                    let outItems = [];
                    for (let i = list.length - 1; i >= 0; i--) {
                        const it = normalizePanCodeEntryFromArray(list[i]);
                        if (!it) continue;
                        const key = it[0];
                        const href = it[1];
                        const code = it[2];
                        const provider = it[3];
                        const t = it[4];
                        if (search) {
                            const hay = `${key} ${href} ${code} ${provider}`.toLowerCase();
                            if (hay.indexOf(search) === -1) continue;
                        }
                        outItems.push({ key, href, code, provider, t });
                        if (outItems.length >= 200) break;
                    }
                    if (!outItems.length) return '<div class="configAuditEmpty">æš‚æ— è®°å½•ã€‚</div>';
                    const showFav = Boolean(current.panCodeFavoritesEnabled);
                    let rows = '';
                    for (let i = 0; i < outItems.length; i++) {
                        const it = outItems[i];
                        const dt = formatDateTimeForDisplay(new Date(it.t));
                        const shortHref = shorten(it.href, 60);
                        const fav = favoritesSet && favoritesSet.has(it.key);
                        const op =
                            mode === 'favorites'
                                ? `<button class="btn btnTiny" type="button" data-action="panFavRemove" data-key="${escapeHtml(it.key)}">å–æ¶ˆæ”¶è—</button>`
                                : (showFav
                                    ? `<button class="btn btnTiny" type="button" data-action="panFavToggle" data-key="${escapeHtml(it.key)}" data-pan-href="${escapeHtml(
                                            it.href
                                        )}" data-code="${escapeHtml(it.code)}" data-provider="${escapeHtml(it.provider)}" data-time="${escapeHtml(String(it.t))}">${
                                            fav ? 'å–æ¶ˆæ”¶è—' : 'æ”¶è—'
                                        }</button>`
                                    : '');
                        rows += `<tr><td title="${escapeHtml(dt)}">${escapeHtml(dt)}</td><td title="${escapeHtml(it.provider)}">${escapeHtml(it.provider)}</td><td title="${escapeHtml(it.code)}">${escapeHtml(it.code)}</td><td title="${escapeHtml(it.href)}">${escapeHtml(shortHref)}</td><td style="white-space:nowrap;"><button class="btn btnTiny" type="button" data-action="panOpen" data-pan-href="${escapeHtml(it.href)}">æ‰“å¼€</button><button class="btn btnTiny" type="button" data-action="panCopyLink" data-pan-href="${escapeHtml(it.href)}">å¤åˆ¶é“¾æ¥</button><button class="btn btnTiny" type="button" data-action="panCopyCode" data-code="${escapeHtml(it.code)}">å¤åˆ¶ç </button>${op}${mode === 'history' ? `<button class="btn btnTiny" type="button" data-action="panHistoryRemove" data-key="${escapeHtml(it.key)}">åˆ é™¤</button>` : ''}</td></tr>`;
                    }
                    return renderSimpleTable(['æ—¶é—´', 'ç½‘ç›˜', 'æå–ç ', 'é“¾æ¥', 'æ“ä½œ'], rows);
                };

                const readPanFavoritesKeySet = () => {
                    const fav = readPanCodeFavorites();
                    const set = new Set();
                    const items = fav.items || [];
                    for (let i = 0; i < items.length; i++) {
                        const it = normalizePanCodeEntryFromArray(items[i]);
                        if (!it) continue;
                        set.add(it[0]);
                    }
                    return set;
                };

                const renderVisitedStatsTable = (searchRaw) => {
                    ensureVisitedLinkStateLoaded();
                    const search = String(searchRaw || '').trim().toLowerCase();
                    const entries = Array.from(VisitedLinkState.map.entries());
                    entries.sort((a, b) => (b[1] || 0) - (a[1] || 0));
                    const items = [];
                    for (let i = 0; i < entries.length; i++) {
                        const k = String(entries[i][0] || '');
                        const t = Number(entries[i][1] || 0);
                        if (!k || !t) continue;
                        let site = '';
                        let url = k;
                        const sep = k.indexOf('|');
                        if (sep > 0 && k.slice(0, sep).indexOf('://') === -1) {
                            site = k.slice(0, sep);
                            url = k.slice(sep + 1);
                        }
                        if (search) {
                            const hay = `${site} ${url}`.toLowerCase();
                            if (hay.indexOf(search) === -1) continue;
                        }
                        const count = getGreasyForkScriptVisitCountByUrl(url);
                        items.push({ key: k, site, url, t, count });
                        if (items.length >= 200) break;
                    }
                    if (!items.length) return '<div class="configAuditEmpty">æš‚æ— è®°å½•ã€‚</div>';
                    let rows = '';
                    for (let i = 0; i < items.length; i++) {
                        const it = items[i];
                        const dt = formatDateTimeForDisplay(new Date(it.t));
                        const shortUrl = shorten(it.url, 70);
                    rows += `<tr><td title="${escapeHtml(dt)}">${escapeHtml(dt)}</td><td title="${escapeHtml(it.site || '-') }"><span class="visitedSiteCell"><span class="visitedMark"></span><span>${escapeHtml(it.site || '-')}</span></span></td><td title="${escapeHtml(it.url)}">${escapeHtml(shortUrl)}</td><td>${escapeHtml(it.count == null ? '-' : String(it.count))}</td><td style="white-space:nowrap;"><button class="btn btnTiny" type="button" data-action="visitedOpen" data-url="${escapeHtml(it.url)}">æ‰“å¼€</button><button class="btn btnTiny" type="button" data-action="visitedCopy" data-url="${escapeHtml(it.url)}">å¤åˆ¶</button><button class="btn btnTiny" type="button" data-action="visitedRemove" data-key="${escapeHtml(it.key)}">åˆ é™¤</button></td></tr>`;
                    }
                    return renderSimpleTable(['æ—¶é—´', 'ç«™ç‚¹', 'é“¾æ¥', 'æ¬¡æ•°', 'æ“ä½œ'], rows);
                };

                const renderVisitedStatsCards = (searchRaw) => {
                    ensureVisitedLinkStateLoaded();
                    const search = String(searchRaw || '').trim().toLowerCase();
                    const entries = Array.from(VisitedLinkState.map.entries());
                    entries.sort((a, b) => (b[1] || 0) - (a[1] || 0));
                const items = [];
                for (let i = 0; i < entries.length; i++) {
                    const k = String(entries[i][0] || '');
                    const t = Number(entries[i][1] || 0);
                    if (!k || !t) continue;
                    let site = '';
                    let url = k;
                    const sep = k.indexOf('|');
                    if (sep > 0 && k.slice(0, sep).indexOf('://') === -1) { site = k.slice(0, sep); url = k.slice(sep + 1); }
                    if (search) { const hay = `${site} ${url}`.toLowerCase(); if (hay.indexOf(search) === -1) continue; }
                    const count = getGreasyForkScriptVisitCountByUrl(url);
                    items.push({ key: k, site, url, t, count });
                    if (items.length >= 200) break;
                }
                if (!items.length) return '<div class="configAuditEmpty">æš‚æ— è®°å½•ã€‚</div>';
                let html = '';
                for (let i = 0; i < items.length; i++) {
                    const it = items[i];
                    const dt = formatDateTimeForDisplay(new Date(it.t));
                    const shortUrl = shorten(it.url, 96);
                    const countText = it.count == null ? '' : `<span class="site" title="${escapeHtml('è®¿é—®æ¬¡æ•°') }">${escapeHtml('Â· ' + it.count + ' æ¬¡')}</span>`;
                    html += `<div class="card">
                        <div class="meta"><span class="visitedMark"></span><span class="time" title="${escapeHtml(dt)}">${escapeHtml(dt)}</span><span class="site" title="${escapeHtml(it.site || '-') }">${escapeHtml(it.site || '-')}</span>${countText}</div>
                        <div class="url" title="${escapeHtml(it.url)}">${escapeHtml(shortUrl)}</div>
                        <div class="ops"><button class="btn btnTiny" type="button" data-action="visitedOpen" data-url="${escapeHtml(it.url)}">æ‰“å¼€</button><button class="btn btnTiny" type="button" data-action="visitedCopy" data-url="${escapeHtml(it.url)}">å¤åˆ¶</button><button class="btn btnTiny" type="button" data-action="visitedRemove" data-key="${escapeHtml(it.key)}">åˆ é™¤</button></div>
                    </div>`;
                }
                return `<div class="visitedCards">${html}</div>`;
            };

                const classicOrder = [
                    'basic',
                    'pin',
                    'hover',
                    'redirect',
                    'reading',
                    'pan',
                    'search',
                    'csdn',
                    'qqmail',
                    'strategy',
                    'text',
                    'backup',
                    'debug',
                    'blacklist',
                ];

                const commonFirstOrder = [
                    'basic',
                    'pin',
                    'hover',
                    'redirect',
                    'reading',
                    'pan',
                    'search',
                    'csdn',
                    'qqmail',
                    'strategy',
                    'text',
                    'backup',
                    'debug',
                    'blacklist',
                ];

                const normalizeLayoutMode = (modeRaw) => {
                    const mode = String(modeRaw || '').trim() || 'classic';
                    return mode === 'commonFirst' ? 'commonFirst' : 'classic';
                };
                const normalizeLayoutStyle = (styleRaw) => {
                    const s = String(styleRaw || '').trim();
                    if (s === 'compact' || s === 'list') return 'compact';
                    return 'comfortable';
                };

                const getLayoutOrder = (modeRaw) => (normalizeLayoutMode(modeRaw) === 'commonFirst' ? commonFirstOrder : classicOrder);

                const buildSection = (layoutKey, title, innerHtml) => `
                    <div class="section" data-layout-section="${escapeHtml(layoutKey)}">
                        <div class="sectionTitle">${title}</div>
                        ${innerHtml}
                    </div>
                `;

                const renderSectionsByLayoutMode = (modeRaw) => {
                    const mode = normalizeLayoutMode(modeRaw);

                const sectionBasic = buildSection(
                        'basic',
                        'ğŸ§© åŸºç¡€',
                        `${renderRowFromSchema('enabled')}${renderRowFromSchema('passiveTipsEnabled')}${renderRowFromSchema('passiveTipDurationMs')}${renderRowFromSchema('visitedLinkColorEnabled')}${renderRowFromSchema('visitedLinkColor')}${renderRowFromSchema('visitedLinkHistoryScope')}${renderRowFromSchema('greasyForkVisitStatsEnabled')}
                        <details class="subDetails" data-submenu="visitedStats" ${current.visitedLinkColorEnabled ? 'open' : ''}>
                            <summary>ğŸ“Š å·²è®¿é—®é“¾æ¥ç»Ÿè®¡ï¼ˆç”¨äºâ€œå·²è®¿é—®å˜è‰²â€ï¼‰</summary>
                            <div class="subBody">
                                <div class="miniBtns">
                                    <input class="configAuditSearch" data-role="visitedStatsSearch" placeholder="æœç´¢é“¾æ¥æˆ–ç«™ç‚¹">
                                    <button class="btn" type="button" data-action="visitedClear">æ¸…ç©ºè®°å½•</button>
                                    <button class="btn" type="button" data-action="visitedCopyJson">å¤åˆ¶ä¸º JSON</button>
                                </div>
                                <div class="hint" data-role="visitedStatsSummary"></div>
                                <div class="configAuditWrapper">
                                    <div class="visitedStatsBody">${renderLoader('æ­£åœ¨åŠ è½½â€¦')}</div>
                                </div>
                                <div class="hint">æç¤ºï¼šè®°å½•ä¼šè‡ªåŠ¨å»é™¤ #hash ä¸å¸¸è§è¿½è¸ªå‚æ•°ï¼Œå¹¶æœ€å¤šä¿ç•™çº¦ 180 å¤©ã€‚</div>
                            </div>
                        </details>`
                    );
                    const sectionReading = buildSection(
                        'reading',
                        'ğŸ“– é˜…è¯»å¢å¼º',
                        `${renderRowFromSchema('autoUnfoldEnabled')}${renderRowFromSchema('loginPopupBypassEnabled')}${renderRowFromSchema('autoUnfoldInterval')}${renderRowFromSchema(
                            'autoUnfoldMaxTicks'
                        )}`
                    );
                    const sectionSearch = buildSection(
                        'search',
                        'ğŸ” ç™¾åº¦æœç´¢',
                        `${renderRowFromSchema('baiduSearchEnhanceEnabled')}
                        <details class="subDetails" data-submenu="baiduSearchEnhanceEnabled" open>
                            <summary>ğŸ”§ ç™¾åº¦æœç´¢å­å¼€å…³ï¼ˆç‹¬ç«‹æ§åˆ¶ï¼‰</summary>
                            <div class="subBody">
                                ${renderRowFromSchema('baiduHideHotSearch')}
                                ${renderRowFromSchema('baiduHideRightContent')}
                                ${renderRowFromSchema('baiduLayoutMode')}
                                ${renderRowFromSchema('baiduStyleOptimizeEnabled')}
                                ${renderRowFromSchema('baiduCleanAdsEnabled')}
                                ${renderRowFromSchema('baiduHideAiAnswerEnabled')}
                                ${renderRowFromSchema('baiduPinOfficialEnabled')}
                            </div>
                        </details>`
                    );
                    const sectionCsdn = buildSection(
                        'csdn',
                        'ğŸƒ CSDN',
                        `${renderRowFromSchema('csdnStrongCopyEnabled')}${renderRowFromSchema('csdnCleanPageEnabled')}
                        <details class="subDetails" data-submenu="csdnCleanPageEnabled" ${current.csdnCleanPageEnabled ? 'open' : ''}>
                            <summary>ğŸ§¼ é¡µé¢å‡€åŒ–å­èœå•ï¼ˆå‹¾é€‰éœ€è¦éšè—çš„åŒºåŸŸï¼‰</summary>
                            <div class="subBody">
                                ${renderRowFromSchema('csdnCleanHideTopToolbar')}
                                ${renderRowFromSchema('csdnCleanHideSideToolbar')}
                                ${renderRowFromSchema('csdnCleanHideLoginPopup')}
                                ${renderRowFromSchema('csdnCleanHideRecommend')}
                                ${renderRowFromSchema('csdnCleanHideRightAside')}
                                ${renderRowFromSchema('csdnCleanHideAds')}
                            </div>
                        </details>
                        ${renderRowFromSchema('csdnCenterContentEnabled')}
                        ${renderRowFromSchema('csdnCommentEnabled')}${renderRowFromSchema('csdnBottomArticleEnabled')}
                        ${renderRowFromSchema('csdnUnfreezeScrollEnabled')}${renderRowFromSchema('csdnRedirectFastJumpEnabled')}`
                    );
                    const sectionQqMail = buildSection(
                        'qqmail',
                        'âœ‰ï¸ QQé‚®ç®±',
                        `${renderRowFromSchema('qqMailCleanVipBubbleEnabled')}`
                    );
                    const sectionPanCode = buildSection(
                        'pan',
                        'ğŸ’¾ ç½‘ç›˜æå–ç ',
                        `${renderRowFromSchema('panCodeAssistEnabled')}${renderRowFromSchema('panCodeLinkMergeEnabled')}${renderRowFromSchema(
                            'panCodeAutoFillEnabled'
                        )}${renderRowFromSchema('panCodeHistoryEnabled')}${renderRowFromSchema('panCodeFavoritesEnabled')}${renderRowFromSchema('panCodeHistoryLimit')}
                        <details class="subDetails" data-submenu="panHistory" ${current.panCodeHistoryEnabled ? 'open' : ''}>
                            <summary>ğŸ—‚ ç½‘ç›˜å†å²è®°å½• <span class="countBadge" data-role="panHistoryCount"></span></summary>
                            <div class="subBody">
                                <div class="miniBtns">
                                    <input class="configAuditSearch" data-role="panHistorySearch" placeholder="æœç´¢ç½‘ç›˜/é“¾æ¥/æå–ç ">
                                    <button class="btn" type="button" data-action="panHistoryClear">æ¸…ç©ºå†å²</button>
                                </div>
                                <div class="configAuditWrapper">
                                    <div class="panHistoryBody">${renderLoader('æ­£åœ¨åŠ è½½â€¦')}</div>
                                </div>
                            </div>
                        </details>
                        ${
                            current.panCodeFavoritesEnabled
                                ? `<details class="subDetails" data-submenu="panFavorites" open>
                            <summary>â­ æ”¶è— <span class="countBadge" data-role="panFavoritesCount"></span></summary>
                            <div class="subBody">
                                <div class="miniBtns">
                                    <input class="configAuditSearch" data-role="panFavoritesSearch" placeholder="æœç´¢ç½‘ç›˜/é“¾æ¥/æå–ç ">
                                    <button class="btn btnDanger" type="button" data-action="panFavoritesClear">æ¸…ç©ºæ”¶è—</button>
                                </div>
                                <div class="configAuditWrapper">
                                    <div class="panFavoritesBody">${renderLoader('æ­£åœ¨åŠ è½½â€¦')}</div>
                                </div>
                            </div>
                        </details>`
                                : ''
                        }`
                    );
                    const sectionHoverTips = buildSection(
                        'hover',
                        'ğŸ§· æ‚¬æµ®æç¤º',
                        `${renderRowFromSchema('netdiskHoverRealUrlEnabled')}${renderRowFromSchema('textLinkHoverFullUrlEnabled')}
                        <div class="hint">ä¼˜å…ˆçº§ï¼šç½‘ç›˜çœŸå®é“¾æ¥ &gt; æ™®é€šé“¾æ¥å®Œæ•´ URLã€‚</div>`
                    );
                    const sectionPin = buildSection('pin', 'ğŸ§· ç½®é¡¶ / ç½®åº•', renderRowFromSchema('pinScrollEnabled'));
                    const sectionStrategy = buildSection(
                        'strategy',
                        'ğŸ§­ æ‰“å¼€ç­–ç•¥',
                        `${renderRowFromSchema('onlyExternalNewTab')}
                        <details class="subDetails" data-submenu="exceptions" open>
                            <summary>ğŸ§¯ ä¾‹å¤–ï¼ˆä¿æŒå½“å‰é¡µæ‰“å¼€ï¼‰</summary>
                            <div class="subBody">
                                ${renderRowFromSchema('keepOnclickSelf')}
                                ${renderRowFromSchema('keepNonHttpSelf')}
                                ${renderRowFromSchema('keepHashSelf')}
                                ${renderRowFromSchema('keepEmptyHrefSelf')}
                                ${renderRowFromSchema('keepFormSelf')}
                            </div>
                        </details>`
                    );
                    const sectionRedirect = buildSection(
                        'redirect',
                        'ğŸš€ ç›´è¾¾ / å»é‡å®šå‘',
                        `${renderRowFromSchema('smartRedirectEnabled')}${renderRowFromSchema('smartRedirectCleanLink')}${renderRowFromSchema('smartRedirectAutoJump')}${renderRowFromSchema(
                            'smartShortLinkEnabled'
                        )}`
                    );
                    const sectionTextLink = `
                    <div class="section" data-layout-section="text">
                        <div class="sectionTitle">ğŸ§© å…¼å®¹æ€§ / æ–‡æœ¬é“¾æ¥</div>
                        ${renderRowFromSchema('enableDiscuz')}${renderRowFromSchema('enableObserver')}
                        ${renderRowFromSchema('enableTextLinkify')}
                        <div class="field">
                            <div class="label">æ–‡æœ¬é“¾æ¥ç™½åå•ï¼ˆä¸€è¡Œä¸€ä¸ªï¼‰</div>
                            <div class="desc">ä»…åœ¨åŒ¹é…è¿™äº›ç«™ç‚¹æ—¶å¯ç”¨æ–‡æœ¬è½¬é“¾æ¥ã€‚æ”¯æŒæ™®é€šåŸŸåã€*.example.com é€šé…ç¬¦ï¼Œæˆ–ä½¿ç”¨ /æ­£åˆ™/ å½¢å¼ã€‚</div>
                            <textarea data-field="textLinkifyIncludeHosts" spellcheck="false" placeholder="ç•™ç©ºè¡¨ç¤ºæ‰€æœ‰ç«™ç‚¹å‡å¯ä½¿ç”¨æ–‡æœ¬è½¬é“¾æ¥"></textarea>
                            <div class="miniBtns">
                                <button class="btn" type="button" data-action="addCurrentTextInclude">åŠ å…¥å½“å‰åŸŸå</button>
                            </div>
                        </div>
                        <div class="field">
                            <div class="label">æ–‡æœ¬é“¾æ¥é»‘åå•ï¼ˆä¸€è¡Œä¸€ä¸ªï¼‰</div>
                            <div class="desc">åŒ¹é…è¿™äº›ç«™ç‚¹æ—¶ç¦ç”¨æ–‡æœ¬è½¬é“¾æ¥ã€‚å½“åŒæ—¶å‘½ä¸­ç™½åå•å’Œé»‘åå•æ—¶ï¼Œç™½åå•ä¼˜å…ˆã€‚</div>
                            <textarea data-field="textLinkifyExcludeHosts" spellcheck="false"></textarea>
                            <div class="miniBtns">
                                <button class="btn" type="button" data-action="addCurrentTextExclude">åŠ å…¥å½“å‰åŸŸå</button>
                            </div>
                            <div class="hint">ç¤ºä¾‹ï¼šexample.comã€*.example.comã€/\\.gov$/ ç­‰ã€‚ä¸€è¡Œä¸€ä¸ªï¼Œäº¦å¯ä½¿ç”¨é€—å·æˆ–ä¸­æ–‡é€—å·æ‰¹é‡ç²˜è´´ã€‚</div>
                        </div>
                    </div>
                    `;
                    const sectionBackup = `
                    <div class="section" data-layout-section="backup">
                        <div class="sectionTitle">ğŸ’¾ è®¾ç½®å¤‡ä»½</div>
                        <div class="field">
                            <div class="label">å¯¼å…¥ / å¯¼å‡ºè®¾ç½®ï¼ˆJSONï¼‰</div>
                            <div class="desc">ç”¨äºå¤‡ä»½æˆ–åœ¨å¤šè®¾å¤‡ä¹‹é—´åŒæ­¥æœ¬è„šæœ¬è®¾ç½®ã€‚æ¨èæµç¨‹ï¼šå…ˆç‚¹å‡»â€œå¯¼å‡ºä¸º JSON æ–‡ä»¶â€ä¿å­˜å½“å‰é…ç½®ï¼Œå†è§†æƒ…å†µä½¿ç”¨â€œå¤åˆ¶é…ç½®ä¸º JSONâ€æˆ–â€œä»æ–‡ä»¶/å‰ªè´´æ¿å¯¼å…¥é…ç½®â€ã€‚ä¸‹æ–¹è¡¨æ ¼ä¼šè®°å½•æœ€è¿‘çš„å¤‡ä»½å’Œæ¢å¤æ“ä½œã€‚</div>
                            <div class="miniBtns">
                                <button class="btn" type="button" data-action="exportSettings">å¯¼å‡ºä¸º JSON æ–‡ä»¶</button>
                                <label class="btn">
                                    <input type="file" data-role="settingsFile" accept="application/json,.json" style="display:none">
                                    é€‰æ‹© JSON æ–‡ä»¶
                                </label>
                                <button class="btn" type="button" data-action="copySettings">å¤åˆ¶é…ç½®ä¸º JSON</button>
                                <button class="btn" type="button" data-action="pasteSettings">ä»å‰ªè´´æ¿å¯¼å…¥é…ç½®</button>
                            </div>
                            <div class="miniBtns">
                                <span class="hint">å¯¼å…¥æ¨¡å¼ï¼š</span>
                                <select data-role="importMode">
                                    <option value="merge">åˆå¹¶ï¼ˆä¿ç•™å½“å‰æœªåœ¨æ–‡ä»¶ä¸­çš„è®¾ç½®ï¼‰</option>
                                    <option value="overwrite">è¦†ç›–ï¼ˆä»¥æ–‡ä»¶å†…å®¹ä¸ºå‡†ï¼‰</option>
                                </select>
                                <button class="btn btnPrimary" type="button" data-action="importSettings">ä»æ–‡ä»¶å¯¼å…¥é…ç½®</button>
                            </div>
                            <div class="hint">å¯¼å‡ºæ–‡ä»¶å‘½åå»ºè®®ï¼š${escapeHtml(getExportFileName())}</div>
                            <div class="configAuditTitle">
                                <span>æœ€è¿‘é…ç½®æ“ä½œ</span>
                                <div class="configAuditControls">
                                    <select data-role="configAuditFilter">
                                        <option value="all">å…¨éƒ¨ç±»å‹</option>
                                        <option value="settings">ä»…è®¾ç½®å˜æ›´</option>
                                        <option value="importExport">ä»…å¯¼å…¥ / å¯¼å‡º</option>
                                        <option value="listChange">ä»…åå•è°ƒæ•´</option>
                                        <option value="logExport">ä»…æ—¥å¿—å¯¼å‡º</option>
                                    </select>
                                    <input class="configAuditSearch" data-role="configAuditSearch" placeholder="æœç´¢åŸŸåæˆ–è¯¦æƒ…">
                                </div>
                            </div>
                            <div class="configAuditWrapper">
                                <div class="configAuditBody">æ­£åœ¨åŠ è½½â€¦</div>
                            </div>
                            <div class="miniBtns" style="margin-top: 6px;">
                                <button class="btn" type="button" data-action="exportConfigAuditLog">å¯¼å‡ºé…ç½®æ“ä½œæ—¥å¿—</button>
                                <button class="btn" type="button" data-action="copyConfigAuditLog">å¤åˆ¶é…ç½®æ“ä½œæ—¥å¿—</button>
                            </div>
                        </div>
                    </div>
                    `;
                    const sectionDebug = buildSection(
                        'debug',
                        'ğŸ è°ƒè¯•',
                        `${renderRowFromSchema('debugOverlay')}${renderRowFromSchema('debugLogLevel')}${renderRowFromSchema('debugSyncInterval')}`
                    );
                    const sectionBlacklist = `
                                <div class="section" data-layout-section="blacklist">
                                    <div class="sectionTitle">ğŸš« é»‘åå•</div>
                                    <div class="field">
                                        <div class="label">é»‘åå•åŸŸåï¼ˆä¸€è¡Œä¸€ä¸ªï¼‰</div>
                                        <div class="desc">å‘½ä¸­é»‘åå•çš„ç«™ç‚¹è„šæœ¬å°†ä¸åšä»»ä½•ä¿®æ”¹ã€‚å¡«å†™ example.com ä¼šåŒæ—¶åŒ¹é… sub.example.comã€‚æ”¯æŒé€—å·/ä¸­æ–‡é€—å·/æ¢è¡Œç²˜è´´ï¼Œä¼šè‡ªåŠ¨æ¢è¡Œè§„èŒƒåŒ–ã€‚</div>
                                        <textarea data-field="excludeDomains" spellcheck="false"></textarea>
                                        <div class="miniBtns">
                                            <button class="btn" type="button" data-action="addCurrent">åŠ å…¥é»‘åå•</button>
                                            <button class="btn" type="button" data-action="removeCurrent">ç§»å‡ºé»‘åå•</button>
                                            <button class="btn btnDanger" type="button" data-action="clearExclude">æ¸…ç©ºé»‘åå•</button>
                                        </div>
                                        <div class="hint">æç¤ºï¼šé»‘åå•ä¼˜å…ˆç”Ÿæ•ˆï¼Œå‘½ä¸­åè„šæœ¬ä¸ä¼šä¿®æ”¹è¯¥ç«™ç‚¹ä»»ä½•é“¾æ¥ã€‚</div>
                                    </div>
                                </div>
                    `;

                    const sections = {
                        basic: sectionBasic,
                        reading: sectionReading,
                        search: sectionSearch,
                        csdn: sectionCsdn,
                        qqmail: sectionQqMail,
                        pan: sectionPanCode,
                        hover: sectionHoverTips,
                        pin: sectionPin,
                        strategy: sectionStrategy,
                        redirect: sectionRedirect,
                        text: sectionTextLink,
                        backup: sectionBackup,
                        debug: sectionDebug,
                        blacklist: sectionBlacklist,
                    };

                    const order = getLayoutOrder(mode);
                    let out = '';
                    for (let i = 0; i < order.length; i++) {
                        const key = order[i];
                        if (sections[key]) out += sections[key];
                    }
                    return out;
                };

                const html = `
                    <div class="backdrop" part="backdrop" data-theme="${escapeHtml(appliedTheme)}">
                        <div class="panel" part="panel" tabindex="-1">
                            <div class="header">
                                <div class="headerLeft">
                                    <div class="title"><span>âš™</span><span>æ–°æ ‡ç­¾é¡µPro - è®¾ç½®</span></div>
                                    <div class="subtitle">å½“å‰åŸŸåï¼š<span class="subtitleHost">${escapeHtml(hostname || '(ç©º)')}</span></div>
                                </div>
                                <div class="headerRight">
                                    <input class="settingsSearch" data-role="settingsSearch" placeholder="æœç´¢è®¾ç½®é¡¹â€¦" spellcheck="false" />
                                    <div class="versionBadge">v${escapeHtml(uiVersion)}</div>
                                    <button class="btn sidebarToggleBtn" type="button" data-action="toggleSidebar">å¯¼èˆª</button>
                                    <button class="btn" type="button" data-action="checkUpdate">æ£€æŸ¥æ›´æ–°</button>
                                    <button class="close" type="button" data-action="close">å…³é—­ (Esc)</button>
                                </div>
                            </div>
                            <div class="body">
                                <div class="sidebarMask" data-action="toggleSidebar"></div>
                                <div class="sidebar" data-role="sidebar">
                                    <div class="sideBlock">
                                        <div class="sideBlockTitle">ğŸ¨ å¤–è§‚</div>
                                        <div class="quickMenuBody">
                                            ${renderQuickMenuSelectFromSchema('uiTheme', 'è®¾ç½®é¢æ¿ä¸»é¢˜')}
                                            ${renderQuickMenuSelectFromSchema('settingsLayoutMode', 'è®¾ç½®é¢æ¿å¸ƒå±€')}
                                            ${renderQuickMenuSelectFromSchema('settingsLayoutStyle', 'è®¾ç½®é¢æ¿å¯†åº¦')}
                                            ${renderQuickMenuSelectFromSchema('menuDisplayMode', 'æ²¹çŒ´èœå•æ˜¾ç¤º')}
                                        </div>
                                    </div>
                                    <div class="sideBlock">
                                        <div class="sideBlockTitle">ğŸ“Œ å¯¼èˆª</div>
                                        <div class="navList" data-role="nav"></div>
                                    </div>
                                </div>
                                <div class="content" data-style="${escapeHtml(normalizeLayoutStyle(current.settingsLayoutStyle))}" data-switching="0">
                                    ${renderSectionsByLayoutMode(current.settingsLayoutMode)}
                                </div>
                            </div>
                            <div class="buttons">
                                <button class="btn" type="button" data-action="cancel">å–æ¶ˆ</button>
                                <button class="btn btnDanger" type="button" data-action="reset">â™» æ¢å¤é»˜è®¤</button>
                                <button class="btn btnPrimary" type="button" data-action="save">ä¿å­˜å¹¶åˆ·æ–°</button>
                            </div>
                        </div>
                    </div>
                `;

                const cssExtra = `
                    .panel { width: min(1180px, 100%); max-height: min(90vh, 960px); position: relative; }
                    .headerRight { gap: 10px; }
                    .sidebarToggleBtn { display: none; }
                    .settingsSearch {
                        width: min(360px, 46vw);
                        max-width: 420px;
                        min-width: 160px;
                        border: 1px solid var(--control-border);
                        background: var(--control-bg);
                        color: inherit;
                        padding: 7px 10px;
                        border-radius: 10px;
                        font-size: 12px;
                        outline: none;
                    }
                    .settingsSearch:focus { box-shadow: 0 0 0 3px var(--focus); }
                    .body { display: flex; min-height: 0; flex: 1 1 auto; }
                    .sidebarMask { display: none; }
                    .sidebar {
                        width: 280px;
                        flex: 0 0 auto;
                        border-right: 1px solid var(--divider);
                        background: var(--panel-bg);
                        padding: 10px;
                        box-sizing: border-box;
                        overflow: auto;
                        scrollbar-width: thin;
                        scrollbar-color: var(--scrollbar-thumb) transparent;
                    }
                    .sideBlock {
                        border: 1px solid var(--section-border);
                        background: var(--section-bg);
                        border-radius: 12px;
                        padding: 10px;
                        margin-bottom: 10px;
                    }
                    .sideBlockTitle { font-size: 12px; font-weight: 700; opacity: .92; margin-bottom: 8px; }
                    .navList { display: grid; gap: 6px; }
                    .navItem {
                        appearance: none;
                        border: 1px solid var(--section-border);
                        background: var(--panel-bg);
                        color: inherit;
                        border-radius: 10px;
                        padding: 8px 10px;
                        text-align: left;
                        cursor: pointer;
                        font-size: 12px;
                        line-height: 1.2;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    }
                    .navSubItem {
                        padding-left: 18px;
                        font-size: 11px;
                        opacity: .88;
                    }
                    .navItem:hover { background: var(--hover-bg); }
                    .navItem[data-active=\"1\"] { border-color: rgba(99,102,241,.6); background: rgba(99,102,241,.12); }
                    .content { flex: 1 1 auto; padding: 12px; overflow: auto; }
                    [data-filter-hide=\"1\"] { display: none !important; }
                    @media (max-width: 980px) {
                        .panel { width: min(980px, 100%); }
                        .sidebar { width: 240px; }
                        .settingsSearch { width: min(280px, 52vw); }
                    }
                    @media (max-width: 760px) {
                        .settingsSearch { width: min(320px, 58vw); }
                        .sidebarToggleBtn { display: inline-flex; }
                        .sidebarMask {
                            display: block;
                            position: absolute;
                            inset: 0;
                            background: rgba(0,0,0,.35);
                            opacity: 0;
                            pointer-events: none;
                            transition: opacity .18s ease;
                            z-index: 3;
                        }
                        .sidebar {
                            display: block;
                            position: absolute;
                            top: 0;
                            bottom: 0;
                            left: 0;
                            width: min(82vw, 300px);
                            transform: translateX(-105%);
                            transition: transform .18s ease;
                            z-index: 4;
                            box-shadow: 0 18px 60px var(--panel-shadow);
                        }
                        .panel[data-sidebar-open="1"] .sidebar { transform: translateX(0); }
                        .panel[data-sidebar-open="1"] .sidebarMask { opacity: 1; pointer-events: auto; }
                    }
                `;

                const styleEl = document.createElement('style');
                styleEl.textContent = css + cssExtra;
                root.appendChild(styleEl);

                const wrap = document.createElement('div');
                wrap.innerHTML = html;
                root.appendChild(wrap);

                const backdrop = root.querySelector('.backdrop');
                const panel = root.querySelector('.panel');
                const contentEl = root.querySelector('.content');
                const headerEl = root.querySelector('.header');
                const navEl = root.querySelector('[data-role="nav"]');
                const settingsSearchEl = root.querySelector('input[data-role="settingsSearch"]');
                const perfBadgeEl = root.querySelector('[data-role="perfBadge"]');
                try {
                    const list = contentEl ? contentEl.querySelectorAll('.row input[type="checkbox"][data-field]') : [];
                    for (let i = 0; i < list.length; i++) {
                        const input = list[i];
                        if (!(input instanceof HTMLInputElement)) continue;
                        const row = input.closest && input.closest('.row');
                        if (!row) continue;
                        if (input.checked) row.setAttribute('data-checked', '1');
                        else row.removeAttribute('data-checked');
                    }
                } catch (e) {}
                const isNarrowUi = () => {
                    try {
                        return (window && typeof window.innerWidth === 'number' ? window.innerWidth : 9999) <= 760;
                    } catch (e) {
                        return false;
                    }
                };
                const setSidebarOpen = (open) => {
                    if (!panel || !panel.setAttribute) return;
                    panel.setAttribute('data-sidebar-open', open ? '1' : '0');
                };
                const toggleSidebar = () => {
                    if (!panel || !panel.getAttribute) return;
                    const open = panel.getAttribute('data-sidebar-open') === '1';
                    setSidebarOpen(!open);
                };
                setSidebarOpen(false);
                updatePerfBadgeUi = () => {
                    if (!perfBadgeEl) return;
                    const p = DebugState.perf || {};
                    const s = p.settings || {};
                    const kpi = p.kpi || {};
                    const fmt = (v) => (typeof v === 'number' && Number.isFinite(v) ? Math.round(v) : 0);
                    const openMs = fmt(s.openMs);
                    const layoutMs = fmt(s.layoutMs);
                    const styleMs = fmt(s.styleMs);
                    const renderMs = fmt(s.renderMs);
                    const bad =
                        (kpi.openMs && openMs > kpi.openMs) ||
                        (kpi.layoutMs && layoutMs > kpi.layoutMs) ||
                        (kpi.styleMs && styleMs > kpi.styleMs) ||
                        (kpi.renderMs && renderMs > kpi.renderMs);
                    perfBadgeEl.textContent = `P:o${openMs} l${layoutMs} s${styleMs} r${renderMs}`;
                    perfBadgeEl.setAttribute('data-bad', bad ? '1' : '0');
                };
                try {
                    DebugState.onPerf = updatePerfBadgeUi;
                } catch (e) {}
                updatePerfBadgeUi();
                

                panelLifecycle = (function() {
                    let disposed = false;
                    const disposers = [];
                    const taskCancelByLabel = new Map();

                    const addDisposer = (fn) => {
                        if (typeof fn !== 'function') return;
                        if (disposed) {
                            try { fn(); } catch (e) {}
                            return;
                        }
                        disposers.push(fn);
                    };

                    const cancelByLabel = (label) => {
                        const k = String(label || '');
                        if (!k) return;
                        const cancel = taskCancelByLabel.get(k);
                        if (typeof cancel === 'function') {
                            try { cancel(); } catch (e) {}
                        }
                        taskCancelByLabel.delete(k);
                    };

                    const on = (target, type, handler, options) => {
                        if (!target || typeof target.addEventListener !== 'function') return;
                        try { target.addEventListener(type, handler, options); } catch (e) {}
                        addDisposer(() => {
                            try { target.removeEventListener(type, handler, options); } catch (e) {}
                        });
                    };

                    const setTimeoutTracked = (fn, ms) => {
                        let id = 0;
                        try { id = setTimeout(fn, ms || 0); } catch (e) { id = 0; }
                        if (id) {
                            addDisposer(() => {
                                try { clearTimeout(id); } catch (e) {}
                            });
                        }
                        return id;
                    };

                    const rafTracked = (fn) => {
                        let id = 0;
                        try { id = requestAnimationFrame(fn); } catch (e) { id = 0; }
                        if (id) {
                            addDisposer(() => {
                                try { if (typeof cancelAnimationFrame === 'function') cancelAnimationFrame(id); } catch (e) {}
                            });
                        }
                        return id;
                    };

                    const schedule = (runLabel, runner, idleTimeout, rafFallback, timeoutMs) => {
                        const label = String(runLabel || '');
                        if (label) cancelByLabel(label);

                        const wrapped = () => withErrorBoundary(label || runLabel, runner);
                        let id = 0;
                        let cancel = null;

                        if (typeof requestIdleCallback === 'function') {
                            try {
                                id = requestIdleCallback(wrapped, { timeout: idleTimeout || 600 });
                                cancel = () => {
                                    try { if (typeof cancelIdleCallback === 'function') cancelIdleCallback(id); } catch (e) {}
                                };
                            } catch (e) {}
                        }
                        if (!id && typeof requestAnimationFrame === 'function' && rafFallback !== false) {
                            try {
                                id = requestAnimationFrame(wrapped);
                                cancel = () => {
                                    try { if (typeof cancelAnimationFrame === 'function') cancelAnimationFrame(id); } catch (e) {}
                                };
                            } catch (e) {}
                        }
                        if (!id) {
                            try {
                                id = setTimeout(wrapped, timeoutMs || 50);
                                cancel = () => {
                                    try { clearTimeout(id); } catch (e) {}
                                };
                            } catch (e) {
                                id = 0;
                                cancel = null;
                            }
                        }

                        if (id && typeof cancel === 'function') {
                            addDisposer(cancel);
                            if (label) taskCancelByLabel.set(label, cancel);
                        }
                        return id;
                    };

                    const setTimeoutByLabel = (runLabel, runner, ms) => {
                        const label = String(runLabel || '');
                        if (label) cancelByLabel(label);

                        let id = 0;
                        try {
                            id = setTimeout(() => withErrorBoundary(label || runLabel, runner), ms || 0);
                        } catch (e) {
                            id = 0;
                        }
                        if (id) {
                            const cancel = () => {
                                try { clearTimeout(id); } catch (e) {}
                            };
                            addDisposer(cancel);
                            if (label) taskCancelByLabel.set(label, cancel);
                        }
                        return id;
                    };

                    const trackObserver = (io) => {
                        if (io && typeof io.disconnect === 'function') {
                            addDisposer(() => {
                                try { io.disconnect(); } catch (e) {}
                            });
                        }
                        return io;
                    };

                    const dispose = () => {
                        if (disposed) return;
                        disposed = true;
                        try {
                            for (const cancel of taskCancelByLabel.values()) {
                                try { if (typeof cancel === 'function') cancel(); } catch (e) {}
                            }
                        } catch (e) {}
                        try { taskCancelByLabel.clear(); } catch (e) {}
                        for (let i = disposers.length - 1; i >= 0; i--) {
                            try { disposers[i](); } catch (e) {}
                        }
                        disposers.length = 0;
                    };

                    return { addDisposer, on, setTimeoutTracked, rafTracked, schedule, setTimeoutByLabel, trackObserver, dispose };
                })();

                const scheduleManaged = (runLabel, runner, idleTimeout, rafFallback, timeoutMs) =>
                    panelLifecycle.schedule(runLabel, runner, idleTimeout, rafFallback, timeoutMs);
                const setTimeoutManaged = (fn, ms) => panelLifecycle.setTimeoutTracked(fn, ms);
                const setTimeoutManagedByLabel = (runLabel, runner, ms) => panelLifecycle.setTimeoutByLabel(runLabel, runner, ms);
                const trackObserver = (io) => panelLifecycle.trackObserver(io);
                const panelAddListener = (target, type, handler, opts) => {
                    const passive = opts && typeof opts.passive === 'boolean' ? opts.passive : isPassivePreferred(type);
                    const capture = opts && typeof opts.capture === 'boolean' ? opts.capture : true;
                    panelLifecycle.on(target, type, handler, { passive, capture });
                };

                panelLifecycle.addDisposer(() => {
                    try {
                        if (typeof destroyVirtualViews === 'function') destroyVirtualViews();
                    } catch (e) {}
                    destroyVirtualViews = null;
                });
                try {
                    const tOpenMs = Math.round((nowPerfMs() - __perfStart));
                    debugLog('settingsOpenPerf', { tOpenMs }, 'INFO');
                    recordPerf('openMs', tOpenMs);
                } catch (e) {}
                try {
                    recordPerf('domDepth', measureDomDepth(panel, 8000));
                } catch (e) {}
                try {
                    const heap = performance && performance.memory && typeof performance.memory.usedJSHeapSize === 'number' ? performance.memory.usedJSHeapSize : 0;
                    if (heap > 0) recordPerf('heapMB', Math.round(heap / 1024 / 1024));
                } catch (e) {}

                const sectionByKey = new Map();
                try {
                    const secs = contentEl ? contentEl.querySelectorAll('.section') : [];
                    for (let i = 0; i < secs.length; i++) {
                        const s = secs[i];
                        const k = s && s.getAttribute ? s.getAttribute('data-layout-section') : '';
                        if (k) sectionByKey.set(String(k), s);
                    }
                } catch (e) {}

                const navBtnByKey = new Map();
                const navSubBtnByKey = new Map();
                const buildNavSubKey = (key, submenu) => `${String(key || '')}::${String(submenu || '')}`;
                const syncNavActive = (key, submenu) => {
                    if (!key) return;
                    const btn = navBtnByKey.get(key);
                    if (!btn) return;
                    for (const [k, b] of navBtnByKey.entries()) {
                        if (!b) continue;
                        b.setAttribute('data-active', k === key ? '1' : '0');
                    }
                    const subWanted = submenu ? buildNavSubKey(key, submenu) : '';
                    for (const [k, b] of navSubBtnByKey.entries()) {
                        if (!b) continue;
                        b.setAttribute('data-active', subWanted && k === subWanted ? '1' : '0');
                    }
                };
                try {
                    if (navEl && contentEl) {
                        navEl.innerHTML = '';
                        const order = getLayoutOrder(current.settingsLayoutMode);
                        const frag = document.createDocumentFragment();
                        for (let i = 0; i < order.length; i++) {
                            const k = order[i];
                            const sec = sectionByKey.get(k);
                            if (!sec) continue;
                            const t = sec.querySelector ? sec.querySelector('.sectionTitle') : null;
                            const label = t && t.textContent ? String(t.textContent).trim() : k;
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.className = 'navItem';
                            btn.setAttribute('data-action', 'nav');
                            btn.setAttribute('data-key', k);
                            btn.setAttribute('data-active', '0');
                            btn.textContent = label;
                            navBtnByKey.set(k, btn);
                            frag.appendChild(btn);

                            const subs = sec.querySelectorAll ? sec.querySelectorAll('details.subDetails[data-submenu]') : [];
                            for (let j = 0; j < subs.length; j++) {
                                const d = subs[j];
                                const submenu = d && d.getAttribute ? String(d.getAttribute('data-submenu') || '') : '';
                                if (!submenu) continue;
                                const sum = d.querySelector ? d.querySelector('summary') : null;
                                const subLabel = sum && sum.textContent ? String(sum.textContent).trim() : submenu;
                                const subBtn = document.createElement('button');
                                subBtn.type = 'button';
                                subBtn.className = 'navItem navSubItem';
                                subBtn.setAttribute('data-action', 'nav');
                                subBtn.setAttribute('data-key', k);
                                subBtn.setAttribute('data-submenu', submenu);
                                subBtn.setAttribute('data-active', '0');
                                subBtn.textContent = `â†³ ${subLabel}`;
                                navSubBtnByKey.set(buildNavSubKey(k, submenu), subBtn);
                                frag.appendChild(subBtn);
                            }
                        }
                        navEl.appendChild(frag);
                        const firstKey = order && order.length ? order.find((k) => sectionByKey.has(k)) : '';
                        if (firstKey) syncNavActive(firstKey);
                    }
                } catch (e) {}

                const getContentScrollOffsetPx = () => {
                    if (!contentEl) return 10;
                    let padTop = 0;
                    try {
                        const cs = getComputedStyle(contentEl);
                        padTop = Number.parseFloat(cs && cs.paddingTop ? cs.paddingTop : '0') || 0;
                    } catch (e) {
                        padTop = 0;
                    }
                    return Math.max(0, padTop) + 10;
                };
                const scheduleSyncNavByScroll = () => {
                    if (!contentEl || navRaf) return;
                    try {
                        navRaf = panelLifecycle.rafTracked(() => {
                            navRaf = 0;
                            if (!contentEl || !contentEl.isConnected) return;
                            const list = contentEl.querySelectorAll('.section');
                            if (!list || !list.length) return;
                            const crect = contentEl.getBoundingClientRect();
                            const ctop = crect.top + getContentScrollOffsetPx();
                            let bestKey = '';
                            let bestDist = Infinity;
                            for (let i = 0; i < list.length; i++) {
                                const s = list[i];
                                if (!s || s.getAttribute('data-filter-hide') === '1') continue;
                                const r = s.getBoundingClientRect();
                                const d = Math.abs(r.top - ctop);
                                if (d < bestDist) {
                                    bestDist = d;
                                    bestKey = s.getAttribute('data-layout-section') || '';
                                }
                            }
                            if (bestKey) syncNavActive(bestKey);
                        });
                    } catch (e) {
                        navRaf = 0;
                    }
                };
                const scrollContentToSection = (key) => {
                    if (!key || !contentEl) return;
                    try {
                        debugLog('settingsNav', { type: 'scrollRequest', key }, 'DEBUG');
                    } catch (e) {}
                    const sec =
                        sectionByKey.get(key) ||
                        contentEl.querySelector(`.section[data-layout-section="${cssEscape(key)}"]`);
                    if (!sec) {
                        try {
                            debugLog('settingsNav', { type: 'sectionNotFound', key }, 'WARN');
                        } catch (e2) {}
                        return;
                    }
                    syncNavActive(key);
                    let top = 0;
                    try {
                        const offset = getContentScrollOffsetPx();
                        const c = contentEl.getBoundingClientRect();
                        const r = sec.getBoundingClientRect();
                        const next = (Number(contentEl.scrollTop) || 0) + (r.top - c.top) - offset;
                        top = Math.max(0, next);
                        if (typeof contentEl.scrollTo === 'function') {
                            contentEl.scrollTo({ top, behavior: getNavScrollBehavior() });
                        } else {
                            contentEl.scrollTop = top;
                        }
                    } catch (e4) {
                        try {
                            sec.scrollIntoView({ block: 'start' });
                        } catch (e5) {}
                    }
                    try {
                        debugLog('settingsNav', { type: 'scrollApplied', key, top }, 'DEBUG');
                    } catch (e3) {}
                    scheduleSyncNavByScroll();
                };
                const scrollContentToTarget = (key, submenu) => {
                    if (!key || !contentEl) return;
                    const sec =
                        sectionByKey.get(key) ||
                        (() => {
                            try {
                                const list = contentEl.querySelectorAll('.section');
                                for (let i = 0; i < list.length; i++) {
                                    const s = list[i];
                                    if (!s) continue;
                                    if ((s.getAttribute('data-layout-section') || '') === key) return s;
                                }
                            } catch (e) {}
                            return null;
                        })();
                    if (!sec) {
                        try {
                            debugLog('settingsNav', { type: 'sectionNotFound', key }, 'WARN');
                        } catch (e2) {}
                        return;
                    }

                    const scrollToElement = (el, isSubmenu) => {
                        let top = 0;
                        try {
                            const offset = getContentScrollOffsetPx();
                            const c = contentEl.getBoundingClientRect();
                            const r = el.getBoundingClientRect();
                            const next = (Number(contentEl.scrollTop) || 0) + (r.top - c.top) - offset;
                            top = Math.max(0, next);
                            if (typeof contentEl.scrollTo === 'function') {
                                let behavior = getNavScrollBehavior();
                                if (isSubmenu && behavior === 'smooth') behavior = 'auto';
                                contentEl.scrollTo({ top, behavior });
                            } else {
                                contentEl.scrollTop = top;
                            }
                        } catch (e4) {
                            try {
                                el.scrollIntoView({ block: 'start' });
                            } catch (e5) {}
                        }
                        scheduleSyncNavByScroll();
                        return top;
                    };

                    if (!submenu) {
                        syncNavActive(key);
                        const top = scrollToElement(sec, false);
                        try {
                            debugLog('settingsNav', { type: 'scrollApplied', key, top }, 'DEBUG');
                        } catch (e3) {}
                        return;
                    }

                    let details = null;
                    try {
                        const list = sec.querySelectorAll('details.subDetails[data-submenu]');
                        for (let i = 0; i < list.length; i++) {
                            const d = list[i];
                            if (!d) continue;
                            if ((d.getAttribute('data-submenu') || '') === submenu) {
                                details = d;
                                break;
                            }
                        }
                    } catch (e) {
                        details = null;
                    }
                    if (!details) {
                        try {
                            debugLog('settingsNav', { type: 'submenuNotFound', key, submenu }, 'WARN');
                        } catch (e2) {}
                        return;
                    }

                    try {
                        details.open = true;
                    } catch (e) {}
                    syncNavActive(key, submenu);

                    submenuScrollKey = key;
                    submenuScrollSubmenu = submenu;
                    if (submenuScrollRaf) return;
                    try {
                        submenuScrollRaf = panelLifecycle.rafTracked(() => {
                            submenuScrollRaf = 0;
                            const k = submenuScrollKey;
                            const s = submenuScrollSubmenu;
                            submenuScrollKey = '';
                            submenuScrollSubmenu = '';
                            if (!k || !contentEl || !contentEl.isConnected) return;
                            const d = (() => {
                                try {
                                    const sec0 =
                                        sectionByKey.get(k) ||
                                        contentEl.querySelector(`.section[data-layout-section="${cssEscape(k)}"]`);
                                    if (!sec0) return null;
                                    const list0 = sec0.querySelectorAll('details.subDetails[data-submenu]');
                                    for (let i = 0; i < list0.length; i++) {
                                        const it = list0[i];
                                        if (!it) continue;
                                        if ((it.getAttribute('data-submenu') || '') === s) return it;
                                    }
                                } catch (e) {}
                                return null;
                            })();
                            if (!d) return;
                            if (!d.isConnected) return;
                            try {
                                d.open = true;
                            } catch (e) {}
                            const top = scrollToElement(d, true);
                            try {
                                debugLog('settingsNav', { type: 'submenuScrollApplied', key: k, submenu: s, top }, 'DEBUG');
                            } catch (e3) {}
                        });
                    } catch (e3) {
                        submenuScrollRaf = 0;
                        try {
                            const top = scrollToElement(details, true);
                            debugLog('settingsNav', { type: 'submenuScrollApplied', key, submenu, top }, 'DEBUG');
                        } catch (e4) {}
                    }
                };
                try {
                    if (contentEl) panelAddListener(contentEl, 'scroll', scheduleSyncNavByScroll, { passive: true });
                } catch (e) {}

                const applySettingsSearch = () => {
                    const q = String((settingsSearchEl && settingsSearchEl.value) || '').trim().toLowerCase();
                    const hideAttr = 'data-filter-hide';
                    const secList = contentEl ? contentEl.querySelectorAll('.section') : [];
                    for (let i = 0; i < secList.length; i++) {
                        const sec = secList[i];
                        if (!sec) continue;
                        if (!q) {
                            sec.removeAttribute(hideAttr);
                            const items = sec.querySelectorAll('.row, .block, details.subDetails');
                            for (let j = 0; j < items.length; j++) items[j].removeAttribute(hideAttr);
                            continue;
                        }
                        const items = sec.querySelectorAll('.row, .block, details.subDetails');
                        let any = false;
                        for (let j = 0; j < items.length; j++) {
                            const it = items[j];
                            const txt = it && it.textContent ? String(it.textContent).toLowerCase() : '';
                            const hit = txt.indexOf(q) !== -1;
                            if (hit) any = true;
                            if (hit) it.removeAttribute(hideAttr);
                            else it.setAttribute(hideAttr, '1');
                        }
                        if (any) sec.removeAttribute(hideAttr);
                        else sec.setAttribute(hideAttr, '1');
                    }
                    scheduleSyncNavByScroll();
                };
                const scheduleApplySettingsSearch = () => {
                    if (searchRaf) return;
                    try {
                        searchRaf = panelLifecycle.rafTracked(() => {
                            searchRaf = 0;
                            applySettingsSearch();
                        });
                    } catch (e) {
                        searchRaf = 0;
                        applySettingsSearch();
                    }
                };
                try {
                    if (settingsSearchEl) panelAddListener(settingsSearchEl, 'input', scheduleApplySettingsSearch, { passive: true });
                } catch (e) {}

                let currentLayoutMode = normalizeLayoutMode(current.settingsLayoutMode);
                const reorderSectionsInDom = (nextMode) => {
                    if (!contentEl) return;
                    const norm = normalizeLayoutMode(nextMode);
                    if (norm === currentLayoutMode) return;
                    const __t0 = nowPerfMs();
                    currentLayoutMode = norm;
                    const order = getLayoutOrder(norm);
                    if (!order || !order.length) return;
                    try { contentEl.setAttribute('data-switching', '1'); } catch (e) {}
                    try { contentEl.style.visibility = 'hidden'; } catch (e) {}
                    const frag = document.createDocumentFragment();
                    for (let i = 0; i < order.length; i++) {
                        const k = order[i];
                        const sec = sectionByKey.get(k) || contentEl.querySelector(`.section[data-layout-section="${cssEscape(k)}"]`);
                        if (sec) frag.appendChild(sec);
                    }
                    contentEl.appendChild(frag);
                    try { recordPerf('layoutMs', Math.round(nowPerfMs() - __t0), { mode: norm, n: order.length }); } catch (e) {}
                    try {
                        panelLifecycle.rafTracked(() => {
                            try { contentEl.style.visibility = ''; } catch (e) {}
                            setTimeoutManaged(() => { try { contentEl.setAttribute('data-switching', '0'); } catch (e) {} }, 300);
                        });
                    } catch (e) {
                        try { contentEl.style.visibility = ''; } catch (e2) {}
                        setTimeoutManaged(() => { try { contentEl.setAttribute('data-switching', '0'); } catch (e2) {} }, 300);
                    }
                };
                try {} catch (e) {}

                const inputByField = new Map();
                const selectByField = new Map();
                try {
                    const inputs = root.querySelectorAll('input[data-field]');
                    for (let i = 0; i < inputs.length; i++) {
                        const el = inputs[i];
                        const k = el && el.getAttribute ? el.getAttribute('data-field') : '';
                        if (k) inputByField.set(String(k), el);
                    }
                } catch (e) {}
                try {
                    const selects = root.querySelectorAll('select[data-field]');
                    for (let i = 0; i < selects.length; i++) {
                        const el = selects[i];
                        const k = el && el.getAttribute ? el.getAttribute('data-field') : '';
                        if (k) selectByField.set(String(k), el);
                    }
                } catch (e) {}

                const getChecked = (key) => {
                    const k = String(key ?? '');
                    const el = inputByField.get(k) || root.querySelector(`input[data-field="${cssEscape(k)}"]`);
                    return Boolean(el && el.checked);
                };

                const getSelect = (key) => {
                    const k = String(key ?? '');
                    const el = selectByField.get(k) || root.querySelector(`select[data-field="${cssEscape(k)}"]`);
                    return el ? String(el.value || '') : '';
                };

                const excludeEl = root.querySelector('textarea[data-field="excludeDomains"]');
                const textLinkIncludeEl = root.querySelector('textarea[data-field="textLinkifyIncludeHosts"]');
                const textLinkExcludeEl = root.querySelector('textarea[data-field="textLinkifyExcludeHosts"]');
                if (excludeEl) excludeEl.value = hostListToTextarea(hostListParse(current.excludeDomains || ''));
                if (textLinkIncludeEl) textLinkIncludeEl.value = hostListToTextarea(hostListParse(current.textLinkifyIncludeHosts || ''));
                if (textLinkExcludeEl) textLinkExcludeEl.value = hostListToTextarea(hostListParse(current.textLinkifyExcludeHosts || ''));
                hostListBindTextarea(excludeEl, panelAddListener);
                hostListBindTextarea(textLinkIncludeEl, panelAddListener);
                hostListBindTextarea(textLinkExcludeEl, panelAddListener);
                const themeEl = root.querySelector('select[data-field="uiTheme"]');
                if (themeEl && backdrop) {
                    backdrop.setAttribute('data-theme', resolveUiTheme(themeEl.value));
                    panelAddListener(themeEl, 'change', () => {
                        backdrop.setAttribute('data-theme', resolveUiTheme(themeEl.value));
                    }, { passive: true });
                }

                const appearanceMenuWrap = root.querySelector('[data-role="appearanceMenuWrap"]');
                const appearanceMenu = root.querySelector('[data-role="appearanceMenu"]');
                const setAppearanceMenuOpen = (open) => {
                    if (!appearanceMenu) return;
                    appearanceMenu.setAttribute('data-open', open ? '1' : '0');
                    try {
                        appearanceMenu.style.contain = 'layout paint';
                        appearanceMenu.style.willChange = open ? 'opacity, transform' : 'auto';
                    } catch (e) {}
                    const btn = appearanceMenuWrap && appearanceMenuWrap.querySelector ? appearanceMenuWrap.querySelector('[data-action="toggleAppearanceMenu"]') : null;
                    if (btn && btn.setAttribute) btn.setAttribute('aria-expanded', open ? 'true' : 'false');
                };
                const toggleAppearanceMenu = () => {
                    if (!appearanceMenu) return;
                    const open = appearanceMenu.getAttribute('data-open') === '1';
                    setAppearanceMenuOpen(!open);
                };

                
                const createVirtualTableView = (containerEl, headers, buildRowHtml, options) => {
                    const opt = options && typeof options === 'object' ? options : {};
                    const rowHeight = typeof opt.rowHeight === 'number' && opt.rowHeight > 0 ? Math.floor(opt.rowHeight) : 34;
                    const overscan = typeof opt.overscan === 'number' && opt.overscan >= 0 ? Math.floor(opt.overscan) : 8;
                    const emptyHtml = String(opt.emptyHtml || '<div class="configAuditEmpty">æš‚æ— è®°å½•ã€‚</div>');
                    const wrapperEl = containerEl && containerEl.closest ? containerEl.closest('.configAuditWrapper') : null;
                    const colCount = Array.isArray(headers) ? headers.length : 1;
                    let items = [];
                    let rafId = 0;
                    let tableEl = null;
                    let tbodyEl = null;
                    let active = false;

                    const ensureMounted = () => {
                        if (!containerEl) return false;
                        if (!wrapperEl) return false;
                        if (!active) active = true;
                        if (tableEl && tbodyEl && containerEl.contains(tableEl)) return true;
                        containerEl.innerHTML = `<table class="configAuditTable"><thead><tr>${headers
                            .map((h) => `<th>${escapeHtml(String(h))}</th>`)
                            .join('')}</tr></thead><tbody></tbody></table>`;
                        tableEl = containerEl.querySelector('table');
                        tbodyEl = tableEl ? tableEl.querySelector('tbody') : null;
                        return Boolean(tbodyEl);
                    };

                    const renderNow = () => {
                        if (!active) return;
                        if (!ensureMounted()) return;
                        const total = items.length;
                        if (!total) {
                            tbodyEl.innerHTML = `<tr><td colspan="${colCount}">${emptyHtml}</td></tr>`;
                            return;
                        }
                        const st = Math.max(0, Number(wrapperEl.scrollTop) || 0);
                        const vh = Math.max(1, Number(wrapperEl.clientHeight) || 1);
                        const start = Math.max(0, Math.floor(st / rowHeight) - overscan);
                        const end = Math.min(total, Math.ceil((st + vh) / rowHeight) + overscan);
                        const top = start * rowHeight;
                        const bottom = (total - end) * rowHeight;
                        let rows = '';
                        if (top > 0) rows += `<tr class="vtSpacerRow"><td colspan="${colCount}" style="height:${top}px;"></td></tr>`;
                        for (let i = start; i < end; i++) {
                            try {
                                rows += buildRowHtml(items[i], i);
                            } catch (e) {}
                        }
                        if (bottom > 0) rows += `<tr class="vtSpacerRow"><td colspan="${colCount}" style="height:${bottom}px;"></td></tr>`;
                        tbodyEl.innerHTML = rows || `<tr><td colspan="${colCount}">${emptyHtml}</td></tr>`;
                    };

                    const scheduleRender = () => {
                        if (!active) return;
                        if (rafId) return;
                        try {
                            rafId = panelLifecycle.rafTracked(() => {
                                rafId = 0;
                                renderNow();
                            });
                        } catch (e) {
                            rafId = 0;
                            renderNow();
                        }
                    };

                    const onScroll = () => scheduleRender();
                    if (wrapperEl) panelAddListener(wrapperEl, 'scroll', onScroll, { passive: true, capture: false });
                    try {
                        if (typeof ResizeObserver === 'function' && wrapperEl) {
                            const ro = new ResizeObserver(() => scheduleRender());
                            ro.observe(wrapperEl);
                            trackObserver(ro);
                        }
                    } catch (e) {}

                    return {
                        setItems(nextItems, resetScroll) {
                            items = Array.isArray(nextItems) ? nextItems : [];
                            if (!active) active = true;
                            if (wrapperEl && resetScroll !== false) {
                                try {
                                    wrapperEl.scrollTop = 0;
                                } catch (e) {}
                            }
                            scheduleRender();
                        },
                        render: scheduleRender,
                        destroy() {
                            active = false;
                            try {
                                if (rafId && typeof cancelAnimationFrame === 'function') cancelAnimationFrame(rafId);
                            } catch (e) {}
                            rafId = 0;
                        },
                    };
                };

                const createVirtualListView = (containerEl, buildItemHtml, options) => {
                    const opt = options && typeof options === 'object' ? options : {};
                    const itemHeight = typeof opt.itemHeight === 'number' && opt.itemHeight > 0 ? Math.floor(opt.itemHeight) : 88;
                    const overscan = typeof opt.overscan === 'number' && opt.overscan >= 0 ? Math.floor(opt.overscan) : 8;
                    const emptyHtml = String(opt.emptyHtml || '<div class="configAuditEmpty">æš‚æ— è®°å½•ã€‚</div>');
                    const wrapperEl = containerEl && containerEl.closest ? containerEl.closest('.configAuditWrapper') : null;
                    let items = [];
                    let rafId = 0;
                    let active = false;

                    const renderNow = () => {
                        if (!active) return;
                        if (!containerEl || !wrapperEl) return;
                        const total = items.length;
                        if (!total) {
                            containerEl.innerHTML = emptyHtml;
                            return;
                        }
                        const st = Math.max(0, Number(wrapperEl.scrollTop) || 0);
                        const vh = Math.max(1, Number(wrapperEl.clientHeight) || 1);
                        const start = Math.max(0, Math.floor(st / itemHeight) - overscan);
                        const end = Math.min(total, Math.ceil((st + vh) / itemHeight) + overscan);
                        const top = start * itemHeight;
                        const bottom = (total - end) * itemHeight;
                        let html = '';
                        if (top > 0) html += `<div style="grid-column:1/-1;height:${top}px;"></div>`;
                        for (let i = start; i < end; i++) {
                            try {
                                html += buildItemHtml(items[i], i);
                            } catch (e) {}
                        }
                        if (bottom > 0) html += `<div style="grid-column:1/-1;height:${bottom}px;"></div>`;
                        containerEl.innerHTML = html || emptyHtml;
                    };

                    const scheduleRender = () => {
                        if (!active) return;
                        if (rafId) return;
                        try {
                            rafId = panelLifecycle.rafTracked(() => {
                                rafId = 0;
                                renderNow();
                            });
                        } catch (e) {
                            rafId = 0;
                            renderNow();
                        }
                    };

                    const onScroll = () => scheduleRender();
                    if (wrapperEl) panelAddListener(wrapperEl, 'scroll', onScroll, { passive: true, capture: false });
                    try {
                        if (typeof ResizeObserver === 'function' && wrapperEl) {
                            const ro = new ResizeObserver(() => scheduleRender());
                            ro.observe(wrapperEl);
                            trackObserver(ro);
                        }
                    } catch (e) {}

                    return {
                        setItems(nextItems, resetScroll) {
                            items = Array.isArray(nextItems) ? nextItems : [];
                            if (!active) active = true;
                            if (wrapperEl && resetScroll !== false) {
                                try {
                                    wrapperEl.scrollTop = 0;
                                } catch (e) {}
                            }
                            scheduleRender();
                        },
                        render: scheduleRender,
                        destroy() {
                            active = false;
                            try {
                                if (rafId && typeof cancelAnimationFrame === 'function') cancelAnimationFrame(rafId);
                            } catch (e) {}
                            rafId = 0;
                        },
                    };
                };

                const openUpdatePage = () => {
                    if (!SCRIPT_UPDATE_URL) return;
                    try {
                        if (typeof GM_openInTab === 'function') {
                            GM_openInTab(SCRIPT_UPDATE_URL, { active: true, insert: true, setParent: true });
                            return;
                        }
                    } catch (e) {}
                    try {
                        window.open(SCRIPT_UPDATE_URL, '_blank', 'noopener,noreferrer');
                    } catch (e2) {}
                };

                const fileInput = root.querySelector('input[data-role="settingsFile"]');
                const importModeEl = root.querySelector('select[data-role="importMode"]');
                const configAuditBody = root.querySelector('.configAuditBody');
                const configAuditFilterEl = root.querySelector('select[data-role="configAuditFilter"]');
                const configAuditSearchEl = root.querySelector('input[data-role="configAuditSearch"]');
                let currentAuditFilter = 'all';
                let currentAuditSearch = '';
                if (configAuditFilterEl) {
                    currentAuditFilter = configAuditFilterEl.value || 'all';
                    panelAddListener(configAuditFilterEl, 'change', () => {
                        currentAuditFilter = configAuditFilterEl.value || 'all';
                        refreshConfigAuditView();
                    }, { passive: true });
                }
                if (configAuditSearchEl) {
                    currentAuditSearch = configAuditSearchEl.value || '';
                    panelAddListener(configAuditSearchEl, 'input', () => {
                        currentAuditSearch = configAuditSearchEl.value || '';
                        refreshConfigAuditView();
                    }, { passive: true });
                }

                const refreshConfigAuditView = () => {
                    if (!configAuditBody) return;
                    const __t0 = nowPerfMs();
                    const committed = readConfigAuditLog();
                    configAuditBody.innerHTML = renderConfigAuditTable(
                        committed,
                        draftConfigAudits,
                        currentAuditFilter,
                        currentAuditSearch
                    );
                    const __ms = Math.round(nowPerfMs() - __t0);
                    try { recordPerf('renderMs', __ms, { section: 'audit' }); } catch (e) {}
                    try { SettingsPanelCache.configAuditHtml = configAuditBody.innerHTML; } catch (e) {}
                };
                scheduleManaged('settingsAuditPopulate', refreshConfigAuditView, 800, true, 50);

                const panHistoryBody = root.querySelector('.panHistoryBody');
                const panFavoritesBody = root.querySelector('.panFavoritesBody');
                const panHistorySearchEl = root.querySelector('input[data-role="panHistorySearch"]');
                const panFavoritesSearchEl = root.querySelector('input[data-role="panFavoritesSearch"]');
                const panHistoryCountEl = root.querySelector('[data-role="panHistoryCount"]');
                const panFavoritesCountEl = root.querySelector('[data-role="panFavoritesCount"]');
                const virtualStops = [];
                const addVirtualStop = (fn) => {
                    if (typeof fn === 'function') virtualStops.push(fn);
                };
                destroyVirtualViews = () => {
                    for (let i = virtualStops.length - 1; i >= 0; i--) {
                        try {
                            virtualStops[i]();
                        } catch (e) {}
                    }
                    virtualStops.length = 0;
                };

                const buildPanCodeItems = (rawItems, favoritesSet, searchRaw, limitRaw) => {
                    const search = String(searchRaw || '').trim().toLowerCase();
                    const list = Array.isArray(rawItems) ? rawItems : [];
                    const limit = typeof limitRaw === 'number' && limitRaw > 0 ? Math.floor(limitRaw) : 200;
                    const out = [];
                    for (let i = list.length - 1; i >= 0; i--) {
                        const it = normalizePanCodeEntryFromArray(list[i]);
                        if (!it) continue;
                        const key = it[0];
                        const href = it[1];
                        const code = it[2];
                        const provider = it[3];
                        const t = it[4];
                        let providerKey = '';
                        try {
                            const info = getPanCodeProviderInfoByHref(href);
                            providerKey = info && info.key ? String(info.key) : '';
                        } catch (e) {
                            providerKey = '';
                        }
                        if (search) {
                            const hay = `${key} ${href} ${code} ${provider} ${providerKey}`.toLowerCase();
                            if (hay.indexOf(search) === -1) continue;
                        }
                        out.push({
                            key,
                            href,
                            code,
                            provider,
                            providerKey,
                            t,
                            fav: Boolean(favoritesSet && favoritesSet.has(key)),
                        });
                        if (out.length >= limit) break;
                    }
                    return out;
                };

                const buildPanCardHtml = (mode, showFav) => (it) => {
                    if (!it) return '';
                    const dt = formatDateTimeForDisplay(new Date(it.t));
                    const shortHref = shorten(it.href, 96);
                    const fav = Boolean(it.fav);
                    const op =
                        mode === 'favorites'
                            ? `<button class="btn btnTiny" type="button" data-action="panFavRemove" data-key="${escapeHtml(it.key)}">å–æ¶ˆæ”¶è—</button>`
                            : (showFav
                                ? `<button class="btn btnTiny" type="button" data-action="panFavToggle" data-key="${escapeHtml(
                                        it.key
                                    )}" data-pan-href="${escapeHtml(it.href)}" data-code="${escapeHtml(it.code)}" data-provider="${escapeHtml(
                                        it.provider
                                    )}" data-time="${escapeHtml(String(it.t))}">${fav ? 'å–æ¶ˆæ”¶è—' : 'æ”¶è—'}</button>`
                                : '');
                    const del =
                        mode === 'history'
                            ? `<button class="btn btnTiny" type="button" data-action="panHistoryRemove" data-key="${escapeHtml(it.key)}">åˆ é™¤</button>`
                            : '';
                    return `<div class="card" style="grid-column:1/-1;">
                        <div class="meta"><span class="time" title="${escapeHtml(dt)}">${escapeHtml(dt)}</span><span class="panProviderBadge" data-key="${escapeHtml(
                        it.providerKey || ''
                    )}" title="${escapeHtml(it.provider)}">${escapeHtml(it.provider)}</span></div>
                        <div class="line"><span class="code" title="${escapeHtml(it.code)}">${escapeHtml(it.code)}</span></div>
                        <div class="line href" title="${escapeHtml(it.href)}">${escapeHtml(shortHref)}</div>
                        <div class="ops"><button class="btn btnTiny" type="button" data-action="panOpen" data-pan-href="${escapeHtml(
                        it.href
                    )}">æ‰“å¼€</button><button class="btn btnTiny" type="button" data-action="panCopyLink" data-pan-href="${escapeHtml(
                        it.href
                    )}">å¤åˆ¶é“¾æ¥</button><button class="btn btnTiny" type="button" data-action="panCopyCode" data-code="${escapeHtml(
                        it.code
                    )}">å¤åˆ¶ç </button>${op}${del}</div>
                    </div>`;
                };

                const buildPanRowHtml = (mode, showFav) => (it) => {
                    if (!it) return '';
                    const dt = formatDateTimeForDisplay(new Date(it.t));
                    const shortHref = shorten(it.href, 60);
                    const fav = Boolean(it.fav);
                    const op =
                        mode === 'favorites'
                            ? `<button class="btn btnTiny" type="button" data-action="panFavRemove" data-key="${escapeHtml(
                                    it.key
                                )}">å–æ¶ˆæ”¶è—</button>`
                            : (showFav
                                ? `<button class="btn btnTiny" type="button" data-action="panFavToggle" data-key="${escapeHtml(
                                        it.key
                                    )}" data-pan-href="${escapeHtml(it.href)}" data-code="${escapeHtml(it.code)}" data-provider="${escapeHtml(
                                        it.provider
                                    )}" data-time="${escapeHtml(String(it.t))}">${fav ? 'å–æ¶ˆæ”¶è—' : 'æ”¶è—'}</button>`
                                : '');
                    return `<tr><td title="${escapeHtml(dt)}">${escapeHtml(dt)}</td><td title="${escapeHtml(
                        it.provider
                    )}"><span class="panProviderBadge" data-key="${escapeHtml(it.providerKey || '')}">${escapeHtml(
                        it.provider
                    )}</span></td><td title="${escapeHtml(it.code)}">${escapeHtml(it.code)}</td><td title="${escapeHtml(it.href)}">${escapeHtml(
                        shortHref
                    )}</td><td style="white-space:nowrap;"><button class="btn btnTiny" type="button" data-action="panOpen" data-pan-href="${escapeHtml(
                        it.href
                    )}">æ‰“å¼€</button><button class="btn btnTiny" type="button" data-action="panCopyLink" data-pan-href="${escapeHtml(
                        it.href
                    )}">å¤åˆ¶é“¾æ¥</button><button class="btn btnTiny" type="button" data-action="panCopyCode" data-code="${escapeHtml(
                        it.code
                    )}">å¤åˆ¶ç </button>${op}${mode === 'history' ? `<button class="btn btnTiny" type="button" data-action="panHistoryRemove" data-key="${escapeHtml(
                        it.key
                    )}">åˆ é™¤</button>` : ''}</td></tr>`;
                };

                let panHistoryTableVt = null;
                let panFavoritesTableVt = null;
                let panHistoryCardsVt = null;
                let panFavoritesCardsVt = null;
                const ensurePanHistoryTableVt = () => {
                    if (panHistoryTableVt) return panHistoryTableVt;
                    if (!panHistoryBody) return null;
                    panHistoryTableVt = createVirtualTableView(
                        panHistoryBody,
                        ['æ—¶é—´', 'ç½‘ç›˜', 'æå–ç ', 'é“¾æ¥', 'æ“ä½œ'],
                        buildPanRowHtml('history', Boolean(current.panCodeFavoritesEnabled)),
                        { rowHeight: 34, overscan: 10 }
                    );
                    addVirtualStop(() => panHistoryTableVt && panHistoryTableVt.destroy());
                    return panHistoryTableVt;
                };
                const ensurePanFavoritesTableVt = () => {
                    if (panFavoritesTableVt) return panFavoritesTableVt;
                    if (!panFavoritesBody) return null;
                    panFavoritesTableVt = createVirtualTableView(
                        panFavoritesBody,
                        ['æ—¶é—´', 'ç½‘ç›˜', 'æå–ç ', 'é“¾æ¥', 'æ“ä½œ'],
                        buildPanRowHtml('favorites', false),
                        { rowHeight: 34, overscan: 10 }
                    );
                    addVirtualStop(() => panFavoritesTableVt && panFavoritesTableVt.destroy());
                    return panFavoritesTableVt;
                };
                const ensurePanHistoryCardsVt = () => {
                    if (panHistoryCardsVt) return panHistoryCardsVt;
                    if (!panHistoryBody) return null;
                    panHistoryBody.innerHTML = `<div class="panCards" data-role="panHistoryCards"></div>`;
                    const cardsEl = panHistoryBody.querySelector('[data-role="panHistoryCards"]');
                    if (!cardsEl) return null;
                    panHistoryCardsVt = createVirtualListView(cardsEl, buildPanCardHtml('history', Boolean(current.panCodeFavoritesEnabled)), {
                        itemHeight: 118,
                        overscan: 10,
                    });
                    addVirtualStop(() => panHistoryCardsVt && panHistoryCardsVt.destroy());
                    return panHistoryCardsVt;
                };
                const ensurePanFavoritesCardsVt = () => {
                    if (panFavoritesCardsVt) return panFavoritesCardsVt;
                    if (!panFavoritesBody) return null;
                    panFavoritesBody.innerHTML = `<div class="panCards" data-role="panFavoritesCards"></div>`;
                    const cardsEl = panFavoritesBody.querySelector('[data-role="panFavoritesCards"]');
                    if (!cardsEl) return null;
                    panFavoritesCardsVt = createVirtualListView(cardsEl, buildPanCardHtml('favorites', false), { itemHeight: 112, overscan: 10 });
                    addVirtualStop(() => panFavoritesCardsVt && panFavoritesCardsVt.destroy());
                    return panFavoritesCardsVt;
                };
                const resetPanHistoryVt = (keep) => {
                    if (keep !== 'table' && panHistoryTableVt) {
                        try { panHistoryTableVt.destroy(); } catch (e) {}
                        panHistoryTableVt = null;
                    }
                    if (keep !== 'cards' && panHistoryCardsVt) {
                        try { panHistoryCardsVt.destroy(); } catch (e) {}
                        panHistoryCardsVt = null;
                    }
                };
                const resetPanFavoritesVt = (keep) => {
                    if (keep !== 'table' && panFavoritesTableVt) {
                        try { panFavoritesTableVt.destroy(); } catch (e) {}
                        panFavoritesTableVt = null;
                    }
                    if (keep !== 'cards' && panFavoritesCardsVt) {
                        try { panFavoritesCardsVt.destroy(); } catch (e) {}
                        panFavoritesCardsVt = null;
                    }
                };

                let panHistorySearch = '';
                let panFavoritesSearch = '';
                if (panHistorySearchEl) {
                    panHistorySearch = panHistorySearchEl.value || '';
                    panelAddListener(panHistorySearchEl, 'input', () => {
                        panHistorySearch = panHistorySearchEl.value || '';
                        refreshPanCodeViews();
                    }, { passive: true });
                }
                if (panFavoritesSearchEl) {
                    panFavoritesSearch = panFavoritesSearchEl.value || '';
                    panelAddListener(panFavoritesSearchEl, 'input', () => {
                        panFavoritesSearch = panFavoritesSearchEl.value || '';
                        refreshPanCodeViews();
                    }, { passive: true });
                }
                const refreshPanCodeViews = () => {
                    let favSet = new Set();
                    try {
                        favSet = readPanFavoritesKeySet();
                    } catch (e) {
                        favSet = new Set();
                    }
                    if (panHistoryBody) {
                        try {
                            const t0 = nowPerfMs();
                            const limit = Math.max(50, Math.min(1000, Number(current.panCodeHistoryLimit) || 100));
                            const raw = readPanCodeHistory(current);
                            const rawItems = raw && Array.isArray(raw.items) ? raw.items : [];
                            const items = buildPanCodeItems(rawItems, favSet, panHistorySearch, limit);
                            try {
                                if (panHistoryCountEl) {
                                    const total = rawItems.length;
                                    const shown = items.length;
                                    panHistoryCountEl.textContent = total ? `${shown}/${total}` : '0';
                                }
                            } catch (e) {}
                            let style = 'comfortable';
                            try { style = normalizeLayoutStyle((contentEl && contentEl.getAttribute('data-style')) || 'comfortable'); } catch (e) {}
                            if (style === 'compact') {
                                resetPanHistoryVt('table');
                                const vt = ensurePanHistoryTableVt();
                                if (vt) vt.setItems(items, false);
                                else panHistoryBody.innerHTML = renderPanCodeTable(rawItems.slice(Math.max(0, rawItems.length - limit)), favSet, panHistorySearch, 'history');
                            } else {
                                resetPanHistoryVt('cards');
                                const vt = ensurePanHistoryCardsVt();
                                if (vt) vt.setItems(items, false);
                                else panHistoryBody.innerHTML = `<div class="panCards">${items.map(buildPanCardHtml('history', Boolean(current.panCodeFavoritesEnabled))).join('')}</div>`;
                            }
                            const ms = Math.round(nowPerfMs() - t0);
                            debugLog('settingsRender', { section: 'panHistory', ms }, 'DEBUG');
                            recordPerf('renderMs', ms, { section: 'panHistory' });
                        } catch (e) {
                            panHistoryBody.innerHTML = `<div class="configAuditEmpty">åŠ è½½å¤±è´¥ï¼š${esc(e && e.message ? e.message : String(e))}</div>`;
                        }
                    }
                    if (panFavoritesBody) {
                        try {
                            const t0 = nowPerfMs();
                            const raw = readPanCodeFavorites();
                            const rawItems = raw && Array.isArray(raw.items) ? raw.items : [];
                            const items = buildPanCodeItems(rawItems, favSet, panFavoritesSearch, 1000);
                            try {
                                if (panFavoritesCountEl) {
                                    const total = rawItems.length;
                                    const shown = items.length;
                                    panFavoritesCountEl.textContent = total ? `${shown}/${total}` : '0';
                                }
                            } catch (e) {}
                            let style = 'comfortable';
                            try { style = normalizeLayoutStyle((contentEl && contentEl.getAttribute('data-style')) || 'comfortable'); } catch (e) {}
                            if (style === 'compact') {
                                resetPanFavoritesVt('table');
                                const vt = ensurePanFavoritesTableVt();
                                if (vt) vt.setItems(items, false);
                                else panFavoritesBody.innerHTML = renderPanCodeTable(rawItems.slice(Math.max(0, rawItems.length - 1000)), favSet, panFavoritesSearch, 'favorites');
                            } else {
                                resetPanFavoritesVt('cards');
                                const vt = ensurePanFavoritesCardsVt();
                                if (vt) vt.setItems(items, false);
                                else panFavoritesBody.innerHTML = `<div class="panCards">${items.map(buildPanCardHtml('favorites', false)).join('')}</div>`;
                            }
                            const ms = Math.round(nowPerfMs() - t0);
                            debugLog('settingsRender', { section: 'panFavorites', ms }, 'DEBUG');
                            recordPerf('renderMs', ms, { section: 'panFavorites' });
                        } catch (e) {
                            panFavoritesBody.innerHTML = `<div class="configAuditEmpty">åŠ è½½å¤±è´¥ï¼š${esc(e && e.message ? e.message : String(e))}</div>`;
                        }
                    }
                    try {
                        SettingsPanelCache.panHistoryHtml = '';
                        SettingsPanelCache.panFavoritesHtml = '';
                    } catch (e) {}
                };
                const refreshPanCodeViewsKeepScroll = () => {
                    let contentTop = 0;
                    let histTop = 0;
                    let favTop = 0;
                    let histWrap = null;
                    let favWrap = null;
                    try { contentTop = contentEl ? Number(contentEl.scrollTop) || 0 : 0; } catch (e) { contentTop = 0; }
                    try { histWrap = panHistoryBody ? panHistoryBody.closest('.configAuditWrapper') : null; } catch (e) { histWrap = null; }
                    try { favWrap = panFavoritesBody ? panFavoritesBody.closest('.configAuditWrapper') : null; } catch (e) { favWrap = null; }
                    try { histTop = histWrap ? Number(histWrap.scrollTop) || 0 : 0; } catch (e) { histTop = 0; }
                    try { favTop = favWrap ? Number(favWrap.scrollTop) || 0 : 0; } catch (e) { favTop = 0; }
                    refreshPanCodeViews();
                    try {
                        const raf = (fn) => {
                            try {
                                if (panelLifecycle && typeof panelLifecycle.rafTracked === 'function') return panelLifecycle.rafTracked(fn);
                            } catch (e) {}
                            try { return setTimeoutManaged(fn, 0); } catch (e2) { return 0; }
                        };
                        raf(() => {
                            try { if (contentEl) contentEl.scrollTop = contentTop; } catch (e) {}
                            try { if (histWrap) histWrap.scrollTop = histTop; } catch (e) {}
                            try { if (favWrap) favWrap.scrollTop = favTop; } catch (e) {}
                            raf(() => {
                                try { if (contentEl) contentEl.scrollTop = contentTop; } catch (e) {}
                                try { if (histWrap) histWrap.scrollTop = histTop; } catch (e) {}
                                try { if (favWrap) favWrap.scrollTop = favTop; } catch (e) {}
                            });
                        });
                    } catch (e) {
                        try { if (contentEl) contentEl.scrollTop = contentTop; } catch (e2) {}
                        try { if (histWrap) histWrap.scrollTop = histTop; } catch (e2) {}
                        try { if (favWrap) favWrap.scrollTop = favTop; } catch (e2) {}
                    }
                };
                const panHistoryDetails = root.querySelector('details[data-submenu="panHistory"]');
                const panFavoritesDetails = root.querySelector('details[data-submenu="panFavorites"]');
                const schedulePanPopulate = () => scheduleManaged('settingsPanPopulate', () => {
                    if ((panHistoryDetails && panHistoryDetails.open) || (panFavoritesDetails && panFavoritesDetails.open)) refreshPanCodeViews();
                }, 800, true, 50);
                const schedulePanAutoRefresh = () => setTimeoutManagedByLabel('settingsPanAutoRefresh', () => {
                    try {
                        if (!host || !host.isConnected) return;
                    } catch (e) {
                        return;
                    }
                    try {
                        if ((panHistoryDetails && panHistoryDetails.open) || (panFavoritesDetails && panFavoritesDetails.open)) {
                            refreshPanCodeViewsKeepScroll();
                        }
                    } catch (e) {}
                    schedulePanAutoRefresh();
                }, 5000);
                schedulePanAutoRefresh();
                if (panHistoryDetails) {
                    panelAddListener(panHistoryDetails, 'toggle', () => {
                        if (panHistoryDetails.open) schedulePanPopulate();
                    }, { passive: true });
                }
                if (panFavoritesDetails) {
                    panelAddListener(panFavoritesDetails, 'toggle', () => {
                        if (panFavoritesDetails.open) schedulePanPopulate();
                    }, { passive: true });
                }

                const visitedStatsBody = root.querySelector('.visitedStatsBody');
                const visitedStatsSearchEl = root.querySelector('input[data-role="visitedStatsSearch"]');
                const visitedStatsSummaryEl = root.querySelector('[data-role="visitedStatsSummary"]');
                let visitedTableVt = null;
                let visitedCardsVt = null;
                const ensureVisitedTableVt = () => {
                    if (visitedTableVt) return visitedTableVt;
                    if (!visitedStatsBody) return null;
                    visitedTableVt = createVirtualTableView(
                        visitedStatsBody,
                        ['æ—¶é—´', 'ç«™ç‚¹', 'é“¾æ¥', 'æ¬¡æ•°', 'æ“ä½œ'],
                        (it) => {
                            if (!it) return '';
                            const dt = formatDateTimeForDisplay(new Date(it.t));
                            const shortUrl = shorten(it.url, 70);
                            const countText = it.count == null ? '-' : String(it.count);
                            return `<tr><td title="${escapeHtml(dt)}">${escapeHtml(dt)}</td><td title="${escapeHtml(
                                it.site || '-'
                            )}"><span class="visitedSiteCell"><span class="visitedMark"></span><span>${escapeHtml(
                                it.site || '-'
                            )}</span></span></td><td title="${escapeHtml(it.url)}">${escapeHtml(
                                shortUrl
                            )}</td><td>${escapeHtml(countText)}</td><td style="white-space:nowrap;"><button class="btn btnTiny" type="button" data-action="visitedOpen" data-url="${escapeHtml(
                                it.url
                            )}">æ‰“å¼€</button><button class="btn btnTiny" type="button" data-action="visitedCopy" data-url="${escapeHtml(
                                it.url
                            )}">å¤åˆ¶</button><button class="btn btnTiny" type="button" data-action="visitedRemove" data-key="${escapeHtml(
                                it.key
                            )}">åˆ é™¤</button></td></tr>`;
                        },
                        { rowHeight: 34, overscan: 10 }
                    );
                    addVirtualStop(() => visitedTableVt && visitedTableVt.destroy());
                    return visitedTableVt;
                };
                const ensureVisitedCardsVt = () => {
                    if (visitedCardsVt) return visitedCardsVt;
                    if (!visitedStatsBody) return null;
                    visitedStatsBody.innerHTML = `<div class="visitedCards" data-role="visitedCards"></div>`;
                    const cardsEl = visitedStatsBody.querySelector('[data-role="visitedCards"]');
                    if (!cardsEl) return null;
                    visitedCardsVt = createVirtualListView(
                        cardsEl,
                        (it) => {
                            if (!it) return '';
                            const dt = formatDateTimeForDisplay(new Date(it.t));
                            const shortUrl = shorten(it.url, 96);
                            const countText = it.count == null ? '' : ` Â· ${it.count} æ¬¡`;
                            return `<div class="card" style="grid-column:1/-1;">
                        <div class="meta"><span class="visitedMark"></span><span class="time" title="${escapeHtml(dt)}">${escapeHtml(dt)}</span><span class="site" title="${escapeHtml(
                                it.site || '-'
                            )}">${escapeHtml(it.site || '-')}${escapeHtml(countText)}</span></div>
                        <div class="url" title="${escapeHtml(it.url)}">${escapeHtml(shortUrl)}</div>
                        <div class="ops"><button class="btn btnTiny" type="button" data-action="visitedOpen" data-url="${escapeHtml(
                                it.url
                            )}">æ‰“å¼€</button><button class="btn btnTiny" type="button" data-action="visitedCopy" data-url="${escapeHtml(
                                it.url
                            )}">å¤åˆ¶</button><button class="btn btnTiny" type="button" data-action="visitedRemove" data-key="${escapeHtml(
                                it.key
                            )}">åˆ é™¤</button></div>
                    </div>`;
                        },
                        { itemHeight: 92, overscan: 10 }
                    );
                    addVirtualStop(() => visitedCardsVt && visitedCardsVt.destroy());
                    return visitedCardsVt;
                };
                const resetVisitedVt = (keep) => {
                    if (keep !== 'table' && visitedTableVt) {
                        try { visitedTableVt.destroy(); } catch (e) {}
                        visitedTableVt = null;
                    }
                    if (keep !== 'cards' && visitedCardsVt) {
                        try { visitedCardsVt.destroy(); } catch (e) {}
                        visitedCardsVt = null;
                    }
                };

                const buildVisitedItems = (searchRaw, limitRaw) => {
                    const search = String(searchRaw || '').trim().toLowerCase();
                    const limit = typeof limitRaw === 'number' && limitRaw > 0 ? Math.floor(limitRaw) : 3000;
                    const entries = getVisitedEntriesSorted();
                    const out = [];
                    for (let i = 0; i < entries.length && out.length < limit; i++) {
                        const k = String(entries[i][0] || '');
                        const t = Number(entries[i][1] || 0);
                        if (!k || !t) continue;
                        let site = '';
                        let url = k;
                        const sep = k.indexOf('|');
                        if (sep > 0 && k.slice(0, sep).indexOf('://') === -1) {
                            site = k.slice(0, sep);
                            url = k.slice(sep + 1);
                        }
                        if (search) {
                            const hay = `${site} ${url}`.toLowerCase();
                            if (hay.indexOf(search) === -1) continue;
                        }
                        const count = getGreasyForkScriptVisitCountByUrl(url);
                        out.push({ key: k, site, url, t, count });
                    }
                    return out;
                };
                let visitedStatsSearch = '';
                if (visitedStatsSearchEl) {
                    visitedStatsSearch = visitedStatsSearchEl.value || '';
                    panelAddListener(visitedStatsSearchEl, 'input', () => {
                        visitedStatsSearch = visitedStatsSearchEl.value || '';
                        refreshVisitedStatsView();
                    }, { passive: true });
                }
            const refreshVisitedStatsView = () => {
                if (!visitedStatsBody) return;
                try { 
                    const t0 = nowPerfMs();
                    try {
                        if (visitedStatsSummaryEl) {
                            const s = getGreasyForkVisitSummary();
                            if (s && s.totalVisits) {
                                const dt = s.last ? formatDateTimeForDisplay(new Date(s.last)) : '';
                                visitedStatsSummaryEl.textContent = `GreasyForkï¼šå·²è®¿é—®è„šæœ¬ ${s.totalScripts} ä¸ªï¼Œæ€»è®¿é—®æ¬¡æ•° ${s.totalVisits}${dt ? `ï¼Œæœ€è¿‘ ${dt}` : ''}`;
                            } else {
                                visitedStatsSummaryEl.textContent = '';
                            }
                        }
                    } catch (e) {}
                    let style = 'comfortable';
                    try { style = normalizeLayoutStyle((contentEl && contentEl.getAttribute('data-style')) || 'comfortable'); } catch (e) {}
                    const items = buildVisitedItems(visitedStatsSearch, 3000);
                    if (style === 'compact') {
                        resetVisitedVt('table');
                        const vt = ensureVisitedTableVt();
                        if (vt) vt.setItems(items, true);
                        else visitedStatsBody.innerHTML = renderVisitedStatsTable(visitedStatsSearch);
                    } else {
                        resetVisitedVt('cards');
                        const vt = ensureVisitedCardsVt();
                        if (vt) vt.setItems(items, true);
                        else visitedStatsBody.innerHTML = renderVisitedStatsCards(visitedStatsSearch);
                    }
                    const ms = Math.round(nowPerfMs() - t0);
                    debugLog('settingsRender', { section: 'visitedStats', ms }, 'DEBUG');
                    recordPerf('renderMs', ms, { section: 'visitedStats' });
                }
                catch (e) { visitedStatsBody.innerHTML = `<div class="configAuditEmpty">åŠ è½½å¤±è´¥ï¼š${esc(e && e.message ? e.message : String(e))}</div>`; }
                try { SettingsPanelCache.visitedStatsHtml = ''; } catch (e) {}
            };
                const visitedStatsDetails = root.querySelector('details[data-submenu="visitedStats"]');
                const scheduleVisitedPopulate = () => scheduleManaged('settingsVisitedPopulate', () => {
                    if (visitedStatsDetails && visitedStatsDetails.open) refreshVisitedStatsView();
                }, 800, true, 50);
                if (visitedStatsDetails) {
                    panelAddListener(visitedStatsDetails, 'toggle', () => {
                        if (visitedStatsDetails.open) scheduleVisitedPopulate();
                    }, { passive: true });
                }

                const schedulePopulateOnVisible = (el, fn, label) => {
                    if (!el || typeof IntersectionObserver !== 'function') {
                        scheduleManaged(label || 'settingsPopulate', fn, 800, true, 50);
                        return;
                    }
                    try {
                        const io = trackObserver(new IntersectionObserver((entries) => {
                            for (let i = 0; i < entries.length; i++) {
                                const it = entries[i];
                                if (it && it.isIntersecting && it.intersectionRatio > 0) {
                                    scheduleManaged(label || 'settingsPopulate', fn, 800, true, 50);
                                    try { io.disconnect(); } catch (e2) {}
                                    break;
                                }
                            }
                        }, { root: contentEl, threshold: [0, 0.2, 0.5, 1] }));
                        io.observe(el);
                    } catch (e) {
                        scheduleManaged(label || 'settingsPopulate', fn, 800, true, 50);
                    }
                };
                if (configAuditBody && SettingsPanelCache.configAuditHtml) {
                    configAuditBody.innerHTML = SettingsPanelCache.configAuditHtml;
                }
                if (panHistoryBody && SettingsPanelCache.panHistoryHtml) {
                    panHistoryBody.innerHTML = SettingsPanelCache.panHistoryHtml;
                }
                if (panFavoritesBody && SettingsPanelCache.panFavoritesHtml) {
                    panFavoritesBody.innerHTML = SettingsPanelCache.panFavoritesHtml;
                }
                if (visitedStatsBody && SettingsPanelCache.visitedStatsHtml) {
                    visitedStatsBody.innerHTML = SettingsPanelCache.visitedStatsHtml;
                }

                if (configAuditBody && !SettingsPanelCache.configAuditHtml) schedulePopulateOnVisible(configAuditBody, refreshConfigAuditView, 'settingsAuditPopulate');
                if ((panHistoryBody || panFavoritesBody) && !(SettingsPanelCache.panHistoryHtml || SettingsPanelCache.panFavoritesHtml)) {
                    schedulePopulateOnVisible(panHistoryBody || panFavoritesBody, refreshPanCodeViews, 'settingsPanPopulate');
                }
                if (visitedStatsBody && !SettingsPanelCache.visitedStatsHtml) schedulePopulateOnVisible(visitedStatsBody, refreshVisitedStatsView, 'settingsVisitedPopulate');

                const buildExportPayload = () => {
                    const data = {};
                    const dataZh = {};
                    const keys = Object.keys(defaults);
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const value = getValue(key, defaults[key]);
                        data[key] = value;
                        const row = findSettingRow(key);
                        const name = row && row.label ? row.label : key;
                        const desc = row && row.desc ? row.desc : '';
                        let display = value;
                        if (typeof defaults[key] === 'boolean') {
                            display = value ? 'å¼€å¯' : 'å…³é—­';
                        } else if (key === 'uiTheme') {
                            display = formatThemeLabel(value);
                        } else if (key === 'debugLogLevel') {
                            display = formatDebugLevelLabel(value);
                        }
                        dataZh[key] = {
                            åç§°: name,
                            æè¿°: desc,
                            å½“å‰å€¼: String(display),
                        };
                    }
                    const now = new Date();
                    const exportedAt = formatDateTimeForDisplay(now);
                    return {
                        meta: {
                            label: SCRIPT_LABEL,
                            version: SCRIPT_VERSION,
                            configVersion: CONFIG_VERSION,
                            exportedAt,
                        },
                    meta_zh: {
                        è¯´æ˜: 'æ–°æ ‡ç­¾é¡µProÂ·å¤šåŠŸèƒ½å¢å¼ºå·¥å…· çš„é…ç½®å¤‡ä»½æ–‡ä»¶ï¼Œå¯åœ¨è®¾ç½®é¢æ¿ä¸­é€šè¿‡â€œå¯¼å…¥é…ç½®â€æ¢å¤ã€‚',
                        å¯¼å‡ºæ—¶é—´: exportedAt,
                        è„šæœ¬ç‰ˆæœ¬: SCRIPT_VERSION,
                        é…ç½®ç»“æ„ç‰ˆæœ¬: CONFIG_VERSION,
                        æœ¬åœ°åŒ–: 'zh-CN',
                    },
                    settings: data,
                    settings_zh: dataZh,
                    };
                };

                const toastRoot = (() => {
                    const el = document.createElement('div');
                    el.className = 'toastRoot';
                    root.appendChild(el);
                    return el;
                })();

                const showToast = (message, type) => {
                    if (!toastRoot) return;
                    const el = document.createElement('div');
                    const t = String(type || 'info').toLowerCase();
                    let cls = 'toast toast-info';
                    if (t === 'error') cls = 'toast toast-error';
                    else if (t === 'warn' || t === 'warning') cls = 'toast toast-warn';
                    el.className = cls;
                    el.textContent = String(message || '');
                    toastRoot.appendChild(el);
                    try {
                        panelLifecycle.rafTracked(() => {
                            el.setAttribute('data-visible', '1');
                        });
                    } catch (e) {
                        try {
                            setTimeoutManaged(() => {
                                el.setAttribute('data-visible', '1');
                            }, 0);
                        } catch (e2) {}
                    }
                    const base = t === 'error' ? 20000 : (t === 'warn' || t === 'warning' ? 7000 : 4000);
                    const hide = () => {
                        el.removeAttribute('data-visible');
                        setTimeoutManaged(() => {
                            if (el.parentNode) el.parentNode.removeChild(el);
                        }, 220);
                    };
                    setTimeoutManaged(hide, base);
                };

                const exportSettingsToFile = () => {
                    try {
                        const payload = buildExportPayload();
                        const json = JSON.stringify(payload, null, 2);
                        const blob = new Blob([json], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = getExportFileName();
                        (document.body || document.documentElement || document).appendChild(a);
                        a.click();
                        setTimeoutManaged(() => {
                            try {
                                a.remove();
                                URL.revokeObjectURL(url);
                            } catch (e) {}
                        }, 0);
                        appendConfigAudit('exportFile', 'å¯¼å‡ºé…ç½®ä¸º JSON æ–‡ä»¶');
                        refreshConfigAuditView();
                        showToast('å·²å¯¼å‡ºå½“å‰é…ç½®ä¸º JSON æ–‡ä»¶ã€‚', 'info');
                    } catch (e) {
                        showToast('å¯¼å‡ºè®¾ç½®å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                    }
                };

                const buildConfigAuditExportPayload = () => {
                    const committed = readConfigAuditLog();
                    const logs = Array.isArray(committed) ? committed : [];
                    const now = new Date();
                    const exportedAt = formatDateTimeForDisplay(now);
                    const logsZh = [];
                    for (let i = 0; i < logs.length; i++) {
                        const item = logs[i] || {};
                        const info = getConfigAuditActionInfo(item.action);
                        logsZh.push({
                            æ—¶é—´: String(item.time || ''),
                            æ“ä½œ: info.label || String(info.code || ''),
                            æ“ä½œç±»å‹: info.type || 'other',
                            åŸŸå: String(item.host || ''),
                            è¯¦æƒ…: String(item.detail || ''),
                            è„šæœ¬ç‰ˆæœ¬: String(item.version || ''),
                        });
                    }
                    return {
                        meta: {
                            label: SCRIPT_LABEL,
                            version: SCRIPT_VERSION,
                            configVersion: CONFIG_VERSION,
                            exportedAt,
                            type: 'configAuditLog',
                        },
                        meta_zh: {
                            è¯´æ˜: 'æ–°æ ‡ç­¾é¡µProÂ·å¤šåŠŸèƒ½å¢å¼ºå·¥å…· çš„é…ç½®æ“ä½œæ—¥å¿—å¤‡ä»½ï¼Œå¯ç”¨äºæ’æŸ¥å†å²è®¾ç½®å˜æ›´ã€‚',
                            å¯¼å‡ºæ—¶é—´: exportedAt,
                            è„šæœ¬ç‰ˆæœ¬: SCRIPT_VERSION,
                            é…ç½®ç»“æ„ç‰ˆæœ¬: CONFIG_VERSION,
                            æ—¥å¿—ç±»å‹: 'é…ç½®æ“ä½œæ—¥å¿—',
                            æœ¬åœ°åŒ–: 'zh-CN',
                        },
                        logs,
                        logs_zh: logsZh,
                    };
                };

                const exportConfigAuditToFile = () => {
                    try {
                        const payload = buildConfigAuditExportPayload();
                        const json = JSON.stringify(payload, null, 2);
                        const blob = new Blob([json], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = getConfigAuditExportFileName();
                        (document.body || document.documentElement || document).appendChild(a);
                        a.click();
                        setTimeoutManaged(() => {
                            try {
                                a.remove();
                                URL.revokeObjectURL(url);
                            } catch (e) {}
                        }, 0);
                        appendConfigAudit('exportConfigLogFile', 'å¯¼å‡ºé…ç½®æ“ä½œæ—¥å¿—ä¸º JSON æ–‡ä»¶');
                        refreshConfigAuditView();
                        showToast('å·²å¯¼å‡ºé…ç½®æ“ä½œæ—¥å¿—ä¸º JSON æ–‡ä»¶ã€‚', 'info');
                    } catch (e) {
                        showToast('å¯¼å‡ºé…ç½®æ“ä½œæ—¥å¿—å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                    }
                };

                const copyConfigAuditToClipboard = async () => {
                    try {
                        const payload = buildConfigAuditExportPayload();
                        const json = JSON.stringify(payload, null, 2);
                        const ok = await copyTextToClipboard(json);
                        if (ok) {
                            appendConfigAudit('exportConfigLogClipboard', 'å¤åˆ¶é…ç½®æ“ä½œæ—¥å¿—ä¸º JSON æ–‡æœ¬');
                            refreshConfigAuditView();
                            showToast('å·²å¤åˆ¶é…ç½®æ“ä½œæ—¥å¿—åˆ°å‰ªè´´æ¿ã€‚', 'info');
                        } else {
                            showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ã€‚', 'error');
                        }
                    } catch (e) {
                        showToast('å¤åˆ¶é…ç½®æ“ä½œæ—¥å¿—å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                    }
                };

                const validateImportedMeta = (meta) => {
                    if (!meta || typeof meta !== 'object') return { ok: true, reason: '' };
                    const label = meta.label;
                    if (label && String(label) !== SCRIPT_LABEL) return { ok: false, reason: 'é…ç½®æ–‡ä»¶æ¥æºä¸å½“å‰è„šæœ¬ä¸åŒ¹é…ã€‚' };
                    const ver = meta.version;
                    const parse = (v) => String(v).split('.').map((x) => parseInt(x, 10) || 0);
                    if (ver) {
                        const [ma, mi, pa] = parse(ver);
                        const [ca, ci, cp] = parse(SCRIPT_VERSION);
                        if (ma > ca) return { ok: false, reason: `é…ç½®æ–‡ä»¶ç‰ˆæœ¬ä¸º ${ver}ï¼Œé«˜äºå½“å‰è„šæœ¬ç‰ˆæœ¬ ${SCRIPT_VERSION}ã€‚` };
                    }
                    const importedConfigVersion = meta.configVersion;
                    if (importedConfigVersion != null) {
                        const iv = parseInt(importedConfigVersion, 10) || 0;
                        if (iv > CONFIG_VERSION) return { ok: false, reason: `é…ç½®ç»“æ„ç‰ˆæœ¬ä¸º ${importedConfigVersion}ï¼Œé«˜äºå½“å‰æ”¯æŒçš„ç‰ˆæœ¬ ${CONFIG_VERSION}ã€‚` };
                    }
                    return { ok: true, reason: '' };
                };

                const normalizeSettingsObject = (source, defaults, base) => {
                    const result = {};
                    const keys = Object.keys(defaults);
                    const src = source && typeof source === 'object' ? source : {};
                    const baseObj = base && typeof base === 'object' ? base : null;
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        let value;
                        if (Object.prototype.hasOwnProperty.call(src, key)) value = src[key];
                        else if (baseObj && Object.prototype.hasOwnProperty.call(baseObj, key)) value = baseObj[key];
                        else value = defaults[key];
                        result[key] = normalizeSettingValue(key, value, defaults[key]);
                    }
                    return result;
                };

                const applyImportedSettings = (obj, mode) => {
                    if (!obj || typeof obj !== 'object') {
                        showToast('å¯¼å…¥å¤±è´¥ï¼šJSON é¡¶å±‚å¿…é¡»æ˜¯å¯¹è±¡ã€‚', 'error');
                        return;
                    }
                    const meta = obj && obj.meta && typeof obj.meta === 'object' ? obj.meta : null;
                    const check = validateImportedMeta(meta);
                    if (!check.ok) {
                        showToast(check.reason + ' å·²ç»§ç»­å¯¼å…¥ï¼Œè¯·ç•™æ„é…ç½®å…¼å®¹æ€§ã€‚', 'warn');
                    }
                    const src = obj && obj.settings && typeof obj.settings === 'object' ? obj.settings : obj;
                    const keys = Object.keys(defaults);
                    const srcKeys = src && typeof src === 'object' ? Object.keys(src) : [];
                    if (srcKeys.length) {
                        const known = {};
                        for (let i = 0; i < keys.length; i++) {
                            known[keys[i]] = true;
                        }
                        const extras = [];
                        for (let i = 0; i < srcKeys.length; i++) {
                            const k = srcKeys[i];
                            if (!Object.prototype.hasOwnProperty.call(known, k)) extras.push(k);
                        }
                        if (extras.length) {
                            const preview = extras.slice(0, 5).join('ï¼Œ');
                            const suffix = extras.length > 5 ? ` ç­‰${extras.length}é¡¹` : '';
                            showToast(`æ£€æµ‹åˆ°æœªçŸ¥é…ç½®å­—æ®µï¼š${preview}${suffix}ï¼Œå·²å¿½ç•¥ã€‚`, 'warn');
                        }
                    }
                    let base = null;
                    if (mode !== 'overwrite') {
                        base = {};
                        for (let i = 0; i < keys.length; i++) {
                            const key = keys[i];
                            base[key] = getValue(key, defaults[key]);
                        }
                    }
                    const next = normalizeSettingsObject(src, defaults, base);
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        setValue(key, next[key]);
                        settings[key] = next[key];
                    }
                    location.reload();
                };

                const importSettingsFromFile = () => {
                    if (!fileInput || !fileInput.files || !fileInput.files[0]) {
                        showToast('è¯·å…ˆé€‰æ‹©è¦å¯¼å…¥çš„ JSON æ–‡ä»¶ã€‚', 'error');
                        return;
                    }
                    const file = fileInput.files[0];
                    const maxSize = 512 * 1024;
                    if (file.size && file.size > maxSize) {
                        showToast('å¯¼å…¥å¤±è´¥ï¼šJSON æ–‡ä»¶ä½“ç§¯è¿‡å¤§ï¼ˆè¶…è¿‡ 512KBï¼‰ã€‚', 'error');
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = () => {
                        try {
                            const text = String(reader.result || '').trim();
                            if (!text) {
                                showToast('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶å†…å®¹ä¸ºç©ºã€‚', 'error');
                                return;
                            }
                            let obj;
                            try {
                                obj = JSON.parse(text);
                            } catch (e) {
                                showToast('å¯¼å…¥å¤±è´¥ï¼šJSON è§£æé”™è¯¯ã€‚', 'error');
                                return;
                            }
                            const mode = importModeEl && importModeEl.value === 'overwrite' ? 'overwrite' : 'merge';
                            const detail = mode === 'overwrite' ? 'ä» JSON æ–‡ä»¶å¯¼å…¥é…ç½®ï¼ˆè¦†ç›–æ¨¡å¼ï¼‰' : 'ä» JSON æ–‡ä»¶å¯¼å…¥é…ç½®ï¼ˆåˆå¹¶æ¨¡å¼ï¼‰';
                            appendConfigAudit('importFile', detail);
                            refreshConfigAuditView();
                            showToast(detail + 'ã€‚', 'info');
                            applyImportedSettings(obj, mode);
                        } catch (e) {
                            showToast('å¯¼å…¥å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                        }
                    };
                    reader.onerror = () => {
                        showToast('å¯¼å…¥å¤±è´¥ï¼šæ— æ³•è¯»å–æ–‡ä»¶ã€‚', 'error');
                    };
                    reader.readAsText(file, 'utf-8');
                };

                const copySettingsToClipboard = async () => {
                    try {
                        const payload = buildExportPayload();
                        const json = JSON.stringify(payload, null, 2);
                        const ok = await copyTextToClipboard(json);
                        if (ok) {
                            appendConfigAudit('exportClipboard', 'å¤åˆ¶é…ç½®ä¸º JSON æ–‡æœ¬');
                            refreshConfigAuditView();
                            showToast('å·²å¤åˆ¶å½“å‰é…ç½®åˆ°å‰ªè´´æ¿ã€‚', 'info');
                        } else {
                            showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ã€‚', 'error');
                        }
                    } catch (e) {
                        showToast('å¤åˆ¶å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                    }
                };

                const importSettingsFromClipboard = async () => {
                    let text = '';
                    try {
                        if (navigator.clipboard && typeof navigator.clipboard.readText === 'function') {
                            text = await navigator.clipboard.readText();
                        } else {
                            text = window.prompt('è¯·ç²˜è´´é…ç½® JSONï¼š') || '';
                        }
                    } catch (e) {
                        text = window.prompt('æ— æ³•ç›´æ¥è¯»å–å‰ªè´´æ¿ï¼Œè¯·æ‰‹åŠ¨ç²˜è´´é…ç½® JSONï¼š') || '';
                    }
                    text = String(text || '').trim();
                    const maxLen = 512 * 1024;
                    if (text.length > maxLen) {
                        showToast('å¯¼å…¥å¤±è´¥ï¼šå‰ªè´´æ¿ JSON æ–‡æœ¬é•¿åº¦è¿‡å¤§ï¼ˆè¶…è¿‡ 512KBï¼‰ã€‚', 'error');
                        return;
                    }
                    if (!text) {
                        showToast('å¯¼å…¥å¤±è´¥ï¼šæœªè·å–åˆ°ä»»ä½•æ–‡æœ¬ã€‚', 'error');
                        return;
                    }
                    let obj;
                    try {
                        obj = JSON.parse(text);
                    } catch (e) {
                        showToast('å¯¼å…¥å¤±è´¥ï¼šJSON è§£æé”™è¯¯ï¼Œè¯·æ£€æŸ¥å†…å®¹æ˜¯å¦ä¸ºå®Œæ•´çš„é…ç½® JSONã€‚', 'error');
                        return;
                    }
                    const mode = importModeEl && importModeEl.value === 'overwrite' ? 'overwrite' : 'merge';
                    const detail = mode === 'overwrite' ? 'ä»å‰ªè´´æ¿å¯¼å…¥é…ç½®ï¼ˆè¦†ç›–æ¨¡å¼ï¼‰' : 'ä»å‰ªè´´æ¿å¯¼å…¥é…ç½®ï¼ˆåˆå¹¶æ¨¡å¼ï¼‰';
                    appendConfigAudit('importClipboard', detail);
                    refreshConfigAuditView();
                    showToast(detail + 'ã€‚', 'info');
                    applyImportedSettings(obj, mode);
                };

                const addCurrentDomain = () => {
                    if (!excludeEl) return;
                    const check = validateDomainToken(hostname);
                    if (!check.ok) {
                        showToast('æ·»åŠ å¤±è´¥ï¼š' + check.reason, 'error');
                        return;
                    }
                    const value = check.value;
                    const list = parseDomainList(excludeEl.value);
                    if (list.includes(value)) {
                        showToast('å½“å‰åŸŸåå·²åœ¨é»‘åå•ä¸­ï¼š' + value, 'info');
                        return;
                    }
                    list.push(value);
                    excludeEl.value = toTextareaValue(list);
                    appendDraftConfigAudit('excludeAdd', 'åŠ å…¥é»‘åå•ï¼š' + value);
                    refreshConfigAuditView();
                    showToast('å·²å°†å½“å‰åŸŸååŠ å…¥é»‘åå•ï¼š' + value, 'info');
                };

                const removeCurrentDomain = () => {
                    if (!excludeEl) return;
                    const list = parseDomainList(excludeEl.value);
                    const next = list.filter((d) => d !== hostname);
                    if (next.length === list.length) {
                        showToast('å½“å‰åŸŸåä¸åœ¨é»‘åå•ä¸­ï¼Œæ— éœ€ç§»é™¤ã€‚', 'info');
                        return;
                    }
                    excludeEl.value = toTextareaValue(next);
                    appendDraftConfigAudit('excludeRemove', 'ç§»å‡ºé»‘åå•ï¼š' + hostname);
                    refreshConfigAuditView();
                    showToast('å·²ä»é»‘åå•ç§»é™¤å½“å‰åŸŸåã€‚', 'info');
                };

                const clearExcludeDomains = () => {
                    if (!excludeEl) return;
                    if (!excludeEl.value.trim()) return;
                    excludeEl.value = '';
                    appendDraftConfigAudit('excludeClear', 'æ¸…ç©ºé»‘åå•');
                    refreshConfigAuditView();
                    showToast('å·²æ¸…ç©ºé»‘åå•ã€‚', 'warn');
                };

                const addCurrentTextInclude = () => {
                    if (!textLinkIncludeEl) return;
                    const check = validateDomainToken(hostname);
                    if (!check.ok) {
                        showToast('æ·»åŠ å¤±è´¥ï¼š' + check.reason, 'error');
                        return;
                    }
                    const value = check.value;
                    const list = parseDomainList(textLinkIncludeEl.value);
                    if (list.includes(value)) {
                        showToast('å½“å‰åŸŸåå·²åœ¨æ–‡æœ¬é“¾æ¥ç™½åå•ä¸­ï¼š' + value, 'info');
                        return;
                    }
                    list.push(value);
                    textLinkIncludeEl.value = toTextareaValue(list);
                    appendDraftConfigAudit('textIncludeAdd', 'åŠ å…¥æ–‡æœ¬é“¾æ¥ç™½åå•ï¼š' + value);
                    refreshConfigAuditView();
                    showToast('å·²å°†å½“å‰åŸŸååŠ å…¥æ–‡æœ¬é“¾æ¥ç™½åå•ï¼š' + value, 'info');
                };

                const addCurrentTextExclude = () => {
                    if (!textLinkExcludeEl) return;
                    const check = validateDomainToken(hostname);
                    if (!check.ok) {
                        showToast('æ·»åŠ å¤±è´¥ï¼š' + check.reason, 'error');
                        return;
                    }
                    const value = check.value;
                    const list = parseDomainList(textLinkExcludeEl.value);
                    if (list.includes(value)) {
                        showToast('å½“å‰åŸŸåå·²åœ¨æ–‡æœ¬é“¾æ¥é»‘åå•ä¸­ï¼š' + value, 'info');
                        return;
                    }
                    list.push(value);
                    textLinkExcludeEl.value = toTextareaValue(list);
                    appendDraftConfigAudit('textExcludeAdd', 'åŠ å…¥æ–‡æœ¬é“¾æ¥é»‘åå•ï¼š' + value);
                    refreshConfigAuditView();
                    showToast('å·²å°†å½“å‰åŸŸååŠ å…¥æ–‡æœ¬é“¾æ¥é»‘åå•ï¼š' + value, 'info');
                };

                const persistToStorage = () => {
                    for (const key of Object.keys(defaults)) {
                        const def = defaults[key];
                        if (typeof def === 'boolean') {
                            const v = getChecked(key);
                            setValue(key, v);
                            settings[key] = v;
                        }
                        const row = findSettingRow(key);
                        if (row && row.type === 'select') {
                            const raw = getSelect(key);
                            const v = raw !== '' ? raw : def;
                            const normalized = normalizeSettingValue(key, v, def);
                            setValue(key, normalized);
                            settings[key] = normalized;
                        }
                    }
                    if (excludeEl) {
                        hostListSyncTextarea(excludeEl);
                        const v = hostListParse(excludeEl.value).join(',');
                        setValue('excludeDomains', v);
                        settings.excludeDomains = v;
                    }
                    if (textLinkIncludeEl) {
                        hostListSyncTextarea(textLinkIncludeEl);
                        const v = hostListParse(textLinkIncludeEl.value).join(',');
                        setValue('textLinkifyIncludeHosts', v);
                        settings.textLinkifyIncludeHosts = v;
                    }
                    if (textLinkExcludeEl) {
                        hostListSyncTextarea(textLinkExcludeEl);
                        const v = hostListParse(textLinkExcludeEl.value).join(',');
                        setValue('textLinkifyExcludeHosts', v);
                        settings.textLinkifyExcludeHosts = v;
                    }
                };

                const save = () => {
                    const before = current;
                    let persistOk = false;
                    try {
                        persistToStorage();
                        persistOk = true;
                    } catch (e) {
                        showToast('ä¿å­˜è®¾ç½®å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                    }
                    if (persistOk) {
                        let diffDetail = '';
                        let draftCount = 0;
                        try {
                            diffDetail = recordSettingsDiffAudit(before, settings) || '';
                        } catch (e) {
                            showToast('è®°å½•é…ç½®å˜æ›´æ—¥å¿—å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                        }
                        try {
                            draftCount = flushDraftConfigAudit() || 0;
                        } catch (e) {
                            showToast('æäº¤è‰ç¨¿é…ç½®æ—¥å¿—å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                        }
                        try {
                            const parts = [];
                            const d = String(diffDetail || '').trim();
                            if (d) parts.push(d);
                            if (draftCount > 0) parts.push(`å·²æäº¤è‰ç¨¿ï¼š${draftCount}æ¡`);
                            appendConfigAudit('saveReload', parts.length ? parts.join('ï¼›') : 'æ— å˜æ›´');
                            refreshConfigAuditView();
                        } catch (e) {
                            showToast('è®°å½•åˆ·æ–°æ“ä½œæ—¥å¿—å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                        }
                    }
                    location.reload();
                };

                const reset = () => {
                    try {
                        resetValues(defaults);
                    } catch (e) {}
                    try {
                        appendConfigAudit('resetReload', 'æ¢å¤é»˜è®¤è®¾ç½®å¹¶åˆ·æ–°é¡µé¢');
                        refreshConfigAuditView();
                    } catch (e) {
                        showToast('è®°å½•æ¢å¤é»˜è®¤è®¾ç½®æ—¥å¿—å¤±è´¥ï¼š' + (e && e.message ? e.message : e), 'error');
                    }
                    location.reload();
                };

                const onKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        try {
                            if (panel && panel.getAttribute && panel.getAttribute('data-sidebar-open') === '1') return setSidebarOpen(false);
                        } catch (e2) {}
                        if (appearanceMenu && appearanceMenu.getAttribute('data-open') === '1') return setAppearanceMenuOpen(false);
                        close();
                    }
                };

                panelLifecycle.on(document, 'keydown', onKeyDown, { capture: true });

                panelLifecycle.on(root, 'change', (e) => {
                    const t = e && e.target;
                    if (!(t instanceof HTMLInputElement)) return;
                    if (t.type !== 'checkbox') return;
                    const key = t.getAttribute('data-field');
                    if (!key) return;
                    const row = findSettingRow(key);
                    if (!row) return;
                    if (!row.iconOn && !row.iconOff) return;
                    const icon = t.checked ? (row.iconOn || row.icon || '') : (row.iconOff || row.icon || '');
                    const rowEl = t.closest && t.closest('.row');
                    if (rowEl && rowEl.setAttribute) {
                        if (t.checked) rowEl.setAttribute('data-checked', '1');
                        else rowEl.removeAttribute('data-checked');
                    }
                    const iconEl = rowEl && rowEl.querySelector ? rowEl.querySelector('.icon') : null;
                    if (iconEl) iconEl.textContent = String(icon);
                }, { capture: false });

                let currentLayoutStyle = normalizeLayoutStyle(String(contentEl && contentEl.getAttribute ? contentEl.getAttribute('data-style') : '') || 'comfortable');
                const applyLayoutStyleDeferred = (v) => {
                    if (!contentEl) return;
                    const next = normalizeLayoutStyle(v);
                    if (next === currentLayoutStyle) return;
                    currentLayoutStyle = next;
                    try {
                        panelLifecycle.rafTracked(() => {
                            const __t0 = nowPerfMs();
                            try { contentEl.setAttribute('data-switching', '1'); } catch (e) {}
                            try { contentEl.style.visibility = 'hidden'; } catch (e) {}
                            contentEl.setAttribute('data-style', next);
                            try { panelLifecycle.rafTracked(() => { try { contentEl.style.visibility = ''; } catch (e) {} }); } catch (e) { try { contentEl.style.visibility = ''; } catch (e2) {} }
                            setTimeoutManaged(() => { try { contentEl.setAttribute('data-switching', '0'); } catch (e) {} }, 300);
                            try { recordPerf('styleMs', Math.round(nowPerfMs() - __t0), { style: next }); } catch (e) {}
                        });
                    } catch (e) {
                        try { contentEl.setAttribute('data-style', next); } catch (e2) {}
                    }
                };
                let pendingLayoutMode = '';
                let pendingLayoutStyle = '';
                const scheduleLayoutApply = () => {
                    if (layoutApplyRaf) return;
                    try {
                        layoutApplyRaf = panelLifecycle.rafTracked(() => {
                            layoutApplyRaf = 0;
                            const m = pendingLayoutMode;
                            const s = pendingLayoutStyle;
                            pendingLayoutMode = '';
                            pendingLayoutStyle = '';
                            if (m) reorderSectionsInDom(m);
                            if (s) applyLayoutStyleDeferred(s);
                        });
                    } catch (e) {
                        layoutApplyRaf = 0;
                        const m = pendingLayoutMode;
                        const s = pendingLayoutStyle;
                        pendingLayoutMode = '';
                        pendingLayoutStyle = '';
                        if (m) reorderSectionsInDom(m);
                        if (s) applyLayoutStyleDeferred(s);
                    }
                };
                panelLifecycle.on(root, 'change', (e) => {
                    const t = e && e.target;
                    if (!(t instanceof HTMLSelectElement)) return;
                    const key = t.getAttribute('data-field');
                    if (!key) return;
                    if (!contentEl) return;
                    if (key === 'settingsLayoutMode') {
                        pendingLayoutMode = t.value;
                        scheduleLayoutApply();
                        return;
                    }
                    if (key === 'settingsLayoutStyle') {
                        pendingLayoutStyle = t.value;
                        scheduleLayoutApply();
                    }
                }, { capture: false });
                panelLifecycle.on(root, 'focusin', (e) => {
                    const t = e && e.target;
                    if (!(t instanceof Element)) return;
                    const sec = t.closest && t.closest('.section');
                    if (sec) sec.setAttribute('data-active', '1');
                }, { capture: false });
                panelLifecycle.on(root, 'focusout', (e) => {
                    const t = e && e.target;
                    if (!(t instanceof Element)) return;
                    const sec = t.closest && t.closest('.section');
                    if (sec) sec.removeAttribute('data-active');
                }, { capture: false });
                panelLifecycle.on(root, 'click', (e) => {
                    try {
                        if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
                    } catch (e2) {}
                    const t = e.target;
                    if (!(t instanceof Element)) return;
                    if (appearanceMenu && appearanceMenu.getAttribute('data-open') === '1') {
                        const inside = t.closest && t.closest('[data-role="appearanceMenuWrap"]');
                        if (!inside) setAppearanceMenuOpen(false);
                    }
                    const row = t.closest && t.closest('.row');
                    if (row && (!t.closest || !t.closest('[data-action]'))) {
                        const input = row.querySelector && row.querySelector('input[type="checkbox"][data-field]');
                        if (input instanceof HTMLInputElement) {
                            if (t === input || (t.closest && t.closest('label.toggle'))) {
                            } else {
                                input.checked = !input.checked;
                                try {
                                    input.dispatchEvent(new Event('change', { bubbles: true }));
                                } catch (e3) {
                                    try {
                                        const ev = document.createEvent('Event');
                                        ev.initEvent('change', true, false);
                                        input.dispatchEvent(ev);
                                    } catch (e4) {}
                                }
                                return;
                            }
                        }
                    }
                    const actionEl = t.closest && t.closest('[data-action]');
                    const action = actionEl && actionEl.getAttribute ? actionEl.getAttribute('data-action') : null;
                    if (!action) return;
                    if (action === 'close' || action === 'cancel') return close();
                    if (action === 'save') return save();
                    if (action === 'reset') return reset();
                    if (action === 'toggleSidebar') return toggleSidebar();
                    if (action === 'toggleAppearanceMenu') return toggleAppearanceMenu();
                    if (action === 'addCurrent') return addCurrentDomain();
                    if (action === 'removeCurrent') return removeCurrentDomain();
                    if (action === 'clearExclude') return clearExcludeDomains();
                    if (action === 'addCurrentTextInclude') return addCurrentTextInclude();
                    if (action === 'addCurrentTextExclude') return addCurrentTextExclude();
                    if (action === 'exportSettings') return exportSettingsToFile();
                    if (action === 'importSettings') return importSettingsFromFile();
                    if (action === 'copySettings') return copySettingsToClipboard();
                    if (action === 'pasteSettings') return importSettingsFromClipboard();
                    if (action === 'exportConfigAuditLog') return exportConfigAuditToFile();
                    if (action === 'copyConfigAuditLog') return copyConfigAuditToClipboard();
                    if (action === 'checkUpdate') return openUpdatePage();
                    if (action === 'nav') {
                        if (typeof e.detail === 'number' && e.detail > 1) return;
                        const now = Date.now();
                        const delta = now - (lastNavClickAt || 0);
                        lastNavClickAt = now;
                        if (delta < 90) lastNavScrollAt = now;
                        const key = actionEl.getAttribute('data-key') || '';
                        const submenu = actionEl.getAttribute('data-submenu') || '';
                        if (!key || !contentEl) return;
                        navBatchKey = key;
                        navBatchSubmenu = submenu;
                        if (navBatchRaf) return;
                        try {
                            navBatchRaf = panelLifecycle.rafTracked(() => {
                                navBatchRaf = 0;
                                const k = navBatchKey;
                                const s = navBatchSubmenu;
                                navBatchKey = '';
                                navBatchSubmenu = '';
                                if (!k || !contentEl) return;
                                scrollContentToTarget(k, s);
                            });
                        } catch (e3) {
                            navBatchRaf = 0;
                            scrollContentToTarget(key, submenu);
                        }
                        try {
                            if (isNarrowUi()) setSidebarOpen(false);
                        } catch (e2) {}
                        return;
                    }
                    if (action === 'panHistoryClear') {
                        const ok = confirm('ç¡®å®šè¦æ¸…ç©ºç½‘ç›˜å†å²è®°å½•å—ï¼Ÿ');
                        if (!ok) return;
                        try {
                            writePanCodeHistory({ v: 1, t: Date.now(), items: [] });
                        } catch (e2) {}
                        refreshPanCodeViewsKeepScroll();
                        showToast('å·²æ¸…ç©ºç½‘ç›˜å†å²è®°å½•ã€‚', 'info');
                        return;
                    }
                    if (action === 'panFavoritesClear') {
                        const ok = confirm('ç¡®å®šè¦æ¸…ç©ºæ”¶è—å—ï¼Ÿ');
                        if (!ok) return;
                        try {
                            writePanCodeFavorites({ v: 1, t: Date.now(), items: [] });
                        } catch (e2) {}
                        refreshPanCodeViewsKeepScroll();
                        showToast('å·²æ¸…ç©ºæ”¶è—ã€‚', 'info');
                        return;
                    }
                    if (action === 'panFavRemove') {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (e2) {}
                        const key = actionEl.getAttribute('data-key') || '';
                        if (removePanCodeFavoriteByKey(key)) {
                            refreshPanCodeViewsKeepScroll();
                            showToast('å·²å–æ¶ˆæ”¶è—ã€‚', 'info');
                        }
                        return;
                    }
                    if (action === 'panFavToggle') {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (e2) {}
                        const key = actionEl.getAttribute('data-key') || '';
                        const href = actionEl.getAttribute('data-pan-href') || actionEl.getAttribute('data-href') || '';
                        const code = actionEl.getAttribute('data-code') || '';
                        const provider = actionEl.getAttribute('data-provider') || '';
                        const time = Number(actionEl.getAttribute('data-time') || 0) || Date.now();
                        const exists = (() => {
                            const fav = readPanCodeFavorites();
                            const items = fav.items || [];
                            for (let i = 0; i < items.length; i++) {
                                const it = normalizePanCodeEntryFromArray(items[i]);
                                if (!it) continue;
                                if (it[0] === key) return true;
                            }
                            return false;
                        })();
                        if (exists) {
                            removePanCodeFavoriteByKey(key);
                            refreshPanCodeViewsKeepScroll();
                            showToast('å·²å–æ¶ˆæ”¶è—ã€‚', 'info');
                        } else {
                            upsertPanCodeFavorite([key, href, code, provider, time]);
                            refreshPanCodeViewsKeepScroll();
                            showToast('å·²åŠ å…¥æ”¶è—ã€‚', 'info');
                        }
                        return;
                    }
                    if (action === 'panHistoryRemove') {
                        const key = actionEl.getAttribute('data-key') || '';
                        if (!key) return;
                        const hist = readPanCodeHistory(current);
                        const list = hist.items || [];
                        let changed = false;
                        for (let i = list.length - 1; i >= 0; i--) {
                            const it = normalizePanCodeEntryFromArray(list[i]);
                            if (!it) {
                                list.splice(i, 1);
                                changed = true;
                                continue;
                            }
                            if (it[0] !== key) continue;
                            list.splice(i, 1);
                            changed = true;
                        }
                        if (changed) writePanCodeHistory(hist);
                        refreshPanCodeViews();
                        return;
                    }
                    if (action === 'panOpen') {
                        const href = actionEl.getAttribute('data-pan-href') || actionEl.getAttribute('data-href') || '';
                        if (!href) return;
                        try {
                            if (typeof GM_openInTab === 'function') {
                                GM_openInTab(href, { active: true, insert: true, setParent: true });
                                return;
                            }
                        } catch (e2) {}
                        try {
                            window.open(href, '_blank', 'noopener,noreferrer');
                        } catch (e3) {}
                        return;
                    }
                    if (action === 'panCopyLink') {
                        const href = actionEl.getAttribute('data-pan-href') || actionEl.getAttribute('data-href') || '';
                        if (!href) return;
                        const text = normalizeUrlForClipboard(href, Boolean(current && current.copyChineseUrlEnabled));
                        copyTextToClipboard(text).then((ok) => showToast(ok ? 'å·²å¤åˆ¶é“¾æ¥ã€‚' : 'å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ã€‚', ok ? 'info' : 'error'));
                        return;
                    }
                    if (action === 'panCopyCode') {
                        const c = actionEl.getAttribute('data-code') || '';
                        if (!c) return;
                        copyTextToClipboard(c).then((ok) => showToast(ok ? 'å·²å¤åˆ¶æå–ç ã€‚' : 'å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ã€‚', ok ? 'info' : 'error'));
                        return;
                    }
                    if (action === 'visitedClear') {
                        const ok = confirm('ç¡®å®šè¦æ¸…ç©ºå·²è®¿é—®é“¾æ¥è®°å½•å—ï¼Ÿ');
                        if (!ok) return;
                        try {
                            VisitedLinkState.map.clear();
                            VisitedLinkState.loaded = true;
                            if (VisitedLinkState.saveTimer) {
                                clearTimeout(VisitedLinkState.saveTimer);
                                VisitedLinkState.saveTimer = 0;
                            }
                            setValue(VISITED_HISTORY_STORAGE_KEY, { v: 1, t: Date.now(), items: [] });
                        } catch (e2) {}
                        refreshVisitedStatsView();
                        showToast('å·²æ¸…ç©ºå·²è®¿é—®è®°å½•ã€‚', 'info');
                        return;
                    }
                    if (action === 'visitedRemove') {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (e2) {}
                        const key = actionEl.getAttribute('data-key') || '';
                        if (!key) return;
                        ensureVisitedLinkStateLoaded();
                        if (VisitedLinkState.map.has(key)) {
                            VisitedLinkState.map.delete(key);
                            scheduleFlushVisitedLinkState();
                            refreshVisitedStatsView();
                        }
                        return;
                    }
                    if (action === 'visitedOpen') {
                        const url = actionEl.getAttribute('data-url') || '';
                        if (!url) return;
                        try {
                            if (typeof GM_openInTab === 'function') {
                                GM_openInTab(url, { active: true, insert: true, setParent: true });
                                return;
                            }
                        } catch (e2) {}
                        try {
                            window.open(url, '_blank', 'noopener,noreferrer');
                        } catch (e3) {}
                        return;
                    }
                    if (action === 'visitedCopy') {
                        const url = actionEl.getAttribute('data-url') || '';
                        if (!url) return;
                        const text = normalizeUrlForClipboard(url, Boolean(current && current.copyChineseUrlEnabled));
                        copyTextToClipboard(text).then((ok) => showToast(ok ? 'å·²å¤åˆ¶é“¾æ¥ã€‚' : 'å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ã€‚', ok ? 'info' : 'error'));
                        return;
                    }
                    if (action === 'visitedCopyJson') {
                        ensureVisitedLinkStateLoaded();
                        const entries = Array.from(VisitedLinkState.map.entries());
                        entries.sort((a, b) => (b[1] || 0) - (a[1] || 0));
                        const out = [];
                        for (let i = 0; i < entries.length && i < 3000; i++) {
                            out.push({ key: entries[i][0], visitedAt: entries[i][1] });
                        }
                        const payload = {
                            meta: {
                                label: SCRIPT_LABEL,
                                version: SCRIPT_VERSION,
                                configVersion: CONFIG_VERSION,
                                exportedAt: formatDateTimeForDisplay(new Date()),
                                type: 'visitedHistory',
                            },
                            items: out,
                        };
                        const json = JSON.stringify(payload, null, 2);
                        copyTextToClipboard(json).then((ok) => showToast(ok ? 'å·²å¤åˆ¶ä¸º JSONã€‚' : 'å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ã€‚', ok ? 'info' : 'error'));
                        return;
                    }
                }, { capture: false });

                if (backdrop) {
                    panelLifecycle.on(backdrop, 'click', (e) => {
                        if (e.target === backdrop) close();
                    }, { capture: false });
                }

                    if (panel && typeof panel.focus === 'function') panel.focus();
                    const __perfEnd = (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now());
                    const __perfMs = __perfEnd - __perfStart;
                    try { console.info(`[${SCRIPT_LABEL}] è®¾ç½®é¢æ¿åˆå§‹åŒ–è€—æ—¶ï¼š${Math.round(__perfMs)}ms`); } catch (e) {}
                    try {
                        debugLog(
                            'settingsPanelOpen',
                            {
                                durationMs: Math.round(__perfMs),
                                layoutStyle: String(current.settingsLayoutStyle || ''),
                                layoutMode: String(current.settingsLayoutMode || ''),
                                groupCount: Array.isArray(SETTINGS_UI_GROUPS) ? SETTINGS_UI_GROUPS.length : 0,
                            },
                            'INFO'
                        );
                    } catch (e) {}
                } catch (e) {
                    settingsPanelOpening = false;
                    try {
                        if (host) host.remove();
                    } catch (e2) {}
                }

                function readConfigAuditLog() {
                    const raw = getValue('configAuditLog', []);
                    const normalize = (input) => {
                        let v = input;
                        if (typeof v === 'string') {
                            try {
                                v = JSON.parse(v);
                            } catch (e) {
                                v = null;
                            }
                        }
                        if (v && typeof v === 'object' && !Array.isArray(v) && Array.isArray(v.logs)) v = v.logs;
                        if (!Array.isArray(v)) return { list: [], migrated: false };
                        const out = [];
                        for (let i = 0; i < v.length; i++) {
                            const item = v[i];
                            if (!item || typeof item !== 'object') continue;
                            const time = String(item.time || '');
                            const action = String(item.action || '');
                            if (!time || !action) continue;
                            out.push({
                                time,
                                action,
                                detail: item.detail == null ? '' : String(item.detail),
                                host: item.host == null ? '' : String(item.host),
                                version: item.version == null ? '' : String(item.version),
                            });
                            if (out.length >= 50) break;
                        }
                        const migrated = !Array.isArray(input) || out.length !== v.length;
                        return { list: out, migrated };
                    };
                    const norm = normalize(raw);
                    if (norm.migrated) {
                        try {
                            writeConfigAuditLog(norm.list);
                        } catch (e) {}
                    }
                    return norm.list;
                }

                function writeConfigAuditLog(list) {
                    try {
                        setValue('configAuditLog', list);
                    } catch (e) {}
                }

                function appendConfigAudit(action, detail) {
                    const list = readConfigAuditLog();
                    const nowStr = formatDateTimeForDisplay(new Date());
                    const detailText = detail || '';
                    const parseAuditTimeToMs = (s) => {
                        const m = /^(\d{4})\.(\d{2})\.(\d{2})\s-\s(\d{2}):(\d{2}):(\d{2})$/.exec(String(s || ''));
                        if (!m) return 0;
                        const y = Number(m[1]);
                        const mo = Number(m[2]);
                        const d = Number(m[3]);
                        const h = Number(m[4]);
                        const mi = Number(m[5]);
                        const se = Number(m[6]);
                        if (!y || !mo || !d) return 0;
                        return new Date(y, mo - 1, d, h, mi, se).getTime();
                    };
                    if (String(action || '') === 'saveReload' && String(detailText) === 'æ— å˜æ›´' && list.length) {
                        const last = list[0] || {};
                        if (
                            String(last.action || '') === 'saveReload' &&
                            String(last.host || '') === String(hostname || '') &&
                            String(last.detail || '') === 'æ— å˜æ›´'
                        ) {
                            const nowMs = parseAuditTimeToMs(nowStr);
                            const lastMs = parseAuditTimeToMs(last.time);
                            if (nowMs && lastMs && nowMs - lastMs < 2 * 60 * 1000) {
                                last.time = nowStr;
                                last.version = SCRIPT_VERSION;
                                writeConfigAuditLog(list);
                                return;
                            }
                        }
                    }
                    const entry = {
                        time: nowStr,
                        action,
                        detail: detailText,
                        host: hostname || '',
                        version: SCRIPT_VERSION,
                    };
                    list.unshift(entry);
                    if (list.length > 50) list.length = 50;
                    writeConfigAuditLog(list);
                }

                function appendDraftConfigAudit(action, detail) {
                    const entry = {
                        time: formatDateTimeForDisplay(new Date()),
                        action,
                        detail: detail || '',
                        host: hostname || '',
                        version: SCRIPT_VERSION,
                        draft: true,
                    };
                    draftConfigAudits.unshift(entry);
                    if (draftConfigAudits.length > 50) draftConfigAudits.length = 50;
                }

                function flushDraftConfigAudit() {
                    if (typeof draftConfigAudits === 'undefined') return;
                    if (!Array.isArray(draftConfigAudits) || !draftConfigAudits.length) return;
                    const count = draftConfigAudits.length;
                    const committed = readConfigAuditLog();
                    const merged = draftConfigAudits.concat(Array.isArray(committed) ? committed : []);
                    if (merged.length > 50) merged.length = 50;
                    writeConfigAuditLog(merged);
                    draftConfigAudits.length = 0;
                    return count;
                }

                function recordSettingsDiffAudit(beforeSettings, afterSettings) {
                    if (!beforeSettings || !afterSettings) return;
                    if (typeof beforeSettings !== 'object' || typeof afterSettings !== 'object') return;
                    const segments = [];
                    const formatBool = (v) => (v ? 'å¼€å¯' : 'å…³é—­');
                    const formatMsLabel = (v) => {
                        const s = String(v ?? '').trim();
                        if (s === '0') return 'å®æ—¶';
                        if (/^\d+$/.test(s)) return `${s}ms`;
                        return s;
                    };
                    const formatLayoutModeLabel = (v) => {
                        const s = String(v ?? '').trim();
                        if (s === 'commonFirst') return 'å¸¸ç”¨ä¼˜å…ˆ';
                        if (s === 'classic') return 'ç»å…¸å¸ƒå±€';
                        return s;
                    };
                    const findLabel = (key, fallback) => {
                        const row = findSettingRow(key);
                        if (row && row.label) return row.label;
                        return fallback || key;
                    };
                    const keys = Object.keys(defaults);
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const def = defaults[key];
                        if (typeof def === 'boolean') {
                            const beforeValue = Boolean(beforeSettings[key]);
                            const afterValue = Boolean(afterSettings[key]);
                            if (beforeValue === afterValue) continue;
                            const label = findLabel(key, key);
                            segments.push(`${label}ï¼š${formatBool(beforeValue)} â†’ ${formatBool(afterValue)}`);
                        }
                    }
                    const buildDomainListDiff = (key, label) => {
                        if (typeof parseDomainList !== 'function') return;
                        const beforeRaw = beforeSettings[key];
                        const afterRaw = afterSettings[key];
                        const beforeList = parseDomainList(beforeRaw);
                        const afterList = parseDomainList(afterRaw);
                        const added = [];
                        const removed = [];
                        for (let i = 0; i < afterList.length; i++) {
                            const v = afterList[i];
                            if (!beforeList.includes(v)) added.push(v);
                        }
                        for (let i = 0; i < beforeList.length; i++) {
                            const v = beforeList[i];
                            if (!afterList.includes(v)) removed.push(v);
                        }
                        if (!added.length && !removed.length) return;
                        const parts = [];
                        if (added.length) parts.push(`æ–°å¢ï¼š${added.join('ï¼Œ')}`);
                        if (removed.length) parts.push(`ç§»é™¤ï¼š${removed.join('ï¼Œ')}`);
                        segments.push(`${label}ï¼š${parts.join('ï¼›')}`);
                    };
                    buildDomainListDiff('excludeDomains', 'é»‘åå•åŸŸå');
                    buildDomainListDiff('textLinkifyIncludeHosts', 'æ–‡æœ¬é“¾æ¥ç™½åå•');
                    buildDomainListDiff('textLinkifyExcludeHosts', 'æ–‡æœ¬é“¾æ¥é»‘åå•');
                    const themeBefore = beforeSettings.uiTheme;
                    const themeAfter = afterSettings.uiTheme;
                    if (themeBefore !== themeAfter) {
                        const label = findLabel('uiTheme', 'è®¾ç½®é¢æ¿ä¸»é¢˜');
                        segments.push(`${label}ï¼š${formatThemeLabel(themeBefore)} â†’ ${formatThemeLabel(themeAfter)}`);
                    }
                    const layoutBefore = beforeSettings.settingsLayoutMode;
                    const layoutAfter = afterSettings.settingsLayoutMode;
                    if (layoutBefore !== layoutAfter) {
                        const label = findLabel('settingsLayoutMode', 'è®¾ç½®é¢æ¿å¸ƒå±€');
                        segments.push(`${label}ï¼š${formatLayoutModeLabel(layoutBefore)} â†’ ${formatLayoutModeLabel(layoutAfter)}`);
                    }
                    const levelBefore = beforeSettings.debugLogLevel;
                    const levelAfter = afterSettings.debugLogLevel;
                    if (levelBefore !== levelAfter) {
                        const label = findLabel('debugLogLevel', 'è°ƒè¯•æ—¥å¿—ç­‰çº§');
                        segments.push(`${label}ï¼š${formatDebugLevelLabel(levelBefore)} â†’ ${formatDebugLevelLabel(levelAfter)}`);
                    }
                    const intervalBefore = beforeSettings.autoUnfoldInterval;
                    const intervalAfter = afterSettings.autoUnfoldInterval;
                    if (intervalBefore !== intervalAfter) {
                        const label = findLabel('autoUnfoldInterval', 'è‡ªåŠ¨å±•å¼€æ‰§è¡Œé—´éš”');
                        segments.push(`${label}ï¼š${formatMsLabel(intervalBefore)} â†’ ${formatMsLabel(intervalAfter)}`);
                    }
                    const ticksBefore = beforeSettings.autoUnfoldMaxTicks;
                    const ticksAfter = afterSettings.autoUnfoldMaxTicks;
                    if (ticksBefore !== ticksAfter) {
                        const label = findLabel('autoUnfoldMaxTicks', 'è‡ªåŠ¨å±•å¼€æŒç»­æ—¶é•¿');
                        segments.push(`${label}ï¼š${String(ticksBefore ?? '')} â†’ ${String(ticksAfter ?? '')}`);
                    }
                    const syncBefore = beforeSettings.debugSyncInterval;
                    const syncAfter = afterSettings.debugSyncInterval;
                    if (syncBefore !== syncAfter) {
                        const label = findLabel('debugSyncInterval', 'æ—¥å¿—åŒæ­¥åˆ·æ–°é—´éš”');
                        segments.push(`${label}ï¼š${formatMsLabel(syncBefore)} â†’ ${formatMsLabel(syncAfter)}`);
                    }
                    if (!segments.length) return '';
                    return segments.join('ï¼›');
                }

                function getConfigAuditActionInfo(action) {
                    const code = String(action || '');
                    let type = 'other';
                    let label = code;
                    if (code === 'exportFile') {
                        type = 'importExport';
                        label = 'å¯¼å‡ºé…ç½®åˆ°æ–‡ä»¶';
                    } else if (code === 'exportClipboard') {
                        type = 'importExport';
                        label = 'å¯¼å‡ºé…ç½®åˆ°å‰ªè´´æ¿';
                    } else if (code === 'importFile') {
                        type = 'importExport';
                        label = 'ä»æ–‡ä»¶å¯¼å…¥é…ç½®';
                    } else if (code === 'importClipboard') {
                        type = 'importExport';
                        label = 'ä»å‰ªè´´æ¿å¯¼å…¥é…ç½®';
                    } else if (code === 'settingsDiff') {
                        type = 'settings';
                        label = 'ä¿å­˜é…ç½®å˜æ›´';
                    } else if (code === 'saveReload') {
                        type = 'settings';
                        label = 'ä¿å­˜å¹¶åˆ·æ–°é¡µé¢';
                    } else if (code === 'resetReload') {
                        type = 'settings';
                        label = 'æ¢å¤é»˜è®¤è®¾ç½®å¹¶åˆ·æ–°é¡µé¢';
                    } else if (code === 'exportConfigLogFile') {
                        type = 'logExport';
                        label = 'å¯¼å‡ºé…ç½®æ—¥å¿—åˆ°æ–‡ä»¶';
                    } else if (code === 'exportConfigLogClipboard') {
                        type = 'logExport';
                        label = 'å¤åˆ¶é…ç½®æ—¥å¿—åˆ°å‰ªè´´æ¿';
                    } else if (code === 'excludeAdd') {
                        type = 'listChange';
                        label = 'æ·»åŠ é»‘åå•åŸŸå';
                    } else if (code === 'excludeRemove') {
                        type = 'listChange';
                        label = 'ç§»é™¤é»‘åå•åŸŸå';
                    } else if (code === 'excludeClear') {
                        type = 'listChange';
                        label = 'æ¸…ç©ºé»‘åå•';
                    } else if (code === 'textIncludeAdd') {
                        type = 'listChange';
                        label = 'æ·»åŠ æ–‡æœ¬é“¾æ¥ç™½åå•';
                    } else if (code === 'textExcludeAdd') {
                        type = 'listChange';
                        label = 'æ·»åŠ æ–‡æœ¬é“¾æ¥é»‘åå•';
                    }
                    return { code, type, label };
                }

                function renderConfigAuditTable(committedList, drafts, filterType, searchText) {
                    const committed = Array.isArray(committedList) ? committedList : [];
                    const draftList = Array.isArray(drafts) ? drafts : [];
                    const filter = filterType || 'all';
                    const keywordRaw = searchText == null ? '' : searchText;
                    const keyword = String(keywordRaw).trim().toLowerCase();
                    if (!committed.length && !draftList.length) {
                        return '<div class="configAuditEmpty">æš‚æ— é…ç½®æ“ä½œè®°å½•ã€‚æ‰§è¡Œå¯¼å…¥/å¯¼å‡ºæˆ–é»‘åå•è°ƒæ•´åï¼Œä¼šåœ¨æ­¤æ˜¾ç¤ºæœ€è¿‘è®°å½•ã€‚</div>';
                    }
                    const rows = [];
                    for (let i = 0; i < draftList.length; i++) {
                        const item = draftList[i] || {};
                        const info = getConfigAuditActionInfo(item.action);
                        if (filter !== 'all' && info.type !== filter) continue;
                        const rawTime = String(item.time || '');
                        const rawAction = String(info.label || '');
                        const rawHost = String(item.host || '');
                        const rawDetail = String(item.detail || '');
                        if (keyword) {
                            const haystack = (rawTime + ' ' + rawAction + ' ' + rawHost + ' ' + rawDetail).toLowerCase();
                            if (haystack.indexOf(keyword) === -1) continue;
                        }
                        const time = escapeHtml(rawTime);
                        const action = escapeHtml(rawAction);
                        const host = escapeHtml(rawHost);
                        const detail = escapeHtml(rawDetail);
                        const badge = '<span class="configAuditDraftBadge">æœªä¿å­˜</span>';
                        rows.push(
                            `<tr data-draft="1"><td>${time}</td><td>${action}</td><td>${host}</td><td>${detail}${badge}</td></tr>`
                        );
                    }
                    for (let i = 0; i < committed.length; i++) {
                        const item = committed[i] || {};
                        const info = getConfigAuditActionInfo(item.action);
                        if (filter !== 'all' && info.type !== filter) continue;
                        const rawTime = String(item.time || '');
                        const rawAction = String(info.label || '');
                        const rawHost = String(item.host || '');
                        const rawDetail = String(item.detail || '');
                        if (keyword) {
                            const haystack = (rawTime + ' ' + rawAction + ' ' + rawHost + ' ' + rawDetail).toLowerCase();
                            if (haystack.indexOf(keyword) === -1) continue;
                        }
                        const time = escapeHtml(rawTime);
                        const action = escapeHtml(rawAction);
                        const host = escapeHtml(rawHost);
                        const detail = escapeHtml(rawDetail);
                        rows.push(`<tr><td>${time}</td><td>${action}</td><td>${host}</td><td>${detail}</td></tr>`);
                    }
                    if (!rows.length) {
                        return '<div class="configAuditEmpty">å½“å‰ç­›é€‰æ¡ä»¶ä¸‹æš‚æ— é…ç½®æ“ä½œè®°å½•ã€‚</div>';
                    }
                    return `<table class="configAuditTable"><thead><tr><th>æ—¶é—´</th><th>æ“ä½œ</th><th>åŸŸå</th><th>è¯¦æƒ…</th></tr></thead><tbody>${rows.join(
                        ''
                    )}</tbody></table>`;
                }

                function normalizeDomainToken(token) {
                    return String(token || '').trim().toLowerCase();
                }

                function validateDomainToken(token) {
                    const value = normalizeDomainToken(token);
                    if (!value) return { ok: false, reason: 'å½“å‰é¡µé¢æ²¡æœ‰æœ‰æ•ˆåŸŸåã€‚' };
                    if (value.length > 255) return { ok: false, reason: 'åŸŸåé•¿åº¦è¶…å‡ºé™åˆ¶ã€‚' };
                    if (/^https?:\/\//i.test(value)) return { ok: false, reason: 'è¯·ä¸è¦åŒ…å«åè®®éƒ¨åˆ†ï¼Œä»…å¡«å†™åŸŸåï¼Œå¦‚ example.comã€‚' };
                    if (/[\/\s]/.test(value)) return { ok: false, reason: 'åŸŸåä¸­ä¸èƒ½åŒ…å«ç©ºæ ¼æˆ–æ–œæ ã€‚' };
                    return { ok: true, value };
                }

                function formatThemeLabel(v) {
                    const value = String(v || '').toLowerCase();
                    if (value === 'dark') return 'æ·±è‰²';
                    if (value === 'light') return 'æµ…è‰²';
                    if (value === 'auto') return 'è·Ÿéšç³»ç»Ÿ';
                    return value;
                }

                function formatDebugLevelLabel(v) {
                    const value = String(v || '').toUpperCase();
                    if (value === 'DEBUG') return 'DEBUG - å…¨éƒ¨æ—¥å¿—';
                    if (value === 'INFO') return 'INFO - å¸¸è§„ä¿¡æ¯';
                    if (value === 'WARN') return 'WARN - è­¦å‘Šä¸é”™è¯¯';
                    if (value === 'ERROR') return 'ERROR - ä»…é”™è¯¯';
                    return value;
                }

                function renderSelectRow(key, icon, label, desc, options) {
                    const currentValue = String(current[key] ?? '');
                    const opts = (options || [])
                        .map(([value, text]) => {
                            const v = String(value);
                            const selected = v === currentValue ? 'selected' : '';
                            return `<option value="${escapeHtml(v)}" ${selected}>${escapeHtml(String(text))}</option>`;
                        })
                        .join('');
                    return `
                        <div class="row">
                            <div class="icon">${escapeHtml(String(icon))}</div>
                            <div>
                                <div class="label">${escapeHtml(String(label))}</div>
                                <div class="desc">${escapeHtml(String(desc))}</div>
                            </div>
                            <div>
                                <select data-field="${escapeHtml(String(key))}">
                                    ${opts}
                                </select>
                            </div>
                        </div>
                    `;
                }

                function renderToggleRow(key, icon, label, desc) {
                    const checked = current[key] ? 'checked' : '';
                    return `
                        <div class="row">
                            <div class="icon">${escapeHtml(String(icon))}</div>
                            <div>
                                <div class="label">${escapeHtml(String(label))}</div>
                                <div class="desc">${escapeHtml(String(desc))}</div>
                            </div>
                            <label class="toggle">
                                <input type="checkbox" data-field="${escapeHtml(String(key))}" ${checked} />
                            </label>
                        </div>
                    `;
                }

                function escapeHtml(s) {
                    return String(s)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#039;');
                }

                function cssEscape(s) {
                    if (typeof CSS !== 'undefined' && CSS.escape) return CSS.escape(String(s));
                    return String(s).replace(/[^a-zA-Z0-9_-]/g, '\\$&');
                }
            }

            function isExcludedDomain(excludeDomains) {
                const hostname = getCurrentHost();
                if (!hostname) return false;
                const normalized = normalizeHostListRaw(excludeDomains);
                if (!normalized) return false;
                return matchHostList(hostname, normalized);
            }

            const BASE_ID = 'newtab-open-links-base';
            const MANAGED_ATTR = 'data-newtab-open-links-managed';
            const ORIG_TARGET_ATTR = 'data-newtab-open-links-orig-target';
            const DEBUG_OVERLAY_ID = 'newtab-open-links-debug-overlay';
            const DEBUG_POS_KEY = 'debugOverlayPos';
            const DEBUG_OVERLAY_STYLE_ID = 'newtab-open-links-debug-overlay-style';
            const TEXT_LINKIFY_STYLE_ID = 'newtab-open-links-textlink-style';
            const TEXT_LINKIFY_TOOLTIP_ID = 'newtab-open-links-textlink-tooltip';
            const TEXT_LINKIFY_TOOLTIP_DELAY = 350;
            const DEBUG_OVERLAY_OWNER_KEY = 'debugOverlayOwner';
            const DEBUG_OVERLAY_BUS_KEY = 'debugOverlayBus';
            const DEBUG_OVERLAY_SHARED_LOG_KEY = 'debugOverlaySharedLog';
            const DEBUG_TAB_ID_KEY = 'debugTabId';

            const DebugState = {
                buffer: [],
                max: 200,
                overlayEl: null,
                logRoot: null,
                failuresRoot: null,
                metricsEl: null,
                themeStop: null,
                ownerTimer: null,
                blurTimer: null,
                pending: [],
                flushTimer: 0,
                domEntryCount: 0,
                bcBound: false,
                busStop: null,
                busOwnerListenerId: 0,
                busLogListenerId: 0,
                busPollTimer: null,
                busLastOwnerSig: '',
                busQueue: [],
                busFlushTimer: 0,
                busSeen: new Set(),
                busLastMsgId: '',
                sharedSeenIds: new Set(),
                sharedPending: [],
                sharedFlushTimer: 0,
                sharedListenerId: 0,
                sharedPollTimer: null,
                sharedLastRaw: '',
                visibilityBound: false,
                focusBound: false,
                lastEnabled: null,
                failureMap: new Map(),
                lastClickGroup: null,
                filterText: '',
                filterInput: null,
                metrics: { aFlushes: 0, aQueued: 0, tlBatches: 0, tlLinks: 0, tlLastMs: 0, cacheHits: 0, cacheMiss: 0 },
                perf: { settings: {}, samples: [], kpi: { openMs: 120, layoutMs: 80, styleMs: 60, renderMs: 120 } },
            };
            let textLinkifyTooltipEl = null;
            let textLinkifyTooltipTimer = 0;
            let textLinkifyTooltipTarget = null;

            function debugEnabled() {
                return Boolean(settings.debugOverlay);
            }

            function resolveDebugSyncIntervalMs() {
                const raw = settings.debugSyncInterval;
                const n = typeof raw === 'number' ? raw : Number(String(raw || '').trim());
                if (!Number.isFinite(n)) return 200;
                const v = Math.floor(n);
                if (v <= 0) return 0;
                return Math.max(80, Math.min(2000, v));
            }

            function resolveDebugSyncPollIntervalMs() {
                const v = resolveDebugSyncIntervalMs();
                if (v === 0) return 80;
                return v;
            }

            function normalizeSharedDebugLogList(raw) {
                const arr = Array.isArray(raw) ? raw : [];
                const out = [];
                for (let i = 0; i < arr.length; i++) {
                    const it = arr[i];
                    if (!it || typeof it !== 'object') continue;
                    const id = String(it.id || '').trim();
                    if (!id) continue;
                    const entry = {
                        id,
                        ts: String(it.ts || ''),
                        level: String(it.level || ''),
                        type: String(it.type || ''),
                        data: it.data == null ? null : it.data,
                        groupId: it.groupId == null ? null : String(it.groupId || ''),
                    };
                    out.push(entry);
                }
                if (out.length <= DebugState.max) return out;
                return out.slice(out.length - DebugState.max);
            }

            function readSharedDebugLog() {
                let v = getValue(DEBUG_OVERLAY_SHARED_LOG_KEY, []);
                if (typeof v === 'string') v = safeJsonParse(v, []);
                return normalizeSharedDebugLogList(v);
            }

            function writeSharedDebugLog(list) {
                try {
                    setValue(DEBUG_OVERLAY_SHARED_LOG_KEY, list);
                } catch (e) {}
            }

            function mergeSharedDebugLog(rawList) {
                const list = normalizeSharedDebugLogList(rawList);
                if (!list.length) return;
                const seen = DebugState.sharedSeenIds;
                for (let i = 0; i < list.length; i++) {
                    const entry = list[i];
                    const id = entry && entry.id ? String(entry.id) : '';
                    if (!id) continue;
                    if (seen.has(id)) continue;
                    seen.add(id);
                    DebugState.buffer.push(entry);
                    while (DebugState.buffer.length > DebugState.max) DebugState.buffer.shift();
                    if (DebugState.logRoot) {
                        DebugState.pending.push(entry);
                        while (DebugState.pending.length > DebugState.max) DebugState.pending.shift();
                        scheduleDebugOverlayFlush();
                    }
                }
            }

            function flushSharedDebugLogPending() {
                const pending = DebugState.sharedPending;
                if (!pending || !pending.length) return;
                const list = readSharedDebugLog();
                const seen = new Set();
                for (let i = 0; i < list.length; i++) {
                    const id = list[i] && list[i].id ? String(list[i].id) : '';
                    if (id) seen.add(id);
                }
                for (let i = 0; i < pending.length; i++) {
                    const entry = pending[i];
                    const id = entry && entry.id ? String(entry.id) : '';
                    if (!id || seen.has(id)) continue;
                    seen.add(id);
                    list.push(entry);
                }
                pending.splice(0, pending.length);
                const next = list.length <= DebugState.max ? list : list.slice(list.length - DebugState.max);
                writeSharedDebugLog(next);
            }

            function scheduleSharedDebugLogAppend(entry) {
                if (!entry || typeof entry !== 'object') return;
                const id = String(entry.id || '').trim();
                if (!id) return;
                DebugState.sharedPending.push(entry);
                while (DebugState.sharedPending.length > DebugState.max) DebugState.sharedPending.shift();
                if (DebugState.sharedFlushTimer) return;
                const ms = resolveDebugSyncIntervalMs();
                const run = () => {
                    DebugState.sharedFlushTimer = 0;
                    flushSharedDebugLogPending();
                };
                try {
                    DebugState.sharedFlushTimer = setTimeout(run, ms === 0 ? 0 : ms);
                } catch (e) {}
            }

            function getDebugLevelThreshold() {
                const raw = String(settings.debugLogLevel || '').toUpperCase();
                if (raw === 'DEBUG') return 10;
                if (raw === 'WARN') return 30;
                if (raw === 'ERROR') return 40;
                return 20;
            }

            function shouldLogLevel(level) {
                const v = String(level || '').toUpperCase();
                let n = 20;
                if (v === 'DEBUG') n = 10;
                else if (v === 'WARN') n = 30;
                else if (v === 'ERROR') n = 40;
                return n >= getDebugLevelThreshold();
            }

            function getDebugTabId() {
                try {
                    const k = `${STORAGE_PREFIX}${DEBUG_TAB_ID_KEY}`;
                    const existing = sessionStorage.getItem(k);
                    if (existing) return existing;
                    const next = `tab_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                    sessionStorage.setItem(k, next);
                    return next;
                } catch (e) {
                    return `tab_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                }
            }

            function getOverlayOwnerStorageKey() {
                return DEBUG_OVERLAY_OWNER_KEY;
            }

            function readOverlayOwner() {
                const raw = getValue(getOverlayOwnerStorageKey(), null);
                if (!raw) return null;
                if (typeof raw === 'object') return raw;
                const parsed = safeJsonParse(raw, null);
                return parsed && typeof parsed === 'object' ? parsed : null;
            }

            function writeOverlayOwner(owner) {
                try {
                    setValue(getOverlayOwnerStorageKey(), owner);
                } catch (e) {}
            }

            function isOverlayOwnerAlive(owner) {
                if (!owner || typeof owner !== 'object') return false;
                const tabId = owner.tabId;
                const ts = owner.ts;
                if (!tabId || typeof tabId !== 'string') return false;
                if (typeof ts !== 'number') return false;
                return Date.now() - ts < 6000;
            }

            function isCurrentTabOwner() {
                const owner = readOverlayOwner();
                if (!isOverlayOwnerAlive(owner)) return false;
                return owner.tabId === getDebugTabId();
            }

            function releaseOverlayOwnershipIfOwner() {
                if (!isCurrentTabOwner()) return false;
                writeOverlayOwner({ tabId: getDebugTabId(), ts: 0 });
                return true;
            }

            function isDocumentVisible() {
                const vs = document && document.visibilityState;
                if (typeof vs !== 'string') return true;
                return vs === 'visible';
            }

            function isDocumentFocused() {
                try {
                    if (document && typeof document.hasFocus === 'function') return document.hasFocus();
                } catch (e) {}
                return true;
            }

            function ensureDebugOverlayBroadcast() {
                if (DebugState.bcBound) return;
                DebugState.bcBound = true;
                const myId = getDebugTabId();
                try {
                    mergeSharedDebugLog(readSharedDebugLog());
                } catch (e) {}

                const onOwnerMaybeChanged = () => {
                    if (!debugEnabled()) return;
                    syncOverlayOwnershipAndUi();
                };
                const onBusMessage = (payload) => {
                    if (!payload || typeof payload !== 'object') return;
                    const type = String(payload.type || '');
                    if (type === 'claim') {
                        const tabId = String(payload.tabId || '');
                        if (!tabId || tabId === myId) return;
                        if (!debugEnabled()) return;
                        if (isDocumentVisible() && isDocumentFocused()) return;
                        try {
                            if (isCurrentTabOwner()) releaseOverlayOwnershipIfOwner();
                        } catch (e) {}
                        stopOverlayOwnershipLoop();
                        hideDebugOverlayUi();
                        return;
                    }
                    if (type !== 'log') return;
                    const entry = payload.entry;
                    if (!entry || typeof entry !== 'object') return;
                    const from = String(payload.from || '');
                    if (from && from === myId) return;
                    const msgId = String(payload.id || '');
                    if (msgId && msgId === DebugState.busLastMsgId) return;
                    if (msgId) DebugState.busLastMsgId = msgId;
                    try {
                        const entryId = String(entry.id || '').trim();
                        if (entryId) {
                            if (DebugState.sharedSeenIds.has(entryId)) return;
                            DebugState.sharedSeenIds.add(entryId);
                        }
                    } catch (e) {}

                    DebugState.buffer.push(entry);
                    while (DebugState.buffer.length > DebugState.max) DebugState.buffer.shift();
                    if (canRenderDebugOverlay()) {
                        DebugState.pending.push(entry);
                        while (DebugState.pending.length > DebugState.max) DebugState.pending.shift();
                        scheduleDebugOverlayFlush();
                    }
                };

                const stopExisting = () => {
                    if (!DebugState.busStop) return;
                    try {
                        DebugState.busStop();
                    } catch (e) {}
                    DebugState.busStop = null;
                };
                stopExisting();

                if (typeof GM_addValueChangeListener === 'function') {
                    try {
                        DebugState.busOwnerListenerId = GM_addValueChangeListener(getOverlayOwnerStorageKey(), () => {
                            onOwnerMaybeChanged();
                        });
                    } catch (e) {
                        DebugState.busOwnerListenerId = 0;
                    }
                    try {
                        DebugState.busLogListenerId = GM_addValueChangeListener(DEBUG_OVERLAY_BUS_KEY, (_k, _o, n) => {
                            onBusMessage(n);
                        });
                    } catch (e) {
                        DebugState.busLogListenerId = 0;
                    }
                    try {
                        DebugState.sharedListenerId = GM_addValueChangeListener(DEBUG_OVERLAY_SHARED_LOG_KEY, (_k, _o, n) => {
                            mergeSharedDebugLog(n);
                        });
                    } catch (e) {
                        DebugState.sharedListenerId = 0;
                    }
                    DebugState.busStop = () => {
                        try {
                            if (typeof GM_removeValueChangeListener === 'function') {
                                if (DebugState.busOwnerListenerId) GM_removeValueChangeListener(DebugState.busOwnerListenerId);
                                if (DebugState.busLogListenerId) GM_removeValueChangeListener(DebugState.busLogListenerId);
                                if (DebugState.sharedListenerId) GM_removeValueChangeListener(DebugState.sharedListenerId);
                            }
                        } catch (e) {}
                        DebugState.busOwnerListenerId = 0;
                        DebugState.busLogListenerId = 0;
                        DebugState.sharedListenerId = 0;
                    };
                    return;
                }

                let lastOwner = '';
                let lastBus = '';
                let lastShared = '';
                const poll = () => {
                    if (!DebugState.bcBound) return;
                    const delay = resolveDebugSyncPollIntervalMs();
                    try {
                        if (debugEnabled()) {
                            const owner = readOverlayOwner();
                            const sig = owner && typeof owner === 'object' ? `${String(owner.tabId || '')}_${String(owner.ts || '')}` : '';
                            if (sig && sig !== lastOwner) {
                                lastOwner = sig;
                                onOwnerMaybeChanged();
                            }
                        }
                    } catch (e) {}
                    try {
                        if (debugEnabled()) {
                            const v = getValue(DEBUG_OVERLAY_BUS_KEY, null);
                            const raw = v == null ? '' : typeof v === 'string' ? v : JSON.stringify(v);
                            if (raw && raw !== lastBus) {
                                lastBus = raw;
                                const parsed = typeof v === 'object' ? v : safeJsonParse(raw, null);
                                onBusMessage(parsed);
                            }
                        }
                    } catch (e) {}
                    try {
                        const v = getValue(DEBUG_OVERLAY_SHARED_LOG_KEY, null);
                        const raw = v == null ? '' : typeof v === 'string' ? v : JSON.stringify(v);
                        if (raw && raw !== lastShared) {
                            lastShared = raw;
                            const parsed = typeof v === 'object' ? v : safeJsonParse(raw, []);
                            mergeSharedDebugLog(parsed);
                        }
                    } catch (e) {}
                    try {
                        DebugState.busPollTimer = setTimeout(poll, delay);
                    } catch (e) {}
                };
                try {
                    DebugState.busPollTimer = setTimeout(poll, resolveDebugSyncPollIntervalMs());
                } catch (e) {}
                DebugState.busStop = () => {
                    try {
                        if (DebugState.busPollTimer) clearTimeout(DebugState.busPollTimer);
                    } catch (e) {}
                    DebugState.busPollTimer = null;
                };
            }

            function stopDebugOverlayBroadcast() {
                if (!DebugState.bcBound) return;
                try {
                    if (DebugState.busStop) DebugState.busStop();
                } catch (e) {}
                DebugState.busStop = null;
                DebugState.busOwnerListenerId = 0;
                DebugState.busLogListenerId = 0;
                DebugState.sharedListenerId = 0;
                DebugState.busPollTimer = null;
                DebugState.busLastOwnerSig = '';
                DebugState.busLastMsgId = '';
                DebugState.bcBound = false;
            }

            function broadcastOverlayClaim() {
                try {
                    setValue(DEBUG_OVERLAY_BUS_KEY, { type: 'claim', tabId: getDebugTabId(), ts: Date.now(), id: `claim_${Date.now()}_${Math.random().toString(16).slice(2)}` });
                } catch (e) {}
            }

            function showDebugOverlayUi() {
                if (!DebugState.overlayEl) return;
                let wasHidden = false;
                try {
                    wasHidden = DebugState.overlayEl.style.display === 'none';
                    DebugState.overlayEl.style.display = '';
                } catch (e) {}
                if (!wasHidden) return;
                try {
                    if (DebugState.themeStop) DebugState.themeStop();
                    DebugState.themeStop = applyDebugOverlayTheme(DebugState.overlayEl);
                } catch (e) {}
                try {
                    ensureFailuresRendered();
                } catch (e) {}
                if (DebugState.logRoot) {
                    try {
                        DebugState.pending.splice(0, DebugState.pending.length);
                    } catch (e) {}
                    rebuildDebugOverlayLogFromBuffer();
                }
            }

            function hideDebugOverlayUi() {
                if (!DebugState.overlayEl) return;
                try {
                    DebugState.overlayEl.style.display = 'none';
                } catch (e) {}
            }

            function canRenderDebugOverlay() {
                if (!DebugState.overlayEl || !DebugState.logRoot) return false;
                if (!debugEnabled()) return false;
                if (!isTopWindow()) return false;
                if (!isDocumentVisible()) return false;
                try {
                    return DebugState.overlayEl.style.display !== 'none';
                } catch (e) {
                    return true;
                }
            }

            function scheduleDebugOverlayFlush() {
                if (DebugState.flushTimer) return;
                const run = () => {
                    DebugState.flushTimer = 0;
                    flushDebugOverlayPending();
                };
                try {
                    if (typeof requestAnimationFrame === 'function') {
                        DebugState.flushTimer = requestAnimationFrame(run);
                        return;
                    }
                } catch (e) {}
                try {
                    DebugState.flushTimer = setTimeout(run, 16);
                } catch (e2) {}
            }

            function rebuildDebugOverlayLogFromBuffer() {
                if (!DebugState.logRoot) return;
                const saved = DebugState.filterText;
                try {
                    DebugState.filterText = '';
                } catch (e) {}
                DebugState.domEntryCount = 0;
                try {
                    DebugState.logRoot.textContent = '';
                    for (let i = 0; i < DebugState.buffer.length; i++) appendDebugEntryToOverlay(DebugState.buffer[i]);
                } catch (e) {}
                try {
                    DebugState.filterText = saved;
                } catch (e) {}
                if (saved) {
                    try {
                        applyDebugOverlayLogFilter();
                    } catch (e) {}
                }
                try {
                    DebugState.logRoot.scrollTop = DebugState.logRoot.scrollHeight;
                } catch (e) {}
            }

            function flushDebugOverlayPending() {
                if (!canRenderDebugOverlay()) return;
                const list = DebugState.pending;
                if (!list || !list.length) return;
                const maxPerFlush = 40;
                for (let i = 0; i < maxPerFlush && list.length; i++) {
                    const entry = list.shift();
                    appendDebugEntryToOverlay(entry);
                }
                if (DebugState.domEntryCount > 260) rebuildDebugOverlayLogFromBuffer();
                else if (DebugState.filterText) {
                    try {
                        applyDebugOverlayLogFilter();
                    } catch (e) {}
                }
                try {
                    DebugState.logRoot.scrollTop = DebugState.logRoot.scrollHeight;
                } catch (e) {}
                if (list.length) scheduleDebugOverlayFlush();
            }

            function bindDebugOverlayFocusEvents() {
                if (DebugState.focusBound) return;
                try {
                    const onFocus = () => {
                        if (!debugEnabled()) return;
                        if (DebugState.blurTimer) {
                            try {
                                clearTimeout(DebugState.blurTimer);
                            } catch (e) {}
                            DebugState.blurTimer = null;
                        }
                        syncOverlayOwnershipAndUi();
                    };
                    const onBlur = () => {
                        if (!debugEnabled()) return;
                        if (DebugState.blurTimer) return;
                        DebugState.blurTimer = setTimeout(() => {
                            DebugState.blurTimer = null;
                            if (!debugEnabled()) return;
                            syncOverlayOwnershipAndUi();
                        }, 180);
                    };
                    addListener(window, 'focus', onFocus, { passive: true, capture: true });
                    addListener(window, 'blur', onBlur, { passive: true, capture: true });
                    bindDebugOverlayFocusEvents._handlers = { onFocus, onBlur };
                    DebugState.focusBound = true;
                } catch (e) {}
            }

            function unbindDebugOverlayFocusEvents() {
                if (!DebugState.focusBound) return;
                try {
                    const h = bindDebugOverlayFocusEvents._handlers;
                    if (h && h.onFocus) removeListener(window, 'focus', h.onFocus, { passive: true, capture: true });
                    if (h && h.onBlur) removeListener(window, 'blur', h.onBlur, { passive: true, capture: true });
                } catch (e) {}
                bindDebugOverlayFocusEvents._handlers = null;
                DebugState.focusBound = false;
            }

            function stopOverlayOwnershipLoop() {
                if (!DebugState.ownerTimer) return;
                try {
                    clearInterval(DebugState.ownerTimer);
                } catch (e) {}
                DebugState.ownerTimer = null;
            }

            function syncOverlayOwnershipAndUi() {
                if (!debugEnabled()) return stopDebugOverlay();
                if (!isTopWindow()) return stopDebugOverlay();
                if (!isDocumentVisible()) return stopDebugOverlay();
                startDebugOverlay();
                showDebugOverlayUi();
            }

            function debugLog(type, data, level) {
                if (!debugEnabled()) return;
                const resolvedLevel = resolveDebugLevel(type, level);
                if (!shouldLogLevel(resolvedLevel)) return;
                let resolvedData = data;
                if (typeof data === 'function') {
                    try {
                        resolvedData = data();
                    } catch (e) {
                        const message = e && e.message ? String(e.message) : String(e);
                        resolvedData = { providerError: message };
                    }
                }
                const ts = formatDateTimeForDisplay(new Date());
                const entry = {
                    id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
                    ts,
                    level: resolvedLevel,
                    type: String(type || ''),
                    data: resolvedData == null ? null : resolvedData,
                    groupId: resolveDebugGroupId(type),
                };
                DebugState.buffer.push(entry);
                while (DebugState.buffer.length > DebugState.max) DebugState.buffer.shift();
                if (canRenderDebugOverlay()) {
                    DebugState.pending.push(entry);
                    while (DebugState.pending.length > DebugState.max) DebugState.pending.shift();
                    scheduleDebugOverlayFlush();
                }
                try {
                    if (entry.id) DebugState.sharedSeenIds.add(String(entry.id));
                } catch (e) {}
                scheduleSharedDebugLogAppend(entry);
                try {
                    if (resolveDebugSyncIntervalMs() === 0) {
                        setValue(DEBUG_OVERLAY_BUS_KEY, { type: 'log', from: getDebugTabId(), entry, ts: Date.now(), id: entry.id });
                    }
                } catch (e) {}
            }

            function withErrorBoundary(tag, fn) {
                if (typeof fn !== 'function') return;
                try {
                    return fn();
                } catch (e) {
                    const message = e && e.message ? String(e.message) : String(e);
                    debugLog('errorBoundary', { tag, error: message }, 'ERROR');
                }
            }

            function resolveDebugLevel(type, explicit) {
                const v = String(explicit || '').toUpperCase();
                if (v === 'DEBUG' || v === 'INFO' || v === 'WARN' || v === 'ERROR') return v;
                const t = String(type || '');
                if (t === 'openFail') return 'ERROR';
                if (t === 'duplicate') return 'WARN';
                return 'INFO';
            }

            function resolveDebugGroupId(type) {
                const t = String(type || '');
                if (t === 'click') {
                    const group = { id: `click_${Date.now()}_${Math.random().toString(16).slice(2)}`, ts: Date.now() };
                    DebugState.lastClickGroup = group;
                    return group.id;
                }
                if (!DebugState.lastClickGroup) return null;
                const now = Date.now();
                if (now - DebugState.lastClickGroup.ts > 2000) return null;
                if (t === 'keepSelf' || t === 'duplicate' || t === 'open' || t === 'openFail' || t === 'openRecovered') return DebugState.lastClickGroup.id;
                return null;
            }

            function formatDebugEntryText(entry) {
                let payload = '';
                try {
                    if (entry.data == null) payload = '';
                    else if (typeof entry.data === 'string') payload = entry.data;
                    else payload = JSON.stringify(entry.data);
                } catch (e) {
                    try {
                        payload = String(entry.data);
                    } catch (e2) {
                        payload = '';
                    }
                }
                const prefix = entry.type === 'openFail' ? 'âš ï¸è·³è½¬å¤±è´¥ ' : '';
                const head = `[${entry.ts}] ${entry.level} ${prefix}${entry.type}`;
                return payload ? `${head} ${payload}` : head;
            }

            async function copyTextToClipboard(text) {
                const t = String(text ?? '');
                let ok = false;
                try {
                    if (typeof GM_setClipboard === 'function') {
                        GM_setClipboard(t);
                        ok = true;
                    }
                } catch (e) {}
                try {
                    if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                        await navigator.clipboard.writeText(t);
                        ok = true;
                    }
                } catch (e) {}
                if (!ok) {
                    try {
                        const ta = document.createElement('textarea');
                        ta.value = t;
                        ta.style.position = 'fixed';
                        ta.style.left = '-9999px';
                        ta.style.top = '0';
                        document.body.appendChild(ta);
                        ta.focus();
                        ta.select();
                        ok = document.execCommand && document.execCommand('copy');
                        ta.remove();
                    } catch (e) {}
                }
                return ok;
            }

            const CopyCurrentUrlHotkeyState = {
                onKeyDown: null,
                parsedCustom: null,
                parsedCustomText: '',
                lastBadCustomTipAt: 0,
            };

            function getCopyCurrentUrlHotkeyDisplay(mode, customText) {
                const m = String(mode || 'off');
                if (m === 'off') return 'å…³é—­';
                if (m === 'altShiftC') return 'Alt+Shift+C';
                if (m === 'altShiftU') return 'Alt+Shift+U';
                if (m === 'ctrlAltC') return 'Ctrl+Alt+C';
                if (m === 'ctrlAltU') return 'Ctrl+Alt+U';
                if (m === 'custom') return String(customText || '').trim() || 'è‡ªå®šä¹‰';
                return 'å…³é—­';
            }

            function parseHotkeyText(text) {
                const raw = String(text || '').trim();
                if (!raw) return null;
                const parts = raw
                    .split('+')
                    .map((x) => String(x).trim())
                    .filter(Boolean);
                if (!parts.length) return null;

                let ctrl = false;
                let alt = false;
                let shift = false;
                let meta = false;
                let keyToken = '';

                for (let i = 0; i < parts.length; i++) {
                    const t = parts[i];
                    const low = t.toLowerCase();
                    if (low === 'ctrl' || low === 'control' || low === 'ctl') {
                        ctrl = true;
                        continue;
                    }
                    if (low === 'alt' || low === 'option') {
                        alt = true;
                        continue;
                    }
                    if (low === 'shift') {
                        shift = true;
                        continue;
                    }
                    if (low === 'win' || low === 'windows' || low === 'cmd' || low === 'command' || low === 'meta') {
                        meta = true;
                        continue;
                    }
                    keyToken = t;
                }

                const hasModifier = ctrl || alt || shift || meta;
                if (!hasModifier) return null;
                if (!keyToken) return null;

                const keyLower = String(keyToken).trim().toLowerCase().replace(/\s+/g, '');
                if (!keyLower) return null;

                const displayParts = [];
                if (ctrl) displayParts.push('Ctrl');
                if (alt) displayParts.push('Alt');
                if (shift) displayParts.push('Shift');
                if (meta) displayParts.push('Win');

                let keyDisplay = '';
                if (keyLower.length === 1) keyDisplay = keyLower.toUpperCase();
                else if (/^f\d{1,2}$/i.test(keyLower)) keyDisplay = keyLower.toUpperCase();
                else if (keyLower === 'esc' || keyLower === 'escape') keyDisplay = 'Escape';
                else if (keyLower === 'space' || keyLower === 'spacebar') keyDisplay = 'Space';
                else if (keyLower === 'enter' || keyLower === 'return') keyDisplay = 'Enter';
                else if (keyLower === 'tab') keyDisplay = 'Tab';
                else if (keyLower === 'backspace') keyDisplay = 'Backspace';
                else if (keyLower === 'delete' || keyLower === 'del') keyDisplay = 'Delete';
                else if (keyLower === 'insert' || keyLower === 'ins') keyDisplay = 'Insert';
                else if (keyLower === 'home') keyDisplay = 'Home';
                else if (keyLower === 'end') keyDisplay = 'End';
                else if (keyLower === 'pageup' || keyLower === 'page up') keyDisplay = 'PageUp';
                else if (keyLower === 'pagedown' || keyLower === 'page down') keyDisplay = 'PageDown';
                else if (keyLower === 'arrowup' || keyLower === 'up') keyDisplay = 'ArrowUp';
                else if (keyLower === 'arrowdown' || keyLower === 'down') keyDisplay = 'ArrowDown';
                else if (keyLower === 'arrowleft' || keyLower === 'left') keyDisplay = 'ArrowLeft';
                else if (keyLower === 'arrowright' || keyLower === 'right') keyDisplay = 'ArrowRight';
                else keyDisplay = String(keyToken).trim();

                displayParts.push(keyDisplay);
                const display = displayParts.join('+');

                const normalizedParts = [];
                if (ctrl) normalizedParts.push('ctrl');
                if (alt) normalizedParts.push('alt');
                if (shift) normalizedParts.push('shift');
                if (meta) normalizedParts.push('meta');
                normalizedParts.push(keyLower);
                const normalized = normalizedParts.join('+');

                return { ctrl, alt, shift, meta, usesMeta: meta, hasModifier, keyLower, display, normalized };
            }

            function isBrowserReservedHotkey(normalized) {
                const n = String(normalized || '').trim().toLowerCase();
                if (!n) return false;
                const reserved = new Set([
                    'ctrl+l',
                    'ctrl+t',
                    'ctrl+w',
                    'ctrl+n',
                    'ctrl+r',
                    'ctrl+shift+r',
                    'ctrl+f',
                    'ctrl+g',
                    'ctrl+h',
                    'ctrl+j',
                    'ctrl+k',
                    'ctrl+p',
                    'ctrl+s',
                    'ctrl+u',
                    'ctrl+shift+i',
                    'ctrl+shift+j',
                    'ctrl+shift+c',
                    'ctrl+shift+delete',
                    'ctrl+shift+escape',
                    'ctrl+tab',
                    'ctrl+shift+tab',
                    'ctrl+c',
                    'ctrl+v',
                    'ctrl+x',
                    'ctrl+insert',
                    'shift+insert',
                    'shift+delete',
                    'alt+left',
                    'alt+right',
                    'alt+home',
                    'alt+d',
                    'f5',
                ]);
                if (reserved.has(n)) return true;
                if (/^ctrl\+\d$/.test(n)) return true;
                return false;
            }

            function isEditableElementForHotkey(el) {
                if (!el || !(el instanceof Element)) return false;
                if (el.isContentEditable) return true;
                const tag = String(el.tagName || '').toUpperCase();
                if (tag === 'TEXTAREA') return true;
                if (tag !== 'INPUT') return false;
                const type = String(el.type || '').toLowerCase();
                if (!type) return true;
                return /^(?:text|search|url|email|tel|password)$/i.test(type);
            }

            function matchCopyCurrentUrlHotkey(e, hotkey) {
                const id = String(hotkey || '');
                const key = String(e && e.key ? e.key : '').toLowerCase();
                if (!key) return false;
                if (id === 'altShiftC') return e.altKey && e.shiftKey && !e.ctrlKey && !e.metaKey && key === 'c';
                if (id === 'altShiftU') return e.altKey && e.shiftKey && !e.ctrlKey && !e.metaKey && key === 'u';
                if (id === 'ctrlAltC') return e.ctrlKey && e.altKey && !e.shiftKey && !e.metaKey && key === 'c';
                if (id === 'ctrlAltU') return e.ctrlKey && e.altKey && !e.shiftKey && !e.metaKey && key === 'u';
                if (id === 'custom') {
                    const parsed = CopyCurrentUrlHotkeyState.parsedCustom;
                    if (!parsed) {
                        const now = Date.now();
                        if (now - CopyCurrentUrlHotkeyState.lastBadCustomTipAt > 5000) {
                            CopyCurrentUrlHotkeyState.lastBadCustomTipAt = now;
                            try {
                                if (settings && settings.passiveTipsEnabled) showPassiveTip('å¿«æ·é”®è®¾ç½®æ— æ•ˆï¼Œè¯·åœ¨æ²¹çŒ´èœå•ä¸­é‡æ–°è®¾ç½®');
                            } catch (e2) {}
                        }
                        return false;
                    }
                    if (Boolean(parsed.ctrl) !== Boolean(e.ctrlKey)) return false;
                    if (Boolean(parsed.alt) !== Boolean(e.altKey)) return false;
                    if (Boolean(parsed.shift) !== Boolean(e.shiftKey)) return false;
                    if (Boolean(parsed.meta) !== Boolean(e.metaKey)) return false;
                    return key === parsed.keyLower;
                }
                return false;
            }

            function startCopyCurrentUrlHotkey() {
                if (CopyCurrentUrlHotkeyState.onKeyDown) return;
                const onKeyDown = (e) => {
                    const hotkey = settings && settings.copyCurrentUrlHotkey ? settings.copyCurrentUrlHotkey : 'off';
                    if (!hotkey || hotkey === 'off') return;
                    if (!matchCopyCurrentUrlHotkey(e, hotkey)) return;
                    const t = e && e.target ? e.target : null;
                    if (isEditableElementForHotkey(t)) return;
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                    } catch (e2) {}
                    const text = normalizeUrlForClipboard(location.href, Boolean(settings && settings.copyChineseUrlEnabled));
                    Promise.resolve()
                        .then(() => copyTextToClipboard(text))
                        .then((ok) => {
                            try {
                                if (settings && settings.passiveTipsEnabled) {
                                    showPassiveTip(ok ? 'å·²å¤åˆ¶å½“å‰é¡µé“¾æ¥' : 'å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™');
                                }
                            } catch (e3) {}
                        });
                };
                CopyCurrentUrlHotkeyState.onKeyDown = onKeyDown;
                document.addEventListener('keydown', onKeyDown, true);
            }

            function stopCopyCurrentUrlHotkey() {
                const onKeyDown = CopyCurrentUrlHotkeyState.onKeyDown;
                if (!onKeyDown) return;
                CopyCurrentUrlHotkeyState.onKeyDown = null;
                try {
                    document.removeEventListener('keydown', onKeyDown, true);
                } catch (e) {}
            }

            function applyCopyCurrentUrlHotkey(active, currentSettings) {
                const s = currentSettings || settings;
                const hotkey = s && s.copyCurrentUrlHotkey ? String(s.copyCurrentUrlHotkey) : 'off';
                const shouldEnable = Boolean(active) && hotkey && hotkey !== 'off';
                if (hotkey === 'custom') {
                    const text = s && s.copyCurrentUrlHotkeyCustom ? String(s.copyCurrentUrlHotkeyCustom) : '';
                    const trimmed = String(text || '').trim();
                    if (trimmed && trimmed !== CopyCurrentUrlHotkeyState.parsedCustomText) {
                        CopyCurrentUrlHotkeyState.parsedCustomText = trimmed;
                        CopyCurrentUrlHotkeyState.parsedCustom = parseHotkeyText(trimmed);
                    } else if (!trimmed) {
                        CopyCurrentUrlHotkeyState.parsedCustomText = '';
                        CopyCurrentUrlHotkeyState.parsedCustom = null;
                    }
                } else {
                    CopyCurrentUrlHotkeyState.parsedCustomText = '';
                    CopyCurrentUrlHotkeyState.parsedCustom = null;
                }
                if (shouldEnable) startCopyCurrentUrlHotkey();
                else stopCopyCurrentUrlHotkey();
            }

            const PanCodeSmartSelectHotkeyState = {
                onKeyDown: null,
                parsedCustom: null,
                parsedCustomText: '',
                lastBadCustomTipAt: 0,
            };

            function getPanCodeSmartSelectHotkeyDisplay(mode, customText) {
                const m = String(mode || 'off');
                if (m === 'off') return 'å…³é—­';
                if (m === 'altShiftP') return 'Alt+Shift+P';
                if (m === 'altShiftN') return 'Alt+Shift+N';
                if (m === 'ctrlAltP') return 'Ctrl+Alt+P';
                if (m === 'ctrlAltN') return 'Ctrl+Alt+N';
                if (m === 'custom') return String(customText || '').trim() || 'è‡ªå®šä¹‰';
                return 'å…³é—­';
            }

            function matchPanCodeSmartSelectHotkey(e, hotkey) {
                const id = String(hotkey || '');
                const key = String(e && e.key ? e.key : '').toLowerCase();
                if (!key) return false;
                if (id === 'altShiftP') return e.altKey && e.shiftKey && !e.ctrlKey && !e.metaKey && key === 'p';
                if (id === 'altShiftN') return e.altKey && e.shiftKey && !e.ctrlKey && !e.metaKey && key === 'n';
                if (id === 'ctrlAltP') return e.ctrlKey && e.altKey && !e.shiftKey && !e.metaKey && key === 'p';
                if (id === 'ctrlAltN') return e.ctrlKey && e.altKey && !e.shiftKey && !e.metaKey && key === 'n';
                if (id === 'custom') {
                    const parsed = PanCodeSmartSelectHotkeyState.parsedCustom;
                    if (!parsed) {
                        const now = Date.now();
                        if (now - PanCodeSmartSelectHotkeyState.lastBadCustomTipAt > 5000) {
                            PanCodeSmartSelectHotkeyState.lastBadCustomTipAt = now;
                            try {
                                if (settings && settings.passiveTipsEnabled) showPassiveTip('ç½‘ç›˜å¿«æ·é”®è®¾ç½®æ— æ•ˆï¼Œè¯·åœ¨æ²¹çŒ´èœå•ä¸­é‡æ–°è®¾ç½®');
                            } catch (e2) {}
                        }
                        return false;
                    }
                    if (Boolean(parsed.ctrl) !== Boolean(e.ctrlKey)) return false;
                    if (Boolean(parsed.alt) !== Boolean(e.altKey)) return false;
                    if (Boolean(parsed.shift) !== Boolean(e.shiftKey)) return false;
                    if (Boolean(parsed.meta) !== Boolean(e.metaKey)) return false;
                    return key === parsed.keyLower;
                }
                return false;
            }

            function startPanCodeSmartSelectHotkey() {
                if (PanCodeSmartSelectHotkeyState.onKeyDown) return;
                const onKeyDown = (e) => {
                    if (!e || e.repeat) return;
                    const hotkey = settings && settings.panCodeSmartSelectHotkey ? settings.panCodeSmartSelectHotkey : 'off';
                    if (!hotkey || hotkey === 'off') return;
                    if (!matchPanCodeSmartSelectHotkey(e, hotkey)) return;
                    const t = e && e.target ? e.target : null;
                    if (isEditableElementForHotkey(t)) return;
                    let sel = null;
                    try {
                        sel = window.getSelection ? window.getSelection() : null;
                        if (!sel || sel.isCollapsed) return;
                    } catch (e2) {
                        return;
                    }
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                    } catch (e3) {}
                    try {
                        window.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window }));
                    } catch (e4) {
                        try {
                            document.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window }));
                        } catch (e5) {}
                    }
                };
                PanCodeSmartSelectHotkeyState.onKeyDown = onKeyDown;
                document.addEventListener('keydown', onKeyDown, true);
            }

            function stopPanCodeSmartSelectHotkey() {
                const onKeyDown = PanCodeSmartSelectHotkeyState.onKeyDown;
                if (!onKeyDown) return;
                PanCodeSmartSelectHotkeyState.onKeyDown = null;
                try {
                    document.removeEventListener('keydown', onKeyDown, true);
                } catch (e) {}
            }

            function applyPanCodeSmartSelectHotkey(active, currentSettings) {
                const s = currentSettings || settings;
                const hotkey = s && s.panCodeSmartSelectHotkey ? String(s.panCodeSmartSelectHotkey) : 'off';
                const shouldEnable = Boolean(active) && hotkey && hotkey !== 'off';
                if (hotkey === 'custom') {
                    const text = s && s.panCodeSmartSelectHotkeyCustom ? String(s.panCodeSmartSelectHotkeyCustom) : '';
                    const trimmed = String(text || '').trim();
                    if (trimmed && trimmed !== PanCodeSmartSelectHotkeyState.parsedCustomText) {
                        PanCodeSmartSelectHotkeyState.parsedCustomText = trimmed;
                        PanCodeSmartSelectHotkeyState.parsedCustom = parseHotkeyText(trimmed);
                    } else if (!trimmed) {
                        PanCodeSmartSelectHotkeyState.parsedCustomText = '';
                        PanCodeSmartSelectHotkeyState.parsedCustom = null;
                    }
                } else {
                    PanCodeSmartSelectHotkeyState.parsedCustomText = '';
                    PanCodeSmartSelectHotkeyState.parsedCustom = null;
                }
                if (shouldEnable) startPanCodeSmartSelectHotkey();
                else stopPanCodeSmartSelectHotkey();
            }

            function ensureOverlayStyle(theme) {
                const existing = document.getElementById(DEBUG_OVERLAY_STYLE_ID);
                if (existing) {
                    existing.setAttribute('data-theme', theme);
                    return;
                }
                const style = document.createElement('style');
                style.id = DEBUG_OVERLAY_STYLE_ID;
                style.type = 'text/css';
                style.setAttribute('data-theme', theme);
                style.textContent = `
                    #${DEBUG_OVERLAY_ID}[data-theme="dark"] {
                        --bg: rgba(17,18,20,.92);
                        --fg: #f3f4f6;
                        --muted: rgba(243,244,246,.72);
                        --border: rgba(255,255,255,.14);
                        --divider: rgba(255,255,255,.10);
                        --btn-bg: rgba(255,255,255,.06);
                        --btn-border: rgba(255,255,255,.18);
                        --btn-hover: rgba(255,255,255,.10);
                        --info: rgba(125,211,252,.95);
                        --warn: rgba(253,230,138,.95);
                        --error: rgba(248,113,113,.95);
                        --fail-bg: rgba(248,113,113,.14);
                        --fail-border: rgba(248,113,113,.55);
                    }
                    #${DEBUG_OVERLAY_ID}[data-theme="light"] {
                        --bg: rgba(255,255,255,.96);
                        --fg: #111827;
                        --muted: rgba(17,24,39,.72);
                        --border: rgba(17,24,39,.18);
                        --divider: rgba(17,24,39,.12);
                        --btn-bg: rgba(17,24,39,.04);
                        --btn-border: rgba(17,24,39,.18);
                        --btn-hover: rgba(17,24,39,.08);
                        --info: #0369a1;
                        --warn: #b45309;
                        --error: #b91c1c;
                        --fail-bg: rgba(185,28,28,.08);
                        --fail-border: rgba(185,28,28,.40);
                    }
                    #${DEBUG_OVERLAY_ID} {
                        background: var(--bg);
                        color: var(--fg);
                        border: 1px solid var(--border);
                        box-shadow: 0 10px 30px rgba(0,0,0,.35);
                        backdrop-filter: blur(6px);
                    }
                    #${DEBUG_OVERLAY_ID} .nto_header {
                        border-bottom: 1px solid var(--divider);
                        background: rgba(127,127,127,.06);
                    }
                    #${DEBUG_OVERLAY_ID} .nto_title {
                        font-weight: 650;
                        letter-spacing: .2px;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_search {
                        border: 1px solid var(--btn-border);
                        background: rgba(127,127,127,.04);
                        color: inherit;
                        border-radius: 8px;
                        padding: 4px 8px;
                        outline: none;
                        width: 150px;
                        font-size: 12px;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_search:focus {
                        border-color: var(--divider);
                        background: rgba(127,127,127,.06);
                    }
                    #${DEBUG_OVERLAY_ID} .nto_btn {
                        border: 1px solid var(--btn-border);
                        background: var(--btn-bg);
                        color: inherit;
                        border-radius: 8px;
                        padding: 4px 8px;
                        cursor: pointer;
                        font-size: 12px;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_btn_small {
                        padding: 3px 6px;
                        font-size: 11px;
                        border-radius: 7px;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_btn:hover { background: var(--btn-hover); }
                    #${DEBUG_OVERLAY_ID} .nto_body {
                        padding: 10px;
                        overflow: auto;
                        line-height: 1.5;
                        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                        font-size: 12px;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_entry {
                        display: grid;
                        grid-template-columns: auto auto 1fr auto;
                        gap: 8px;
                        padding: 6px 8px;
                        border-radius: 8px;
                        border: 1px solid transparent;
                        margin: 0 0 6px 0;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_entry:hover {
                        border-color: var(--divider);
                        background: rgba(127,127,127,.06);
                    }
                    #${DEBUG_OVERLAY_ID} .nto_entry .nto_btn_copy {
                        opacity: 0;
                        transition: opacity .12s ease-in-out;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_entry:hover .nto_btn_copy { opacity: 1; }
                    @media (hover: none) {
                        #${DEBUG_OVERLAY_ID} .nto_entry .nto_btn_copy { opacity: 1; }
                    }
                    #${DEBUG_OVERLAY_ID} .nto_entry:last-child { margin-bottom: 0; }
                    #${DEBUG_OVERLAY_ID} .nto_meta { color: var(--muted); }
                    #${DEBUG_OVERLAY_ID} .nto_level_INFO { color: var(--info); }
                    #${DEBUG_OVERLAY_ID} .nto_level_WARN { color: var(--warn); }
                    #${DEBUG_OVERLAY_ID} .nto_level_ERROR { color: var(--error); }
                    #${DEBUG_OVERLAY_ID} .nto_payload { word-break: break-word; white-space: pre-wrap; }
                    #${DEBUG_OVERLAY_ID} details.nto_group {
                        border: 1px solid var(--divider);
                        border-radius: 10px;
                        margin: 0 0 8px 0;
                        overflow: hidden;
                    }
                    #${DEBUG_OVERLAY_ID} details.nto_group > summary {
                        cursor: pointer;
                        list-style: none;
                        padding: 8px 10px;
                        user-select: none;
                        background: rgba(127,127,127,.06);
                        color: var(--fg);
                        display: flex;
                        gap: 10px;
                        align-items: baseline;
                    }
                    #${DEBUG_OVERLAY_ID} details.nto_group > summary::-webkit-details-marker { display: none; }
                    #${DEBUG_OVERLAY_ID} details.nto_group .nto_group_body { padding: 8px 8px 2px; }
                    #${DEBUG_OVERLAY_ID} details.nto_failbox {
                        border: 1px solid var(--fail-border);
                        background: var(--fail-bg);
                        border-radius: 10px;
                        margin: 10px 10px 0;
                        overflow: hidden;
                    }
                    #${DEBUG_OVERLAY_ID} details.nto_failbox > summary {
                        cursor: pointer;
                        list-style: none;
                        padding: 8px 10px;
                        user-select: none;
                        display: flex;
                        justify-content: space-between;
                        gap: 10px;
                        align-items: baseline;
                    }
                    #${DEBUG_OVERLAY_ID} details.nto_failbox > summary::-webkit-details-marker { display: none; }
                    #${DEBUG_OVERLAY_ID} .nto_failbody { padding: 8px; padding-top: 0; }
                    #${DEBUG_OVERLAY_ID} .nto_failitem {
                        display: grid;
                        grid-template-columns: 1fr auto auto;
                        gap: 8px;
                        padding: 6px 8px;
                        border-radius: 8px;
                        border: 1px solid var(--fail-border);
                        background: rgba(127,127,127,.06);
                        margin-top: 6px;
                    }
                    #${DEBUG_OVERLAY_ID} .nto_failitem:first-child { margin-top: 0; }
                    #${DEBUG_OVERLAY_ID} .nto_failtitle { font-weight: 650; }
                    #${DEBUG_OVERLAY_ID} .nto_failreason { color: var(--muted); margin-top: 2px; }
                `;
                try {
                    (document.head || document.documentElement || document.body).appendChild(style);
                } catch (e) {}
            }

            function applyDebugOverlayTheme(el) {
                const theme = resolveUiTheme(settings.uiTheme);
                el.setAttribute('data-theme', theme);
                ensureOverlayStyle(theme);
                let stop = null;
                if (String(settings.uiTheme || '').toLowerCase() === 'auto') {
                    try {
                        const mq = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
                        if (mq && typeof mq.addEventListener === 'function') {
                            const onChange = () => {
                                const next = resolveUiTheme('auto');
                                el.setAttribute('data-theme', next);
                                ensureOverlayStyle(next);
                            };
                            mq.addEventListener('change', onChange);
                            stop = () => mq.removeEventListener('change', onChange);
                        } else if (mq && typeof mq.addListener === 'function') {
                            const onChange = () => {
                                const next = resolveUiTheme('auto');
                                el.setAttribute('data-theme', next);
                                ensureOverlayStyle(next);
                            };
                            mq.addListener(onChange);
                            stop = () => mq.removeListener(onChange);
                        }
                    } catch (e) {}
                }
                return stop;
            }

            function ensureFailuresRendered() {
                if (!DebugState.failuresRoot) return;
                DebugState.failuresRoot.textContent = '';
                const entries = Array.from(DebugState.failureMap.values()).sort((a, b) => b.lastAt - a.lastAt);
                const box = DebugState.failuresRoot.closest ? DebugState.failuresRoot.closest('details.nto_failbox') : null;
                const summary = box && box.querySelector ? box.querySelector('summary') : null;
                if (!entries.length) {
                    if (box) box.style.display = 'none';
                    return;
                }
                if (box) box.style.display = '';
                if (summary) summary.textContent = `è·³è½¬å¤±è´¥ï¼ˆ${entries.length}ï¼‰`;
                for (let i = 0; i < entries.length; i++) {
                    const it = entries[i];
                    const row = document.createElement('div');
                    row.className = 'nto_failitem';
                    const left = document.createElement('div');
                    const t = document.createElement('div');
                    t.className = 'nto_failtitle';
                    t.textContent = `âš ï¸è·³è½¬å¤±è´¥ x${it.count}`;
                    const u = document.createElement('div');
                    u.className = 'nto_payload';
                    u.textContent = it.href;
                    const r = document.createElement('div');
                    r.className = 'nto_failreason';
                    r.textContent = it.reason;
                    left.appendChild(t);
                    left.appendChild(u);
                    left.appendChild(r);
                    const btnCopy = document.createElement('button');
                    btnCopy.className = 'nto_btn nto_btn_small';
                    btnCopy.textContent = 'å¤åˆ¶';
                    btnCopy.addEventListener('click', async () => {
                        const ok = await copyTextToClipboard(`âš ï¸è·³è½¬å¤±è´¥ ${it.href}\nåŸå› ï¼š${it.reason}`);
                        debugLog('copyOne', { ok, type: 'openFail', href: it.href }, 'DEBUG');
                    });
                    const btnClose = document.createElement('button');
                    btnClose.className = 'nto_btn nto_btn_small';
                    btnClose.textContent = 'å…³é—­';
                    btnClose.addEventListener('click', () => {
                        DebugState.failureMap.delete(it.href);
                        ensureFailuresRendered();
                    });
                    row.appendChild(left);
                    row.appendChild(btnCopy);
                    row.appendChild(btnClose);
                    DebugState.failuresRoot.appendChild(row);
                }
            }

            function markOpenFailure(href, reason) {
                const key = String(href || '');
                if (!key) return;
                const now = Date.now();
                const existing = DebugState.failureMap.get(key);
                const next = existing
                    ? { ...existing, lastAt: now, count: existing.count + 1, reason: String(reason || existing.reason || '') }
                    : { href: key, firstAt: now, lastAt: now, count: 1, reason: String(reason || '') };
                DebugState.failureMap.set(key, next);
                ensureFailuresRendered();
                debugLog('openFail', { href: key, reason: next.reason }, 'ERROR');
            }

            function resolveOpenFailureReason(opened, href) {
                const method = opened && opened.method ? String(opened.method) : 'none';
                if (method === 'GM_openInTab') return 'GM_openInTab è°ƒç”¨å¤±è´¥ï¼ˆå¯èƒ½è¢«è„šæœ¬ç®¡ç†å™¨/æƒé™é™åˆ¶ï¼‰';
                if (method === 'window.open') return 'window.open è¢«æµè§ˆå™¨æ‹¦æˆªï¼ˆå¼¹çª—æ‹¦æˆª/éç”¨æˆ·æ‰‹åŠ¿ï¼‰';
                const h = String(href || '');
                if (!h) return 'href ä¸ºç©ºæˆ–æ— æ•ˆ';
                if (typeof GM_openInTab !== 'function') return 'ç¼ºå°‘ GM_openInTab æˆæƒï¼ˆ@grant æˆ–è„šæœ¬ç®¡ç†å™¨é™åˆ¶ï¼‰';
                return 'æœªçŸ¥åŸå› ï¼ˆå¯èƒ½è¢«ç«™ç‚¹è„šæœ¬æ‹¦æˆªæˆ–æµè§ˆå™¨ç­–ç•¥é™åˆ¶ï¼‰';
            }

            function appendDebugEntryToOverlay(entry) {
                if (!DebugState.logRoot) return;
                const cssEscapeAttrValue = (v) => {
                    const s = String(v ?? '');
                    try {
                        if (typeof CSS !== 'undefined' && CSS.escape) return CSS.escape(s);
                    } catch (e) {}
                    return s.replace(/"/g, '\\"');
                };
                const renderEntryEl = () => {
                    const row = document.createElement('div');
                    row.className = `nto_entry nto_level_${entry.level}${entry.type === 'openFail' ? ' nto_fail' : ''}`;
                    try {
                        row.setAttribute('data-search', formatDebugEntryText(entry).toLowerCase());
                    } catch (e) {}
                    if (entry.type === 'openFail') {
                        row.style.borderColor = 'var(--fail-border)';
                        row.style.background = 'var(--fail-bg)';
                    }
                    const meta = document.createElement('div');
                    meta.className = 'nto_meta';
                    const levelLabel = entry.level === 'ERROR' ? 'é”™è¯¯' : (entry.level === 'WARN' ? 'è­¦å‘Š' : 'ä¿¡æ¯');
                    meta.textContent = `${entry.ts}`;
                    const lv = document.createElement('div');
                    lv.className = `nto_level_${entry.level}`;
                    lv.textContent = `${levelLabel}`;
                    const payload = document.createElement('div');
                    payload.className = 'nto_payload';
                    payload.textContent = (() => {
                        const prefix = entry.level === 'ERROR' ? 'é”™è¯¯' : (entry.level === 'WARN' ? 'è­¦å‘Š' : 'ä¿¡æ¯');
                        let text = `${prefix}ï¼š${entry.type}`;
                        if (entry.type === 'openFail') text = `é”™è¯¯ï¼šopenFail`;
                        if (entry.data == null) return text;
                        try {
                            const s = typeof entry.data === 'string' ? entry.data : JSON.stringify(entry.data);
                            return `${text} ${s}`;
                        } catch (e) {
                            try {
                                return `${text} ${String(entry.data)}`;
                            } catch (e2) {
                                return text;
                            }
                        }
                    })();
                    const btnCopy = document.createElement('button');
                    btnCopy.type = 'button';
                    btnCopy.className = 'nto_btn nto_btn_small nto_btn_copy';
                    btnCopy.textContent = 'å¤åˆ¶';
                    btnCopy.addEventListener('click', async () => {
                        const text = formatDebugEntryText(entry);
                        const ok = await copyTextToClipboard(text);
                        debugLog('copyOne', { ok, type: entry.type }, 'DEBUG');
                    });
                    row.appendChild(meta);
                    row.appendChild(lv);
                    row.appendChild(payload);
                    row.appendChild(btnCopy);
                    return row;
                };

                if (entry.groupId) {
                    let group = DebugState.logRoot.querySelector(`details.nto_group[data-group-id="${cssEscapeAttrValue(entry.groupId)}"]`);
                    if (!group) {
                        group = document.createElement('details');
                        group.className = 'nto_group';
                        group.open = true;
                        group.setAttribute('data-group-id', entry.groupId);
                        const summary = document.createElement('summary');
                        const s1 = document.createElement('span');
                        s1.className = 'nto_meta';
                        s1.textContent = entry.ts;
                        const s2 = document.createElement('span');
                        s2.textContent = 'ç‚¹å‡»ä¼šè¯';
                        const s3 = document.createElement('span');
                        s3.className = 'nto_meta';
                        s3.textContent = '';
                        summary.appendChild(s1);
                        summary.appendChild(s2);
                        summary.appendChild(s3);
                        const body = document.createElement('div');
                        body.className = 'nto_group_body';
                        group.appendChild(summary);
                        group.appendChild(body);
                        DebugState.logRoot.appendChild(group);
                    }
                    const body = group.querySelector('.nto_group_body');
                    if (body) body.appendChild(renderEntryEl());
                    const summaryMeta = group.querySelector('summary .nto_meta:last-child');
                    if (summaryMeta && entry.type === 'click' && entry.data && entry.data.href) {
                        try {
                            summaryMeta.textContent = String(entry.data.href);
                        } catch (e) {}
                    }
                } else {
                    DebugState.logRoot.appendChild(renderEntryEl());
                }
                DebugState.domEntryCount++;
            }

            function applyDebugOverlayLogFilter() {
                if (!DebugState.logRoot) return;
                const q = String(DebugState.filterText || '').trim().toLowerCase();
                const entries = DebugState.logRoot.querySelectorAll('.nto_entry');
                for (let i = 0; i < entries.length; i++) {
                    const el = entries[i];
                    if (!q) {
                        el.style.display = '';
                        continue;
                    }
                    const hay = String(el.getAttribute('data-search') || el.textContent || '').toLowerCase();
                    el.style.display = hay.indexOf(q) !== -1 ? '' : 'none';
                }
                const groups = DebugState.logRoot.querySelectorAll('details.nto_group');
                for (let i = 0; i < groups.length; i++) {
                    const g = groups[i];
                    const vis = g.querySelector('.nto_entry:not([style*="display: none"])');
                    g.style.display = vis ? '' : 'none';
                }
            }
            function formatDebugMetricsText() {
                const m = DebugState.metrics || {};
                const p = DebugState.perf || {};
                const s = p.settings || {};
                const kpi = p.kpi || {};
                const fmt = (v) => (typeof v === 'number' && Number.isFinite(v) ? Math.round(v) : 0);
                const tag = (v, lim) => {
                    const ms = fmt(v);
                    const th = typeof lim === 'number' && lim > 0 ? lim : 0;
                    return th && ms > th ? `!${ms}ms` : `${ms}ms`;
                };
                const ui = `UI: open ${tag(s.openMs, kpi.openMs)}, layout ${tag(s.layoutMs, kpi.layoutMs)}, style ${tag(s.styleMs, kpi.styleMs)}, render ${tag(s.renderMs, kpi.renderMs)}`;
                return `A: flush ${m.aFlushes || 0}, queued ${m.aQueued || 0} | TL: batches ${m.tlBatches || 0}, links ${m.tlLinks || 0}, last ${m.tlLastMs || 0}ms | Cache: hit ${m.cacheHits || 0}, miss ${m.cacheMiss || 0} | ${ui}`;
            }
            function updateDebugMetricsUI() {
                try {
                    if (!DebugState.metricsEl) return;
                    DebugState.metricsEl.textContent = formatDebugMetricsText();
                } catch (e) {}
            }
            function debugLogSampling(type, data, level, rate) {
                try {
                    const r = typeof rate === 'number' && rate > 1 ? rate : 100;
                    if (Math.floor(Math.random() * r) !== 0) return;
                    debugLog(type, data, level);
                } catch (e) {}
            }

            function applyDebugOverlay() {
                const want = debugEnabled();
                if (DebugState.lastEnabled !== want) {
                    DebugState.lastEnabled = want;
                }
                if (want) {
                    if (!isTopWindow()) return;
                    ensureDebugOverlayBroadcast();
                    syncOverlayOwnershipAndUi();
                    bindDebugOverlayFocusEvents();
                    try {
                        if (!DebugState.visibilityBound) {
                            addListener(document, 'visibilitychange', syncOverlayOwnershipAndUi, { passive: true, capture: true });
                            DebugState.visibilityBound = true;
                        }
                    } catch (e) {}
                    try {
                        if (DebugState.overlayEl) {
                            if (DebugState.themeStop) DebugState.themeStop();
                            DebugState.themeStop = applyDebugOverlayTheme(DebugState.overlayEl);
                            updateDebugMetricsUI();
                        }
                    } catch (e) {}
                } else {
                    unbindDebugOverlayFocusEvents();
                    if (DebugState.blurTimer) {
                        try {
                            clearTimeout(DebugState.blurTimer);
                        } catch (e) {}
                        DebugState.blurTimer = null;
                    }
                    try {
                        DebugState.pending.splice(0, DebugState.pending.length);
                    } catch (e) {}
                    DebugState.flushTimer = 0;
                    DebugState.domEntryCount = 0;
                    try {
                        if (DebugState.visibilityBound) {
                            removeListener(document, 'visibilitychange', syncOverlayOwnershipAndUi, { passive: true, capture: true });
                            DebugState.visibilityBound = false;
                        }
                    } catch (e) {}
                    stopDebugOverlayBroadcast();
                    stopDebugOverlay();
                }
            }

            function startDebugOverlay() {
                if (debugOverlayStop) {
                    showDebugOverlayUi();
                    return;
                }
                debugOverlayStop = createDebugOverlay();
            }

            function stopDebugOverlay() {
                if (!debugOverlayStop) return;
                try {
                    debugOverlayStop();
                } catch (e) {}
                debugOverlayStop = null;
            }

            function createDebugOverlay() {
                const existing = document.getElementById(DEBUG_OVERLAY_ID);
                if (existing) {
                    DebugState.overlayEl = existing;
                    DebugState.logRoot = existing.querySelector && existing.querySelector('.nto_body');
                    DebugState.failuresRoot = existing.querySelector && existing.querySelector('.nto_failures');
                    DebugState.filterInput = existing.querySelector && existing.querySelector('.nto_search');
                    if (DebugState.filterInput) {
                        try {
                            DebugState.filterInput.value = String(DebugState.filterText || '');
                        } catch (e) {}
                    }
                    try {
                        if (DebugState.themeStop) DebugState.themeStop();
                        DebugState.themeStop = applyDebugOverlayTheme(existing);
                    } catch (e) {}
                    ensureFailuresRendered();
                    if (DebugState.logRoot) {
                        try {
                            DebugState.pending.splice(0, DebugState.pending.length);
                        } catch (e) {}
                        rebuildDebugOverlayLogFromBuffer();
                    }
                    runThemeSyncUnitTestsOnce();
                    return () => {
                        const el = document.getElementById(DEBUG_OVERLAY_ID);
                        if (el) el.remove();
                        DebugState.overlayEl = null;
                        DebugState.logRoot = null;
                        DebugState.failuresRoot = null;
                        DebugState.filterInput = null;
                        try {
                            if (DebugState.themeStop) DebugState.themeStop();
                        } catch (e) {}
                        DebugState.themeStop = null;
                    };
                }

                const el = document.createElement('div');
                el.id = DEBUG_OVERLAY_ID;
                el.style.position = 'fixed';
                el.style.zIndex = '2147483646';
                el.style.right = '14px';
                el.style.bottom = '14px';
                el.style.width = '420px';
                el.style.maxWidth = 'calc(100vw - 20px)';
                el.style.maxHeight = 'calc(100vh - 20px)';
                el.style.minWidth = '320px';
                el.style.minHeight = '180px';
                el.style.resize = 'both';
                el.style.display = 'flex';
                el.style.flexDirection = 'column';
                el.style.borderRadius = '10px';
                el.style.overflow = 'hidden';
                el.style.font = '12px/1.35 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,PingFang SC,Hiragino Sans GB,Microsoft YaHei,sans-serif';
                DebugState.themeStop = applyDebugOverlayTheme(el);

                const header = document.createElement('div');
                header.className = 'nto_header';
                header.style.display = 'flex';
                header.style.alignItems = 'center';
                header.style.justifyContent = 'space-between';
                header.style.padding = '8px 10px';
                header.style.cursor = 'move';
                header.style.userSelect = 'none';

                const title = document.createElement('div');
                title.className = 'nto_title';
                title.textContent = 'ğŸ æ–°æ ‡ç­¾é¡µæ‰“å¼€ - è°ƒè¯•';

                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.gap = '6px';

                const search = document.createElement('input');
                search.type = 'search';
                search.className = 'nto_search';
                search.placeholder = 'æœç´¢æ—¥å¿—';
                try {
                    search.value = String(DebugState.filterText || '');
                } catch (e) {}
                search.addEventListener('input', () => {
                    DebugState.filterText = search.value || '';
                    applyDebugOverlayLogFilter();
                });
                DebugState.filterInput = search;

                const btnClear = document.createElement('button');
                btnClear.textContent = 'æ¸…ç©º';
                btnClear.type = 'button';
                btnClear.className = 'nto_btn';

                const btnCopy = document.createElement('button');
                btnCopy.textContent = 'å¤åˆ¶å…¨éƒ¨';
                btnCopy.type = 'button';
                btnCopy.className = 'nto_btn';

                const btnClose = document.createElement('button');
                btnClose.textContent = 'å…³é—­';
                btnClose.type = 'button';
                btnClose.className = 'nto_btn';

                actions.appendChild(search);
                actions.appendChild(btnClear);
                actions.appendChild(btnCopy);
                actions.appendChild(btnClose);

                header.appendChild(title);
                header.appendChild(actions);
                el.appendChild(header);
                const metrics = document.createElement('div');
                metrics.className = 'nto_metrics';
                metrics.style.padding = '6px 10px';
                metrics.style.fontSize = '11px';
                metrics.style.opacity = '.9';
                metrics.textContent = '';
                el.appendChild(metrics);

                const failBox = document.createElement('details');
                failBox.className = 'nto_failbox';
                failBox.open = true;
                const failSummary = document.createElement('summary');
                failSummary.textContent = 'è·³è½¬å¤±è´¥ï¼ˆ0ï¼‰';
                const failBody = document.createElement('div');
                failBody.className = 'nto_failbody';
                const failures = document.createElement('div');
                failures.className = 'nto_failures';
                failBox.appendChild(failSummary);
                failBody.appendChild(failures);
                failBox.appendChild(failBody);
                el.appendChild(failBox);

                const body = document.createElement('div');
                body.className = 'nto_body';
                body.style.flex = '1';
                el.appendChild(body);

                const getPos = () => {
                    const v = getValue(DEBUG_POS_KEY, null);
                    if (!v) return null;
                    if (typeof v === 'object' && v) return v;
                    try {
                        const parsed = JSON.parse(String(v));
                        if (parsed && typeof parsed === 'object') return parsed;
                    } catch (e) {}
                    return null;
                };
                const setPos = (pos) => {
                    try {
                        setValue(DEBUG_POS_KEY, pos);
                    } catch (e) {}
                };

                const applyPos = () => {
                    const pos = getPos();
                    if (!pos) return;
                    const rect = el.getBoundingClientRect();
                    const w = rect.width || 0;
                    const h = rect.height || 0;
                    if (typeof pos.left === 'number') {
                        const left = Math.max(6, Math.min(window.innerWidth - w - 6, pos.left));
                        el.style.left = `${left}px`;
                        el.style.right = 'auto';
                    }
                    if (typeof pos.top === 'number') {
                        const top = Math.max(6, Math.min(window.innerHeight - h - 6, pos.top));
                        el.style.top = `${top}px`;
                        el.style.bottom = 'auto';
                    }
                };
                applyPos();

                let dragging = false;
                let startX = 0;
                let startY = 0;
                let startLeft = 0;
                let startTop = 0;
                const bindDragMoveListeners = () => {
                    try {
                        window.addEventListener('mousemove', onMove, true);
                        window.addEventListener('mouseup', onUp, true);
                    } catch (e) {}
                };
                const unbindDragMoveListeners = () => {
                    try {
                        window.removeEventListener('mousemove', onMove, true);
                        window.removeEventListener('mouseup', onUp, true);
                    } catch (e) {}
                };
                const onDown = (ev) => {
                    if (!ev || ev.button !== 0) return;
                    if (dragging) return;
                    try {
                        const t = ev.target;
                        if (t && t.closest && t.closest('button')) return;
                        if (t && t.closest && t.closest('input,textarea,select')) return;
                    } catch (e) {}
                    dragging = true;
                    startX = ev.clientX;
                    startY = ev.clientY;
                    const rect = el.getBoundingClientRect();
                    startLeft = rect.left;
                    startTop = rect.top;
                    debugLog('overlayDragDown', { x: startX, y: startY, left: startLeft, top: startTop, t: Date.now() }, 'DEBUG');
                    bindDragMoveListeners();
                    ev.preventDefault();
                };
                const onMove = (ev) => {
                    if (!dragging) return;
                    const dx = ev.clientX - startX;
                    const dy = ev.clientY - startY;
                    const nextLeft = Math.max(6, Math.min(window.innerWidth - 6, startLeft + dx));
                    const nextTop = Math.max(6, Math.min(window.innerHeight - 6, startTop + dy));
                    el.style.left = `${nextLeft}px`;
                    el.style.top = `${nextTop}px`;
                    el.style.right = 'auto';
                    el.style.bottom = 'auto';
                    debugLog('overlayDragMove', { x: ev.clientX, y: ev.clientY, left: nextLeft, top: nextTop, t: Date.now() }, 'DEBUG');
                };
                const onUp = () => {
                    if (!dragging) return;
                    dragging = false;
                    const rect = el.getBoundingClientRect();
                    setPos({ left: rect.left, top: rect.top });
                    debugLog('overlayDragUp', { left: rect.left, top: rect.top, t: Date.now() }, 'DEBUG');
                    unbindDragMoveListeners();
                };

                addListener(header, 'mousedown', onDown, { passive: false, capture: true });

                btnClear.addEventListener('click', () => {
                    DebugState.buffer.splice(0, DebugState.buffer.length);
                    if (DebugState.logRoot) DebugState.logRoot.textContent = '';
                });
                btnClose.addEventListener('click', () => {
                    try {
                        settings.debugOverlay = false;
                        setValue('debugOverlay', false);
                    } catch (e) {}
                    try {
                        releaseOverlayOwnershipIfOwner();
                    } catch (e) {}
                    applyDebugOverlay();
                });
                btnCopy.addEventListener('click', async () => {
                    const text = DebugState.buffer.map(formatDebugEntryText).join('\n');
                    const ok = await copyTextToClipboard(text);
                    debugLog('copy', { ok, len: text.length }, 'DEBUG');
                });

                const origPush = history && history.pushState ? history.pushState.bind(history) : null;
                const origReplace = history && history.replaceState ? history.replaceState.bind(history) : null;
                const patched = { push: false, replace: false };

                const patchHistory = () => {
                    try {
                        if (origPush && history.pushState) {
                            history.pushState = function(state, title2, url) {
                                debugLog('pushState', { url: url == null ? '' : String(url) }, 'DEBUG');
                                return origPush(state, title2, url);
                            };
                            patched.push = true;
                        }
                        if (origReplace && history.replaceState) {
                            history.replaceState = function(state, title2, url) {
                                debugLog('replaceState', { url: url == null ? '' : String(url) }, 'DEBUG');
                                return origReplace(state, title2, url);
                            };
                            patched.replace = true;
                        }
                    } catch (e) {}
                };
                patchHistory();

                const onPop = () => debugLog('popstate', { url: location.href }, 'DEBUG');
                const onHash = () => debugLog('hashchange', { url: location.href }, 'DEBUG');
                const onBeforeUnload = () => {
                    debugLog('beforeunload', { url: location.href }, 'DEBUG');
                    try {
                        releaseOverlayOwnershipIfOwner();
                    } catch (e) {}
                };

                addListener(window, 'popstate', onPop, { passive: true, capture: true });
                addListener(window, 'hashchange', onHash, { passive: true, capture: true });
                addListener(window, 'beforeunload', onBeforeUnload, { passive: true, capture: true });

                try {
                    (document.documentElement || document.body || document).appendChild(el);
                } catch (e) {
                    try {
                        document.body.appendChild(el);
                    } catch (e2) {}
                }

                DebugState.overlayEl = el;
                DebugState.logRoot = body;
                DebugState.failuresRoot = failures;
                DebugState.metricsEl = metrics;
                ensureFailuresRendered();
                try {
                    DebugState.pending.splice(0, DebugState.pending.length);
                } catch (e) {}
                rebuildDebugOverlayLogFromBuffer();
                runThemeSyncUnitTestsOnce();
                debugLog('overlay', { on: true, url: location.href });

                return () => {
                    try {
                        removeListener(window, 'popstate', onPop, { passive: true, capture: true });
                        removeListener(window, 'hashchange', onHash, { passive: true, capture: true });
                        removeListener(window, 'beforeunload', onBeforeUnload, { passive: true, capture: true });
                    } catch (e) {}
                    try {
                        removeListener(header, 'mousedown', onDown, { passive: false, capture: true });
                        unbindDragMoveListeners();
                    } catch (e) {}
                    try {
                        if (patched.push && origPush) history.pushState = origPush;
                        if (patched.replace && origReplace) history.replaceState = origReplace;
                    } catch (e) {}
                    try {
                        const cur = document.getElementById(DEBUG_OVERLAY_ID);
                        if (cur) cur.remove();
                    } catch (e) {}
                    DebugState.overlayEl = null;
                    DebugState.logRoot = null;
                    DebugState.failuresRoot = null;
                    DebugState.metricsEl = null;
                    DebugState.filterInput = null;
                    try {
                        if (DebugState.themeStop) DebugState.themeStop();
                    } catch (e) {}
                    DebugState.themeStop = null;
                };
            }

            const GO_TB_UI_ID = 'goTopBottom';
            const GO_TB_POS_KEY = 'gtb_pos';
            const GO_TB_IGNORED_KEY = 'goTBIgnoredSites';
            const GO_TB_STYLE_ID = 'goTopBottom-style';

            const GoTBState = {
                stop: null,
                retryTimer: 0,
                retryCount: 0,
                giveUpLogged: false,
            };

            function scheduleGoTopBottomRetry() {
                if (GoTBState.retryTimer) return;
                if (GoTBState.retryCount >= 200) {
                    if (!GoTBState.giveUpLogged) {
                        GoTBState.giveUpLogged = true;
                        debugLog('goTBGiveUp', { reason: 'retryLimit', url: location.href }, 'WARN');
                    }
                    return;
                }
                GoTBState.retryCount++;
                GoTBState.retryTimer = setTimeout(() => {
                    GoTBState.retryTimer = 0;
                    startGoTopBottomControls();
                }, 250);
            }

            function readGoTBIgnoredSites() {
                let list = getValue(GO_TB_IGNORED_KEY, []);
                if (!Array.isArray(list)) list = [];
                const legacy = safeJsonParse(localStorage.getItem('btnScript_ignoredSites') || '[]', []);
                if (!Array.isArray(legacy) || !legacy.length) return list;
                const merged = Array.from(
                    new Set(
                        list.concat(legacy)
                            .map((x) => String(x || '').trim().toLowerCase())
                            .filter(Boolean)
                    )
                );
                if (merged.length !== list.length) {
                    try {
                        setValue(GO_TB_IGNORED_KEY, merged);
                    } catch (e) {}
                }
                return merged;
            }

            function startGoTopBottomControls() {
                const existing = document.getElementById(GO_TB_UI_ID);
                if (existing) {
                    try {
                        const cs = window.getComputedStyle ? getComputedStyle(existing) : null;
                        const hidden = cs ? cs.display === 'none' : existing.style && existing.style.display === 'none';
                        if (hidden) {
                            try { existing.style.setProperty('display', 'flex', 'important'); } catch (e1) {}
                            try { existing.style.setProperty('visibility', 'visible', 'important'); } catch (e2) {}
                            try { existing.style.setProperty('opacity', '1', 'important'); } catch (e3) {}
                            try { existing.style.setProperty('pointer-events', 'auto', 'important'); } catch (e4) {}
                            debugLog('goTBShow', { reason: 'unhideExisting', url: location.href }, 'INFO');
                        }
                    } catch (e) {}
                }
                if (GoTBState.stop && existing) return;
                if (GoTBState.stop) {
                    stopGoTopBottomControls();
                }
                if (!isTopWindow()) {
                    debugLog('goTBSkip', { reason: 'notTopWindow', url: location.href }, 'DEBUG');
                    return;
                }
                if (!document.body) return scheduleGoTopBottomRetry();

                const currentHost = getCurrentHost();
                const ignoredSites = readGoTBIgnoredSites();
                if (currentHost && ignoredSites.indexOf(currentHost) !== -1) {
                    debugLog('goTBSkip', { reason: 'ignoredSite', host: currentHost, url: location.href }, 'INFO');
                    return;
                }
                GoTBState.retryCount = 0;
                GoTBState.giveUpLogged = false;

                const shouldPreventClick = (lastDragEndTime) => Date.now() - lastDragEndTime < 500;

                const createStyle = () => {
                    if (document.getElementById(GO_TB_STYLE_ID)) return;
                    const style = document.createElement('style');
                    style.id = GO_TB_STYLE_ID;
                    style.type = 'text/css';
                    style.textContent =
                        '#goTopBottom{position:fixed !important;bottom:75px !important;right:15px !important;z-index:2147483647 !important;display:flex !important;flex-direction:column !important;row-gap:12px !important;opacity:.9 !important;transition:opacity .2s !important;pointer-events:auto !important;}' +
                        '#goTopBottom:hover{opacity:1 !important;}' +
                        '#goTopBottom,#goTopBottom *{box-sizing:border-box !important;}' +
                        '#goTopBottom .t-btn{display:flex !important;justify-content:center !important;align-items:center !important;width:40px !important;height:40px !important;min-width:40px !important;min-height:40px !important;padding:0 !important;margin:0 !important;border:0 !important;outline:0 !important;cursor:pointer !important;color:#fff !important;border-radius:6px !important;background-image:linear-gradient(to top right,#6966ff,#37e2d3) !important;background-size:100% 100% !important;background-color:transparent !important;line-height:1 !important;text-decoration:none !important;user-select:none !important;}' +
                        '#goTopBottom .t-btn svg{width:22px !important;height:22px !important;display:block !important;pointer-events:none !important;}' +
                        '#goTopBottom .t-btn path{pointer-events:none !important;}' +
                        '#goTopBottom .bottom{opacity:1 !important;}';
                    try {
                        (document.head || document.documentElement || document.body).appendChild(style);
                    } catch (e) {}
                };

                const setImportant = (el, prop, value) => {
                    try {
                        el.style.setProperty(prop, value, 'important');
                    } catch (e) {}
                };

                const forceContainerVisible = (el) => {
                    if (!el) return;
                    setImportant(el, 'display', 'flex');
                    setImportant(el, 'visibility', 'visible');
                    setImportant(el, 'opacity', '1');
                    setImportant(el, 'pointer-events', 'auto');
                    setImportant(el, 'z-index', '2147483647');
                    setImportant(el, 'position', 'fixed');
                    setImportant(el, 'flex-direction', 'column');
                    setImportant(el, 'row-gap', '12px');
                    setImportant(el, 'width', '40px');
                    setImportant(el, 'height', 'auto');
                    setImportant(el, 'padding', '0');
                    setImportant(el, 'margin', '0');
                };

                const ensureContainer = () => {
                    let container = document.getElementById(GO_TB_UI_ID);
                    if (container) return container;
                    container = document.createElement('div');
                    container.id = GO_TB_UI_ID;
                    container.style.display = 'flex';
                    container.style.justifyContent = 'center';
                    container.style.alignItems = 'center';
                    container.style.width = '40px';
                    container.style.height = 'auto';

                    const top = document.createElement('span');
                    top.className = 't-btn gotop';
                    top.title = 'è¿”å›é¡¶éƒ¨';
                    top.innerHTML =
                        '<svg t="1681901274619" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3044" width="22" height="22"><path d="M199.36 572.768a31.904 31.904 0 0 0 22.624-9.376l294.144-294.144 285.728 285.728a31.968 31.968 0 1 0 45.248-45.248l-308.352-308.352a32 32 0 0 0-45.28 0l-316.768 316.768a31.968 31.968 0 0 0 22.656 54.624z" p-id="3045" fill="#ffffff"></path><path d="M538.784 457.376a32 32 0 0 0-45.28 0l-316.768 316.768a31.968 31.968 0 1 0 45.248 45.248l294.144-294.144 285.728 285.728a31.968 31.968 0 1 0 45.248-45.248l-308.32-308.352z" p-id="3046" fill="#ffffff"></path></svg>';

                    const bottom = document.createElement('span');
                    bottom.className = 't-btn bottom';
                    bottom.title = 'è¿”å›åº•éƒ¨';
                    bottom.innerHTML =
                        '<svg t="1681901383895" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4902" width="22" height="22"><path d="M493.504 558.144a31.904 31.904 0 0 0 45.28 0l308.352-308.352a31.968 31.968 0 1 0-45.248-45.248l-285.728 285.728-294.176-294.144a31.968 31.968 0 1 0-45.248 45.248l316.768 316.768z" p-id="4903" fill="#ffffff"></path><path d="M801.888 460.576l-285.728 285.728-294.144-294.144a31.968 31.968 0 1 0-45.248 45.248l316.768 316.768a31.904 31.904 0 0 0 45.28 0l308.352-308.352a32 32 0 1 0-45.28-45.248z" p-id="4904" fill="#ffffff"></path></svg>';

                    container.appendChild(top);
                    container.appendChild(bottom);
                    try {
                        document.body.appendChild(container);
                    } catch (e) {
                        try {
                            (document.documentElement || document).appendChild(container);
                        } catch (e2) {}
                    }
                    return container;
                };

                createStyle();
                const hadContainer = !!existing;
                const container = ensureContainer();
                forceContainerVisible(container);
                try {
                    const btns = container.querySelectorAll('.t-btn');
                    for (let i = 0; i < btns.length; i++) {
                        const b = btns[i];
                        setImportant(b, 'display', 'flex');
                        setImportant(b, 'opacity', '1');
                        setImportant(b, 'visibility', 'visible');
                        setImportant(b, 'pointer-events', 'auto');
                        setImportant(b, 'width', '40px');
                        setImportant(b, 'height', '40px');
                        setImportant(b, 'min-width', '40px');
                        setImportant(b, 'min-height', '40px');
                        setImportant(b, 'padding', '0');
                        setImportant(b, 'margin', '0');
                        setImportant(b, 'border', '0');
                        setImportant(b, 'outline', '0');
                        setImportant(b, 'border-radius', '6px');
                        setImportant(b, 'background-image', 'linear-gradient(to top right,#6966ff,#37e2d3)');
                        setImportant(b, 'background-size', '100% 100%');
                        setImportant(b, 'background-color', 'transparent');
                        try {
                            const svg = b.querySelector && b.querySelector('svg');
                            if (svg) {
                                setImportant(svg, 'width', '22px');
                                setImportant(svg, 'height', '22px');
                                setImportant(svg, 'display', 'block');
                                setImportant(svg, 'pointer-events', 'none');
                            }
                        } catch (e2) {}
                    }
                } catch (e) {}
                debugLog(
                    'goTBInit',
                    { reason: hadContainer ? 'reuse' : 'create', host: getCurrentHost(), url: location.href },
                    'INFO'
                );

                let lastDragEndTime = 0;
                let menuEl = null;

                const hideMenu = () => {
                    if (!menuEl) return;
                    try {
                        menuEl.style.display = 'none';
                    } catch (e) {}
                };

                const hideScrollButtons = () => {
                    try {
                        container.style.display = 'none';
                    } catch (e) {}
                    hideMenu();
                };

                const ignoreCurrentSite = () => {
                    const host = getCurrentHost();
                    let sites = readGoTBIgnoredSites();
                    if (!sites.includes(host)) {
                        sites.push(host);
                        try {
                            setValue(GO_TB_IGNORED_KEY, sites);
                        } catch (e) {}
                    }
                    hideScrollButtons();
                };

                const createMenuItem = (text, icon, onClick) => {
                    const item = document.createElement('div');
                    item.style.padding = '8px 12px';
                    item.style.cursor = 'pointer';
                    item.style.borderRadius = '4px';
                    item.style.margin = '2px 5px';
                    item.style.whiteSpace = 'nowrap';
                    item.style.overflow = 'hidden';
                    item.style.textOverflow = 'ellipsis';
                    item.style.transition = 'background-color 0.2s';
                    item.style.display = 'flex';
                    item.style.alignItems = 'center';
                    item.style.gap = '5px';

                    const iconElem = document.createElement('div');
                    iconElem.style.flexShrink = '0';
                    iconElem.style.width = '14px';
                    iconElem.style.height = '14px';
                    iconElem.style.display = 'flex';
                    iconElem.style.justifyContent = 'center';
                    iconElem.style.alignItems = 'center';
                    iconElem.style.fontSize = '12px';
                    iconElem.textContent = icon;

                    const textElem = document.createElement('div');
                    textElem.style.flexGrow = '1';
                    textElem.style.overflow = 'hidden';
                    textElem.style.textOverflow = 'ellipsis';
                    textElem.textContent = text;

                    item.appendChild(iconElem);
                    item.appendChild(textElem);

                    item.addEventListener('mouseenter', () => {
                        item.style.backgroundColor = '#f2f2f2';
                    });
                    item.addEventListener('mouseleave', () => {
                        item.style.backgroundColor = 'transparent';
                    });
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        try {
                            onClick();
                        } catch (e2) {}
                    });
                    return item;
                };

                const ensureMenu = () => {
                    const existingMenu = document.getElementById('gtb-context-menu');
                    if (existingMenu) return existingMenu;
                    const menu = document.createElement('div');
                    menu.id = 'gtb-context-menu';
                    menu.style.position = 'fixed';
                    menu.style.background = 'white';
                    menu.style.border = '1px solid #ddd';
                    menu.style.borderRadius = '8px';
                    menu.style.boxShadow = '0 3px 10px rgba(0,0,0,0.15)';
                    menu.style.padding = '5px 0';
                    menu.style.zIndex = '2147483647';
                    menu.style.display = 'none';
                    menu.style.width = '140px';
                    menu.style.boxSizing = 'border-box';
                    menu.style.maxWidth = '140px';
                    menu.style.overflow = 'hidden';
                    menu.style.fontFamily = 'Arial, sans-serif';
                    menu.style.fontSize = '14px';
                    menu.style.transition = 'opacity 0.2s ease';

                    menu.appendChild(createMenuItem('å…³é—­æŒ‰é’®', 'âœ•', hideScrollButtons));
                    menu.appendChild(createMenuItem('å¿½ç•¥æ­¤ç½‘ç«™', 'â›”', ignoreCurrentSite));

                    try {
                        document.body.appendChild(menu);
                    } catch (e) {
                        try {
                            (document.documentElement || document).appendChild(menu);
                        } catch (e2) {}
                    }
                    return menu;
                };

                const showContextMenu = (e) => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (e2) {}
                    menuEl = ensureMenu();
                    if (!menuEl) return;

                    const viewportWidth = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
                    const viewportHeight = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);

                    menuEl.style.visibility = 'hidden';
                    menuEl.style.display = 'block';
                    menuEl.style.left = '0px';
                    menuEl.style.top = '0px';
                    const menuHeight = menuEl.getBoundingClientRect().height || 0;

                    const x = e.clientX || 0;
                    const y = e.clientY || 0;

                    const posX = x + 160 > viewportWidth ? Math.max(x - 150, 10) : x;
                    const posY = y + menuHeight + 20 > viewportHeight ? Math.max(10, viewportHeight - menuHeight - 20) : y;

                    menuEl.style.left = `${posX}px`;
                    menuEl.style.top = `${posY}px`;
                    menuEl.style.visibility = 'visible';
                };

                const onDocClick = (e) => {
                    if (!menuEl || menuEl.style.display === 'none') return;
                    const t = e && e.target;
                    if (t && menuEl.contains(t)) return;
                    hideMenu();
                };

                const resolveMaxScrollTop = () => Math.max(
                    document.body ? document.body.scrollHeight : 0,
                    document.body ? document.body.offsetHeight : 0,
                    document.documentElement ? document.documentElement.clientHeight : 0,
                    document.documentElement ? document.documentElement.scrollHeight : 0,
                    document.documentElement ? document.documentElement.offsetHeight : 0
                );

                const smoothScrollTo = (top) => {
                    const t = Math.max(0, Number(top) || 0);
                    try {
                        window.scrollTo({ top: t, behavior: 'smooth' });
                    } catch (e) {
                        try {
                            window.scrollTo(0, t);
                        } catch (e2) {}
                    }
                };

                const onContainerClick = (e) => {
                    if (shouldPreventClick(lastDragEndTime)) {
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                        } catch (e2) {}
                        return;
                    }
                    const target = e && e.target && e.target.closest ? e.target.closest('span') : null;
                    if (!target) return;
                    const cls = String(target.className || '');
                    if (cls.indexOf('gotop') !== -1) smoothScrollTo(0);
                    else smoothScrollTo(resolveMaxScrollTop());
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (e2) {}
                };

                let dragging = false;
                let startX = 0;
                let startY = 0;
                let startLeft = 0;
                let startTop = 0;
                let moved = false;
                const dragThreshold = 5;

                const applySavedPos = () => {
                    let position = getValue(GO_TB_POS_KEY, {});
                    if (!position || typeof position !== 'object') position = {};
                    if (typeof position.left !== 'number' || typeof position.top !== 'number') return;
                    const vw = window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || 0;
                    const vh = window.innerHeight || (document.documentElement && document.documentElement.clientHeight) || 0;
                    let w = 50;
                    let h = 100;
                    try {
                        const rect = container.getBoundingClientRect();
                        w = rect.width || w;
                        h = rect.height || h;
                    } catch (e) {}
                    const maxLeft = vw ? Math.max(6, vw - w - 6) : null;
                    const maxTop = vh ? Math.max(6, vh - h - 6) : null;
                    const safeLeft = maxLeft == null ? position.left : Math.max(6, Math.min(maxLeft, position.left));
                    const safeTop = maxTop == null ? position.top : Math.max(6, Math.min(maxTop, position.top));
                    setImportant(container, 'left', `${safeLeft}px`);
                    setImportant(container, 'top', `${safeTop}px`);
                    setImportant(container, 'right', 'auto');
                    setImportant(container, 'bottom', 'auto');
                    setImportant(container, 'position', 'fixed');
                    debugLog(
                        'goTBInitPos',
                        {
                            left: safeLeft,
                            top: safeTop,
                            rawLeft: position.left,
                            rawTop: position.top,
                            w,
                            h,
                            vw,
                            vh,
                            t: Date.now(),
                        },
                        'DEBUG'
                    );
                };

                const onDown = (e) => {
                    if (!e || e.button !== 0) return;
                    dragging = true;
                    moved = false;
                    startX = e.pageX;
                    startY = e.pageY;
                    try {
                        const rect = container.getBoundingClientRect();
                        startLeft = rect.left;
                        startTop = rect.top;
                    } catch (e2) {
                        startLeft = 0;
                        startTop = 0;
                    }
                    debugLog('goTBDragDown', { x: startX, y: startY, left: startLeft, top: startTop, t: Date.now() }, 'DEBUG');
                    try {
                        e.preventDefault();
                    } catch (e2) {}
                };

                const onMove = (e) => {
                    if (!dragging) return;
                    const dx = (e.pageX || 0) - startX;
                    const dy = (e.pageY || 0) - startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= dragThreshold) return;
                    moved = true;
                    const vw = window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || 0;
                    const vh = window.innerHeight || (document.documentElement && document.documentElement.clientHeight) || 0;
                    let w = 50;
                    let h = 100;
                    try {
                        const rect = container.getBoundingClientRect();
                        w = rect.width || w;
                        h = rect.height || h;
                    } catch (e2) {}
                    const maxLeft = vw ? Math.max(6, vw - w - 6) : null;
                    const maxTop = vh ? Math.max(6, vh - h - 6) : null;
                    const nextLeft = maxLeft == null ? startLeft + dx : Math.max(6, Math.min(maxLeft, startLeft + dx));
                    const nextTop = maxTop == null ? startTop + dy : Math.max(6, Math.min(maxTop, startTop + dy));
                    setImportant(container, 'left', `${nextLeft}px`);
                    setImportant(container, 'top', `${nextTop}px`);
                    setImportant(container, 'right', 'auto');
                    setImportant(container, 'bottom', 'auto');
                    setImportant(container, 'position', 'fixed');
                    debugLog('goTBDragMove', { x: e.pageX, y: e.pageY, left: nextLeft, top: nextTop, t: Date.now() }, 'DEBUG');
                };

                const onUp = (e) => {
                    if (!dragging) return;
                    dragging = false;
                    if (!moved) return;
                    lastDragEndTime = Date.now();
                    try {
                        const rect = container.getBoundingClientRect();
                        setValue(GO_TB_POS_KEY, { left: rect.left, top: rect.top });
                        debugLog('goTBDragUp', { left: rect.left, top: rect.top, t: Date.now() }, 'DEBUG');
                    } catch (e2) {}
                    try {
                        if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
                    } catch (e2) {}
                };

                applySavedPos();
                try {
                    const vw = window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || 0;
                    const vh = window.innerHeight || (document.documentElement && document.documentElement.clientHeight) || 0;
                    const rect = container.getBoundingClientRect();
                    const offscreen = vw && vh
                        ? (rect.right < 0 || rect.bottom < 0 || rect.left > vw || rect.top > vh)
                        : (rect.right < 0 || rect.bottom < 0);
                    if (offscreen) {
                        try {
                            setValue(GO_TB_POS_KEY, {});
                        } catch (e2) {}
                        setImportant(container, 'left', 'auto');
                        setImportant(container, 'top', 'auto');
                        setImportant(container, 'right', '15px');
                        setImportant(container, 'bottom', '75px');
                        debugLog('goTBResetPos', { rect: { left: rect.left, top: rect.top, right: rect.right, bottom: rect.bottom }, vw, vh, url: location.href }, 'WARN');
                    }
                    let cs = null;
                    try {
                        cs = window.getComputedStyle ? getComputedStyle(container) : null;
                    } catch (e3) {}
                    debugLog(
                        'goTBReady',
                        {
                            rect: { left: rect.left, top: rect.top, right: rect.right, bottom: rect.bottom, w: rect.width, h: rect.height },
                            display: cs ? cs.display : '',
                            visibility: cs ? cs.visibility : '',
                            opacity: cs ? cs.opacity : '',
                            url: location.href,
                        },
                        'INFO'
                    );
                } catch (e) {}

                container.addEventListener('contextmenu', showContextMenu, true);
                container.addEventListener('click', onContainerClick, true);
                container.addEventListener('mousedown', onDown, true);
                window.addEventListener('mousemove', onMove, true);
                window.addEventListener('mouseup', onUp, true);
                document.addEventListener('click', onDocClick, true);

                GoTBState.stop = function () {
                    if (GoTBState.retryTimer) {
                        try {
                            clearTimeout(GoTBState.retryTimer);
                        } catch (e) {}
                        GoTBState.retryTimer = 0;
                    }
                    GoTBState.retryCount = 0;
                    GoTBState.giveUpLogged = false;
                    try {
                        container.removeEventListener('contextmenu', showContextMenu, true);
                        container.removeEventListener('click', onContainerClick, true);
                        container.removeEventListener('mousedown', onDown, true);
                        window.removeEventListener('mousemove', onMove, true);
                        window.removeEventListener('mouseup', onUp, true);
                        document.removeEventListener('click', onDocClick, true);
                    } catch (e) {}
                    try {
                        const el = document.getElementById(GO_TB_UI_ID);
                        if (el) el.remove();
                    } catch (e) {}
                    try {
                        const menu = document.getElementById('gtb-context-menu');
                        if (menu) menu.remove();
                    } catch (e) {}
                    try {
                        const style = document.getElementById(GO_TB_STYLE_ID);
                        if (style) style.remove();
                    } catch (e) {}
                };
            }

            /**
             * åœæ­¢å¹¶ç§»é™¤ç½®é¡¶/ç½®åº•æŒ‰é’®åŠç›¸å…³äº‹ä»¶
             */
            function stopGoTopBottomControls() {
                if (!GoTBState.stop) return;
                try {
                    GoTBState.stop();
                } catch (e) {}
                GoTBState.stop = null;
            }

            /**
             * æ ¹æ®é…ç½®å¼€å…³åº”ç”¨æˆ–ç§»é™¤ç½®é¡¶/ç½®åº•æŒ‰é’®
             */
            function applyGoTopBottomControls(active) {
                if (!active) return stopGoTopBottomControls();
                startGoTopBottomControls();
            }

            function getAutoUnfoldState() {
                if (getAutoUnfoldState._state) return getAutoUnfoldState._state;
                getAutoUnfoldState._state = {
                    websites: null,
                    websitesError: '',
                    compiledWebsites: null,
                    compiledError: '',
                    candidatesKey: '',
                    candidates: null,
                    intervalId: 0,
                    ticks: 0,
                    startedAt: 0,
                    tipKey: '',
                    tipAt: 0,
                };
                return getAutoUnfoldState._state;
            }

            function extractWebsitesArrayLiteral(text) {
                const s = String(text || '');
                const hit = /const\s+websites\s*=\s*/m.exec(s);
                if (!hit) return '';
                let i = hit.index + hit[0].length;
                while (i < s.length && /\s/.test(s[i])) i++;
                if (s[i] !== '[') {
                    const j = s.indexOf('[', i);
                    if (j === -1) return '';
                    i = j;
                }
                const start = i;
                let depth = 0;
                let quote = '';
                let esc = false;
                for (; i < s.length; i++) {
                    const ch = s[i];
                    const next = i + 1 < s.length ? s[i + 1] : '';
                    if (quote) {
                        if (esc) {
                            esc = false;
                            continue;
                        }
                        if (ch === '\\') {
                            esc = true;
                            continue;
                        }
                        if (ch === quote) {
                            quote = '';
                            continue;
                        }
                        continue;
                    }
                    if (ch === '"' || ch === "'" || ch === '`') {
                        quote = ch;
                        esc = false;
                        continue;
                    }
                    if (ch === '/' && next === '/') {
                        const end = s.indexOf('\n', i + 2);
                        if (end === -1) break;
                        i = end;
                        continue;
                    }
                    if (ch === '/' && next === '*') {
                        const end = s.indexOf('*/', i + 2);
                        if (end === -1) break;
                        i = end + 1;
                        continue;
                    }
                    if (ch === '[') {
                        depth++;
                        continue;
                    }
                    if (ch === ']') {
                        depth--;
                        if (depth === 0) return s.slice(start, i + 1);
                        continue;
                    }
                }
                return '';
            }

            function parseAutoUnfoldWebsitesFromText(text) {
                const literal = extractWebsitesArrayLiteral(text);
                if (!literal) return [];
                if (literal.length > 1200000) return [];
                try {
                    const out = new Function(`return (${literal});`)();
                    return Array.isArray(out) ? out : [];
                } catch (e) {
                    return [];
                }
            }

            function getAutoUnfoldWebsitesFromGlobal() {
                try {
                    if (typeof window === 'undefined') return [];
                    const websites = window.websites;
                    return Array.isArray(websites) ? websites : [];
                } catch (e) {
                    return [];
                }
            }

            function getAutoUnfoldWebsites() {
                const state = getAutoUnfoldState();
                if (Array.isArray(state.websites)) return state.websites;
                state.websites = [];
                state.websitesError = '';
                state.compiledWebsites = null;
                state.compiledError = '';
                state.candidatesKey = '';
                state.candidates = null;
                let text = '';
                try {
                    if (typeof GM_getResourceText === 'function') text = String(GM_getResourceText('AutoUnfold') || '');
                } catch (e) {
                    state.websitesError = String(e && e.message ? e.message : e);
                }
                let websitesFromGlobal = [];
                if (!text) websitesFromGlobal = getAutoUnfoldWebsitesFromGlobal();
                if (text) {
                    try {
                        state.websites = parseAutoUnfoldWebsitesFromText(text);
                        if (!state.websites.length) state.websitesError = 'æœªè§£æåˆ° websites é…ç½®';
                    } catch (e) {
                        state.websites = [];
                        state.websitesError = String(e && e.message ? e.message : e);
                        debugLog('autoUnfoldLoad', { ok: false, reason: state.websitesError }, 'ERROR');
                    }
                } else if (websitesFromGlobal.length) {
                    state.websites = websitesFromGlobal;
                    state.websitesError = '';
                } else {
                    state.websitesError = state.websitesError || 'AutoUnfold èµ„æºä¸ºç©º';
                    debugLog('autoUnfoldLoad', { ok: false, reason: state.websitesError }, 'WARN');
                    return state.websites;
                }
                if (state.websitesError) {
                    debugLog('autoUnfoldLoad', { ok: false, reason: state.websitesError }, 'WARN');
                    return state.websites;
                }
                debugLog('autoUnfoldLoad', { ok: true, count: state.websites.length }, 'INFO');
                return state.websites;
            }

            function parseAutoUnfoldUrlPattern(raw) {
                const s = String(raw || '').trim();
                if (!s) return null;
                if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(s)) {
                    try {
                        const u = new URL(s);
                        return {
                            host: String(u.hostname || '').toLowerCase(),
                            needle: `${u.pathname || ''}${u.search || ''}${u.hash || ''}`.trim(),
                        };
                    } catch (e) {
                        return { host: '', needle: s };
                    }
                }
                const slashIdx = s.indexOf('/');
                if (slashIdx > 0) {
                    const host = s.slice(0, slashIdx).trim().toLowerCase();
                    const needle = s.slice(slashIdx).trim();
                    return { host, needle };
                }
                return { host: s.toLowerCase(), needle: '' };
            }

            function matchAutoUnfoldPattern(pattern, host, path) {
                if (!pattern) return false;
                const h = String(host || '').trim().toLowerCase();
                if (!h) return false;
                const p = String(path || '');
                const hostNeedle = String(pattern.host || '').trim().toLowerCase();
                if (!hostNeedle) {
                    const needle = String(pattern.needle || '');
                    if (!needle) return false;
                    return String(location.href || '').indexOf(needle) !== -1;
                }
                const okHost = h === hostNeedle || h.endsWith(`.${hostNeedle}`);
                if (!okHost) return false;
                const needle = String(pattern.needle || '');
                if (!needle) return true;
                return p.indexOf(needle) !== -1;
            }

            function getAutoUnfoldCompiledWebsites() {
                const state = getAutoUnfoldState();
                if (Array.isArray(state.compiledWebsites)) return state.compiledWebsites;
                state.compiledWebsites = [];
                state.compiledError = '';
                const websites = getAutoUnfoldWebsites();
                if (!websites.length) return state.compiledWebsites;
                try {
                    const out = [];
                    for (let i = 0; i < websites.length; i++) {
                        const w = websites[i];
                        if (!w) continue;
                        const url = w.url == null ? '' : String(w.url);
                        const pattern = parseAutoUnfoldUrlPattern(url);
                        if (!pattern) continue;
                        out.push({
                            name: w.name == null ? '' : String(w.name),
                            url,
                            pattern,
                            fun: typeof w.fun === 'function' ? w.fun : null,
                            handles: Array.isArray(w.handles) ? w.handles : [],
                        });
                    }
                    state.compiledWebsites = out;
                } catch (e) {
                    state.compiledWebsites = [];
                    state.compiledError = String(e && e.message ? e.message : e);
                    debugLog('autoUnfoldCompile', { ok: false, reason: state.compiledError }, 'WARN');
                }
                if (!state.compiledWebsites.length && !state.compiledError) {
                    state.compiledError = 'æ— å¯ç”¨ç«™ç‚¹è§„åˆ™';
                    debugLog('autoUnfoldCompile', { ok: false, reason: state.compiledError }, 'WARN');
                } else {
                    debugLog('autoUnfoldCompile', { ok: true, count: state.compiledWebsites.length }, 'DEBUG');
                }
                return state.compiledWebsites;
            }

            function getAutoUnfoldCandidatesForLocation(compiledWebsites) {
                const state = getAutoUnfoldState();
                const host = String(getCurrentHost() || '').toLowerCase();
                const path = `${location.pathname || ''}${location.search || ''}${location.hash || ''}`;
                const key = `${host}|${path}`;
                if (state.candidatesKey === key && Array.isArray(state.candidates)) return state.candidates;
                const list = Array.isArray(compiledWebsites) ? compiledWebsites : [];
                const candidates = [];
                for (let i = 0; i < list.length; i++) {
                    const site = list[i];
                    if (!site) continue;
                    if (matchAutoUnfoldPattern(site.pattern, host, path)) candidates.push(site);
                }
                state.candidatesKey = key;
                state.candidates = candidates;
                debugLog('autoUnfoldCandidates', { host, count: candidates.length }, 'DEBUG');
                return candidates;
            }

            function stopAutoUnfold() {
                if (!autoUnfoldStop) return;
                try {
                    autoUnfoldStop();
                } catch (e) {}
                autoUnfoldStop = null;
            }

            function applyAutoUnfoldHandlesOnce(candidates) {
                const list = Array.isArray(candidates) ? candidates : [];
                const queryCache = new Map();
                const queryAll = (selector) => {
                    if (queryCache.has(selector)) return queryCache.get(selector);
                    try {
                        const out = document.querySelectorAll(selector);
                        queryCache.set(selector, out);
                        return out;
                    } catch (e) {
                        queryCache.set(selector, null);
                        return null;
                    }
                };
                const applyToElement = (el, type, handle) => {
                    if (type === 'display') {
                        el.style.display = 'none';
                        return true;
                    }
                    if (type === 'height') {
                        el.style.setProperty('height', 'unset', 'important');
                        el.style.setProperty('min-height', 'unset', 'important');
                        el.style.setProperty('max-height', 'unset', 'important');
                        return true;
                    }
                    if (type === 'overflow') {
                        el.style.setProperty('overflow', 'unset', 'important');
                        return true;
                    }
                    if (type === 'classlist') {
                        const remove = handle.remove == null ? '' : String(handle.remove);
                        if (!remove) return false;
                        el.classList.remove(remove);
                        return true;
                    }
                    if (type === 'click') {
                        if (el.getAttribute('opened') === 'yes') return false;
                        try {
                            el.click();
                        } catch (e) {}
                        try {
                            el.setAttribute('opened', 'yes');
                        } catch (e2) {}
                        return true;
                    }
                    try {
                        el.click();
                    } catch (e) {}
                    return true;
                };
                let matchedSites = 0;
                let matchedHandles = 0;
                let affected = 0;
                for (let i = 0; i < list.length; i++) {
                    const website = list[i];
                    if (!website) continue;
                    matchedSites++;
                    try {
                        if (typeof website.fun === 'function') website.fun();
                    } catch (e) {
                        const url = website.url == null ? '' : String(website.url);
                        debugLog('autoUnfoldFunError', { name: website.name, url, msg: String(e && e.message ? e.message : e) }, 'WARN');
                    }
                    const handles = website.handles;
                    if (!Array.isArray(handles) || !handles.length) continue;
                    for (let j = 0; j < handles.length; j++) {
                        const handle = handles[j];
                        if (!handle) continue;
                        const selector = handle.item == null ? '' : String(handle.item);
                        if (!selector) continue;
                        const nodeList = queryAll(selector);
                        if (!nodeList || !nodeList.length) continue;
                        matchedHandles++;
                        const type = handle.type == null ? '' : String(handle.type).toLowerCase();
                        for (let k = 0; k < nodeList.length; k++) {
                            const el = nodeList[k];
                            if (!(el instanceof Element)) continue;
                            if (applyToElement(el, type, handle)) affected++;
                        }
                    }
                }
                return { matchedSites, matchedHandles, affected };
            }

            function startAutoUnfold() {
                if (!isTopWindow()) return;
                if (autoUnfoldStop) return;
                const state = getAutoUnfoldState();
                const intervalMs = (() => {
                    const n = Number(settings.autoUnfoldInterval);
                    if (!Number.isFinite(n)) return 100;
                    return Math.min(2000, Math.max(30, Math.floor(n)));
                })();
                const maxTicks = (() => {
                    const n = Number(settings.autoUnfoldMaxTicks);
                    if (!Number.isFinite(n)) return 100;
                    return Math.min(500, Math.max(10, Math.floor(n)));
                })();
                const compiled = getAutoUnfoldCompiledWebsites();
                if (!compiled.length) return;
                const candidates = getAutoUnfoldCandidatesForLocation(compiled);
                if (!candidates.length) return;
                state.ticks = 0;
                state.startedAt = Date.now();
                const maybeShowAutoUnfoldTip = (stats) => {
                    if (!stats) return;
                    if (!stats.affected && !stats.matchedHandles) return;
                    const key = String(state.candidatesKey || '');
                    if (!key) return;
                    const now = Date.now();
                    if (state.tipKey === key && state.tipAt && now - state.tipAt < 20000) return;
                    state.tipKey = key;
                    state.tipAt = now;
                    showPassiveTip('é˜…è¯»å¢å¼ºï¼šè‡ªåŠ¨å±•å¼€å·²ç”Ÿæ•ˆ');
                };
                const interval = setInterval(() => {
                    if (++state.ticks >= maxTicks) {
                        stopAutoUnfold();
                        debugLog('autoUnfoldDone', { ticks: state.ticks, ms: Date.now() - state.startedAt }, 'INFO');
                        return;
                    }
                    const curCandidates = getAutoUnfoldCandidatesForLocation(compiled);
                    const stats = applyAutoUnfoldHandlesOnce(curCandidates);
                    maybeShowAutoUnfoldTip(stats);
                }, intervalMs);
                state.intervalId = interval;
                autoUnfoldStop = () => {
                    try {
                        clearInterval(interval);
                    } catch (e) {}
                    state.intervalId = 0;
                };
                debugLog('autoUnfoldStart', { ms: state.startedAt, url: location.href, intervalMs, maxTicks, candidates: candidates.length }, 'INFO');
            }

            function applyAutoUnfold(active) {
                if (!active) return stopAutoUnfold();
                startAutoUnfold();
            }

            function isZhihuHost(host) {
                const h = String(host || '').trim().toLowerCase();
                if (!h) return false;
                return h === 'zhihu.com' || h.endsWith('.zhihu.com');
            }

            function isJuejinHost(host) {
                const h = String(host || '').trim().toLowerCase();
                if (!h) return false;
                return h === 'juejin.cn' || h.endsWith('.juejin.cn') || h === 'juejin.im' || h.endsWith('.juejin.im');
            }

            function isBilibiliHost(host) {
                const h = String(host || '').trim().toLowerCase();
                if (!h) return false;
                return h === 'bilibili.com' || h.endsWith('.bilibili.com');
            }

            function isCsdnContentHost(host) {
                const h = String(host || '').trim().toLowerCase();
                if (!h) return false;
                if (h === 'link.csdn.net') return false;
                return h === 'csdn.net' || h.endsWith('.csdn.net');
            }

            function isBaiduHost(host) {
                const h = String(host || '').trim().toLowerCase();
                if (!h) return false;
                return h === 'baidu.com' || h.endsWith('.baidu.com');
            }

            function isTiebaHost(host) {
                const h = String(host || '').trim().toLowerCase();
                if (!h) return false;
                return h === 'tieba.baidu.com' || h.endsWith('.tieba.baidu.com');
            }

            const ZHIHU_LOGIN_POPUP_CSS = '.MobileModal-wrapper,.OpenInAppButton{display:none !important;}';

            const CSDN_LOGIN_POPUP_CSS = ['.passport-login-container,.passport-login-container-mask{display:none !important;}', '.passport-login-tip-container{display:none !important;}'].join('\n');

            const TIEBA_LOGIN_POPUP_CSS = [
                '#passport-login-pop,.passport-login-pop,.passport-login-dialog{display:none !important;}',
                '.tang-pass-pop,.tang-pass-pop-mask,.tang-pass-login,.tang-pass-login-mask,.tang-passport{display:none !important;}',
                '.dialogJ,.dialogJ-mask,.j_passport,.j_passport_pop,.j_smart_login{display:none !important;}',
                '.tieba-custom-pass-login,.tieba-login-background{display:none !important;}',
                '.passport-login-pop-mask,.passport-login-dialog-mask,.passport-login-mask,.passport-mask{display:none !important;}',
                '.passport-login-pop-mask,.passport-login-dialog-mask,.passport-login-mask,.passport-mask,.tang-pass-pop-mask,.tang-pass-login-mask,.dialogJ-mask,.tieba-login-background{pointer-events:none !important;}',
                'iframe[src*="passport.baidu.com"]{display:none !important;visibility:hidden !important;pointer-events:none !important;}',
            ].join('\n');

            const LOGIN_POPUP_BYPASS_RULES = [
                {
                    name: 'çŸ¥ä¹',
                    matchHost: isZhihuHost,
                    css: ZHIHU_LOGIN_POPUP_CSS,
                    selectors: ['.MobileModal-wrapper', '.OpenInAppButton', '.signFlowModal', '.SignFlowModal', '.Modal-wrapper', '.Modal-backdrop', '.LoginModal', '.LoginDialog'],
                    cssOnly: false,
                },
                {
                    name: 'æ˜é‡‘',
                    matchHost: isJuejinHost,
                    css: ['#juejin-auth-modal,#juejin-login-modal,.auth-modal-box,.auth-modal-mask,.auth-modal,.passport-modal{display:none !important;}'].join('\n'),
                    cssOnly: true,
                },
                {
                    name: 'B ç«™',
                    matchHost: isBilibiliHost,
                    css: ['.bili-mini-mask,.bili-mini-login{display:none !important;}'].join('\n'),
                    cssOnly: true,
                },
                {
                    name: 'CSDN',
                    matchHost: isCsdnContentHost,
                    css: CSDN_LOGIN_POPUP_CSS,
                    cssOnly: true,
                },
                {
                    name: 'ç™¾åº¦è´´å§',
                    matchHost: isTiebaHost,
                    css: TIEBA_LOGIN_POPUP_CSS,
                    selectors: [
                        '#passport-login-pop',
                        '.passport-login-pop',
                        '.passport-login-dialog',
                        '.passport-login-pop-mask',
                        '.passport-login-dialog-mask',
                        '.passport-login-mask',
                        '.tieba-custom-pass-login',
                        '.tieba-login-background',
                        '.tang-pass-pop',
                        '.tang-pass-pop-mask',
                        '.tang-pass-login',
                        '.tang-pass-login-mask',
                        '.tang-passport',
                        '.dialogJ',
                        '.dialogJ-mask',
                        '.j_passport',
                        '.j_passport_pop',
                        '.j_smart_login',
                        'iframe[src*="passport.baidu.com"]',
                        'iframe[src*="passport.baidu.com/passApi"]',
                    ],
                    observeAttributes: true,
                    cssOnly: false,
                },
                {
                    name: 'ç™¾åº¦',
                    matchHost: isBaiduHost,
                    css: '',
                    cssOnly: false,
                },
            ];

            function resolveLoginPopupBypassRule(host) {
                const h = String(host || '').trim().toLowerCase();
                for (let i = 0; i < LOGIN_POPUP_BYPASS_RULES.length; i++) {
                    const r = LOGIN_POPUP_BYPASS_RULES[i];
                    if (!r) continue;
                    try {
                        if (typeof r.matchHost === 'function' && r.matchHost(h)) return r;
                    } catch (e) {}
                }
                return null;
            }

            function stopLoginPopupBypass() {
                if (!loginPopupBypassStop) return;
                try {
                    loginPopupBypassStop();
                } catch (e) {}
                loginPopupBypassStop = null;
            }

            function startLoginPopupBypass() {
                if (!isTopWindow()) return;
                if (loginPopupBypassStop) return;
                const host = getCurrentHost();
                const isZhihu = isZhihuHost(host);
                const isTieba = isTiebaHost(host);
                const styleId = 'newtab-open-links-login-bypass-style';
                const rule = resolveLoginPopupBypassRule(host);
                const cssOnly = Boolean(rule && rule.cssOnly);
                const css = rule && rule.css ? String(rule.css || '').trim() : '';
                if (css) upsertStyleText(styleId, css);
                if (!rule && !isZhihu && !isTieba) {
                    try {
                        const cs = getComputedStyle(document.body);
                        const cs2 = getComputedStyle(document.documentElement);
                        const locked = (cs && cs.overflow === 'hidden') || (cs2 && cs2.overflow === 'hidden');
                        if (locked) {
                            document.documentElement && document.documentElement.style.setProperty('overflow', 'auto', 'important');
                            document.body && document.body.style.setProperty('overflow', 'auto', 'important');
                        }
                    } catch (e) {}
                    showPassiveTip('æ­¤ç«™æœªé€‚é…â€œéšè—ç™»å½•é®æŒ¡â€ï¼Œå·²å°è¯•æ¢å¤æ»šåŠ¨', 'warn');
                    debugLog('loginBypass', { ok: false, reason: 'unsupportedSite', host }, 'INFO');
                    loginPopupBypassStop = () => {};
                    return;
                }

                const isScrollLocked = () => {
                    try {
                        const cs = window.getComputedStyle ? getComputedStyle(document.body) : null;
                        if (cs && cs.overflow === 'hidden') return true;
                    } catch (e) {}
                    try {
                        const cs2 = window.getComputedStyle ? getComputedStyle(document.documentElement) : null;
                        if (cs2 && cs2.overflow === 'hidden') return true;
                    } catch (e2) {}
                    return false;
                };

                const healScroll = () => {
                    try {
                        if (document.documentElement) {
                            document.documentElement.style.setProperty('overflow', 'auto', 'important');
                            document.documentElement.style.setProperty('height', 'auto', 'important');
                        }
                    } catch (e) {}
                    try {
                        if (document.body) {
                            document.body.style.setProperty('overflow', 'auto', 'important');
                            document.body.style.setProperty('height', 'auto', 'important');
                        }
                    } catch (e2) {}
                };

                const hasLoginSignals = (el) => {
                    if (!el || !(el instanceof Element)) return false;
                    try {
                        if (el.querySelector && el.querySelector('input[type="password"], input[autocomplete="current-password"], input[autocomplete="new-password"]')) return true;
                    } catch (e) {}
                    const id = String(el.id || '');
                    const cls = typeof el.className === 'string' ? el.className : '';
                    const hint = `${id} ${cls}`.slice(0, 300);
                    if (/login|signin|signup|register|passport|auth|modal|dialog|overlay|mask/i.test(hint)) return true;
                    let text = '';
                    try {
                        text = String(el.textContent || '').replace(/\s+/g, ' ').slice(0, 400);
                    } catch (e2) {}
                    if (isTieba && /ä¸‹è½½è´´å§|è´´å§\s*APP|æ‰“å¼€è´´å§|è¿›å…¥è´´å§|å»\s*APP|ç«‹å³æ³¨å†Œ|æ‰“å¼€\s*App/i.test(text)) return true;
                    return /ç™»å½•|æ³¨å†Œ|æ‰‹æœºå·|éªŒè¯ç |æ‰«ç |ç»§ç»­æµè§ˆ|Sign in|Log in|Register/i.test(text);
                };

                const hasBlockingText = (el) => {
                    if (!isTieba) return false;
                    if (!el || !(el instanceof Element)) return false;
                    let text = '';
                    try {
                        text = String(el.textContent || '').replace(/\s+/g, ' ').slice(0, 200);
                    } catch (e) {
                        text = '';
                    }
                    return /åŠ è½½ä¸­|æ­£åœ¨åŠ è½½|è¯·ç¨å€™|Loading|è½½å…¥ä¸­/i.test(text);
                };

                const isMaskLike = (el) => {
                    if (!isTieba) return false;
                    if (!el || !(el instanceof Element)) return false;
                    const id = String(el.id || '');
                    const cls = typeof el.className === 'string' ? el.className : '';
                    const hint = `${id} ${cls}`.slice(0, 220);
                    if (!/mask|backdrop|overlay|shade|cover|modal|dialog|pop/i.test(hint)) return false;
                    return true;
                };

                const isBigOverlay = (el) => {
                    if (!el || !(el instanceof Element)) return false;
                    let cs = null;
                    try {
                        cs = window.getComputedStyle ? getComputedStyle(el) : null;
                    } catch (e) {}
                    if (cs) {
                        if (cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0') return false;
                        const pos = String(cs.position || '');
                        if (pos !== 'fixed' && pos !== 'sticky' && !(isTieba && pos === 'absolute')) return false;
                    }
                    let rect;
                    try {
                        rect = el.getBoundingClientRect();
                    } catch (e2) {
                        return false;
                    }
                    const vw = Math.max(1, window.innerWidth || 1);
                    const vh = Math.max(1, window.innerHeight || 1);
                    return rect.width >= vw * 0.6 && rect.height >= vh * 0.6;
                };

                const hideEl = (el) => {
                    if (!el || !(el instanceof Element)) return false;
                    try {
                        if (el.getAttribute('data-newtab-pro-login-bypass') === '1') return false;
                    } catch (e) {}
                    try {
                        el.setAttribute('data-newtab-pro-login-bypass', '1');
                    } catch (e2) {}
                    try {
                        el.style.setProperty('display', 'none', 'important');
                        el.style.setProperty('visibility', 'hidden', 'important');
                        el.style.setProperty('pointer-events', 'none', 'important');
                    } catch (e3) {}
                    return true;
                };

                const healInteraction = () => {
                    if (!isTieba) return;
                    try {
                        if (document.documentElement) document.documentElement.style.setProperty('pointer-events', 'auto', 'important');
                    } catch (e) {}
                    try {
                        if (document.body) document.body.style.setProperty('pointer-events', 'auto', 'important');
                    } catch (e2) {}
                };

                let zhihuUserRequestedLogin = false;
                let zhihuClickBound = false;
                const onZhihuLoginClick = (e) => {
                    if (!isZhihu) return;
                    const t = e && e.target;
                    if (!t || !(t instanceof Element)) return;
                    let el = null;
                    try {
                        el = t.closest('a,button,[role="button"],[role="link"]');
                    } catch (e2) {
                        el = null;
                    }
                    if (!el) return;
                    let text = '';
                    try {
                        text = String(el.textContent || '').replace(/\s+/g, '').slice(0, 20);
                    } catch (e3) {
                        text = '';
                    }
                    if (!text) return;
                    if (/ç™»å½•|æ³¨å†Œ/.test(text)) zhihuUserRequestedLogin = true;
                };

                const findButtonByExactText = (root, exactText) => {
                    const r = root && (root.nodeType === 9 || root.nodeType === 1) ? root : null;
                    if (!r || !r.querySelectorAll) return null;
                    const wanted = String(exactText || '').trim();
                    if (!wanted) return null;
                    let list = null;
                    try {
                        list = r.querySelectorAll('button,[role="button"],a,[role="link"]');
                    } catch (e) {
                        list = null;
                    }
                    if (!list || !list.length) return null;
                    const limit = list.length > 200 ? 200 : list.length;
                    for (let i = 0; i < limit; i++) {
                        const el = list[i];
                        if (!el) continue;
                        let t = '';
                        try {
                            t = String(el.textContent || '').trim();
                        } catch (e2) {
                            t = '';
                        }
                        if (t === wanted) return el;
                    }
                    return null;
                };

                const tryZhihuCloseLoginModal = () => {
                    if (!isZhihu) return false;
                    let changed = false;
                    let modal = null;
                    try {
                        modal = document.querySelector('.signFlowModal,.SignFlowModal');
                    } catch (e) {
                        modal = null;
                    }
                    if (!modal) {
                        if (zhihuUserRequestedLogin) zhihuUserRequestedLogin = false;
                    } else if (!zhihuUserRequestedLogin) {
                        let btn = null;
                        try {
                            btn = modal.querySelector('.Button.Modal-closeButton.Button--plain');
                        } catch (e2) {
                            btn = null;
                        }
                        if (btn && typeof btn.click === 'function') {
                            try {
                                btn.click();
                                changed = true;
                            } catch (e3) {}
                        } else if (hideEl(modal)) {
                            changed = true;
                        }
                    }

                    const quickLoginBtn = findButtonByExactText(document, 'ç«‹å³ç™»å½•/æ³¨å†Œ');
                    if (quickLoginBtn && !zhihuUserRequestedLogin) {
                        let container = null;
                        try {
                            container =
                                quickLoginBtn.closest('[role="dialog"],[aria-modal="true"],.signFlowModal,.SignFlowModal') ||
                                (quickLoginBtn.parentElement && quickLoginBtn.parentElement.parentElement) ||
                                null;
                        } catch (e4) {
                            container = null;
                        }
                        if (container && hideEl(container)) changed = true;
                    }
                    return changed;
                };

                const tryTiebaHideAppOrLoginDialog = () => {
                    if (!isTieba) return false;
                    let changed = false;
                    const hit = (t) => /ä¸‹è½½è´´å§|è´´å§\s*APP|æ‰“å¼€è´´å§|è¿›å…¥è´´å§|å»\s*APP|ç«‹å³æ³¨å†Œ|ç™»å½•|æ³¨å†Œ/i.test(String(t || '').replace(/\s+/g, ''));
                    let nodes = null;
                    try {
                        nodes = document.querySelectorAll('a,button,[role="button"],[role="link"]');
                    } catch (e) {
                        nodes = null;
                    }
                    if (nodes && nodes.length) {
                        const limit = nodes.length > 260 ? 260 : nodes.length;
                        for (let i = 0; i < limit; i++) {
                            const el = nodes[i];
                            if (!el || el.nodeType !== 1) continue;
                            let t = '';
                            try {
                                t = String(el.textContent || '').slice(0, 40);
                            } catch (e2) {
                                t = '';
                            }
                            if (!t || !hit(t)) continue;
                            let container = null;
                            try {
                                container =
                                    el.closest('[role="dialog"],[aria-modal="true"],.dialogJ,.tang-pass-pop,.tang-pass-login,.passport-login-pop,.passport-login-dialog') || null;
                            } catch (e3) {
                                container = null;
                            }
                            if (container && !isScriptUiNode(container) && hideEl(container)) changed = true;
                            let p = el;
                            for (let d = 0; d < 9; d++) {
                                if (!p || !(p instanceof Element)) break;
                                if (p === document.body || p === document.documentElement) break;
                                if (!isScriptUiNode(p) && hasLoginSignals(p)) {
                                    let cs = null;
                                    try {
                                        cs = window.getComputedStyle ? getComputedStyle(p) : null;
                                    } catch (e4) {
                                        cs = null;
                                    }
                                    if (cs && (cs.position === 'fixed' || cs.position === 'absolute' || cs.position === 'sticky')) {
                                        if (hideEl(p)) changed = true;
                                        break;
                                    }
                                }
                                p = p.parentElement;
                            }
                        }
                    }
                    return changed;
                };

                const isScriptUiNode = (el) => {
                    if (!el || !(el instanceof Element)) return true;
                    try {
                        if (el.id === 'newtab-open-links-settings-panel') return true;
                        if (el.id === PASSIVE_TIP_ROOT_ID || el.id === GO_TB_UI_ID) return true;
                        if (typeof el.closest === 'function') {
                            if (el.closest('#newtab-open-links-settings-panel')) return true;
                            if (PASSIVE_TIP_ROOT_ID && el.closest('#' + PASSIVE_TIP_ROOT_ID)) return true;
                            if (GO_TB_UI_ID && el.closest('#' + GO_TB_UI_ID)) return true;
                        }
                    } catch (e) {}
                    return false;
                };

                const tryHideBlockingOverlays = () => {
                    let changed = false;
                    if (tryZhihuCloseLoginModal()) changed = true;
                    if (tryTiebaHideAppOrLoginDialog()) changed = true;
                    const matchedSelectors = rule && Array.isArray(rule.selectors) && rule.selectors.length ? rule.selectors : null;
                    const selectorsToHide = isZhihu && zhihuUserRequestedLogin ? ['.MobileModal-wrapper', '.OpenInAppButton'] : matchedSelectors;
                    if (selectorsToHide) {
                        for (let i = 0; i < selectorsToHide.length; i++) {
                            const sel = selectorsToHide[i];
                            if (!sel) continue;
                            let list = null;
                            try {
                                list = document.querySelectorAll(sel);
                            } catch (e) {
                                list = null;
                            }
                            if (!list || !list.length) continue;
                            const limit = list.length > 30 ? 30 : list.length;
                            for (let j = 0; j < limit; j++) {
                                const el = list[j];
                                if (!el || el.nodeType !== 1) continue;
                                if (isScriptUiNode(el)) continue;
                                if (hideEl(el)) changed = true;
                            }
                        }
                    }
                    if (!isZhihu || !zhihuUserRequestedLogin) {
                        if (isTieba) {
                            try {
                                const overlayish = document.querySelectorAll(
                                    'div[class*="mask" i],div[class*="modal" i],div[class*="dialog" i],div[class*="pop" i],div[id*="mask" i],div[id*="modal" i],div[id*="dialog" i],div[id*="pop" i],section[class*="mask" i],section[class*="modal" i],section[class*="dialog" i],section[class*="pop" i]'
                                );
                                const limit = overlayish.length > 120 ? 120 : overlayish.length;
                                for (let i = 0; i < limit; i++) {
                                    const el = overlayish[i];
                                    if (!el || el.nodeType !== 1) continue;
                                    if (isScriptUiNode(el)) continue;
                                    const big = isBigOverlay(el);
                                    const maskLike = isMaskLike(el);
                                    if (maskLike && big) {
                                        if (hideEl(el)) changed = true;
                                        continue;
                                    }
                                    if (!big) continue;
                                    if (!hasLoginSignals(el) && !hasBlockingText(el)) continue;
                                    if (hideEl(el)) changed = true;
                                }
                            } catch (e) {}
                        }
                        const body = document.body;
                        if (body && body.children && body.children.length) {
                            const list = body.children;
                            const limit = list.length > 200 ? 200 : list.length;
                            for (let i = 0; i < limit; i++) {
                                const el = list[i];
                                if (!el || el.nodeType !== 1) continue;
                                if (isScriptUiNode(el)) continue;
                                if (!isBigOverlay(el)) continue;
                                if (!hasLoginSignals(el)) continue;
                                if (hideEl(el)) changed = true;
                            }
                        }
                        try {
                            const dialogs = document.querySelectorAll('[role="dialog"],[aria-modal="true"]');
                            const limit = dialogs.length > 30 ? 30 : dialogs.length;
                            for (let i = 0; i < limit; i++) {
                                const el = dialogs[i];
                                if (isScriptUiNode(el)) continue;
                                if (!isBigOverlay(el)) continue;
                                if (!hasLoginSignals(el)) continue;
                                if (hideEl(el)) changed = true;
                            }
                        } catch (e) {}
                    }
                    if (changed) {
                        lastEffectAt = Date.now();
                        if (!tipAt || Date.now() - tipAt > 15000) {
                            tipAt = Date.now();
                            showPassiveTip('å·²å°è¯•éšè—ç™»å½•é®æŒ¡å±‚');
                        }
                    }
                    if (isScrollLocked()) {
                        healScroll();
                        lastEffectAt = Date.now();
                    }
                    if (isTieba) healInteraction();
                };

                let overlayObserver = null;
                let lockObserver = null;
                let scheduled = false;
                let rafId = 0;
                let timeoutId = 0;
                let lastRunAt = 0;
                let lastEffectAt = Date.now();
                let tipAt = 0;
                let watchdogTimer = 0;
                const startedAt = Date.now();

                const releaseObservers = () => {
                    if (rafId) {
                        try {
                            cancelAnimationFrame(rafId);
                        } catch (e) {}
                    }
                    rafId = 0;
                    if (timeoutId) {
                        try {
                            clearTimeout(timeoutId);
                        } catch (e2) {}
                    }
                    timeoutId = 0;
                    scheduled = false;
                    if (watchdogTimer) {
                        try {
                            clearTimeout(watchdogTimer);
                        } catch (e3) {}
                    }
                    watchdogTimer = 0;
                    try {
                        if (overlayObserver) overlayObserver.disconnect();
                    } catch (e4) {}
                    overlayObserver = null;
                    try {
                        if (lockObserver) lockObserver.disconnect();
                    } catch (e5) {}
                    lockObserver = null;
                    if (isZhihu && zhihuClickBound) {
                        try {
                            document.removeEventListener('click', onZhihuLoginClick, true);
                        } catch (e6) {}
                        zhihuClickBound = false;
                    }
                };

                const scheduleTryHide = () => {
                    if (scheduled) return;
                    scheduled = true;
                    const run = () => {
                        scheduled = false;
                        rafId = 0;
                        timeoutId = 0;
                        const now = Date.now();
                        const delta = now - lastRunAt;
                        if (delta < 120) {
                            try {
                                timeoutId = setTimeout(scheduleTryHide, 120 - delta);
                            } catch (e) {
                                timeoutId = 0;
                            }
                            return;
                        }
                        lastRunAt = now;
                        tryHideBlockingOverlays();
                    };
                    if (typeof requestAnimationFrame === 'function') {
                        try {
                            rafId = requestAnimationFrame(run);
                            return;
                        } catch (e) {}
                    }
                    try {
                        timeoutId = setTimeout(run, 0);
                    } catch (e2) {
                        timeoutId = 0;
                    }
                };

                const startObservers = () => {
                    scheduleTryHide();
                    try {
                        const root = document.body || document.documentElement || document;
                        const observeAttributes = Boolean(rule && rule.observeAttributes);
                        const config =
                            isZhihu || observeAttributes
                                ? { childList: true, subtree: true, attributes: true, attributeFilter: ['style', 'class', 'hidden', 'aria-hidden'] }
                                : { childList: true, subtree: true };
                        overlayObserver = MutationRegistry.observe(root, config, () => {
                            scheduleTryHide();
                        });
                    } catch (e) {}
                };

                try {
                    lockObserver = new MutationObserver(() => {
                        if (isScrollLocked()) {
                            healScroll();
                            lastEffectAt = Date.now();
                        }
                    });
                    if (document.body) lockObserver = MutationRegistry.observe(document.body, { attributes: true, attributeFilter: ['style', 'class'] }, () => {
                        if (isScrollLocked()) {
                            healScroll();
                            lastEffectAt = Date.now();
                        }
                    });
                    if (document.documentElement) lockObserver = MutationRegistry.observe(document.documentElement, { attributes: true, attributeFilter: ['style', 'class'] }, () => {
                        if (isScrollLocked()) {
                            healScroll();
                            lastEffectAt = Date.now();
                        }
                    });
                } catch (e2) {}

                if (isZhihu && !zhihuClickBound) {
                    zhihuClickBound = true;
                    try {
                        EventRegistry.add(document, 'click', onZhihuLoginClick, true);
                    } catch (e3) {
                        zhihuClickBound = false;
                    }
                }

                if (!cssOnly) startObservers();
                if (isScrollLocked()) {
                    healScroll();
                    lastEffectAt = Date.now();
                }

                const watchdog = () => {
                    watchdogTimer = 0;
                    const now = Date.now();
                    const elapsed = now - startedAt;
                    const minRunMs = 5000;
                    const maxRunMs = isZhihu ? 10 * 60 * 1000 : cssOnly ? 20000 : 15000;
                    const stable = !isZhihu && elapsed >= minRunMs && now - lastEffectAt >= 2500 && !isScrollLocked();
                    const expired = !isZhihu && elapsed >= maxRunMs;
                    if (stable || expired) {
                        releaseObservers();
                        debugLog('loginBypassStopObserver', { reason: stable ? 'stable' : 'timeout', ms: elapsed, url: location.href }, 'INFO');
                        return;
                    }
                    try {
                        watchdogTimer = setTimeout(watchdog, 900);
                    } catch (e) {
                        watchdogTimer = 0;
                    }
                };
                try {
                    watchdogTimer = setTimeout(watchdog, 900);
                } catch (e) {
                    watchdogTimer = 0;
                }

                loginPopupBypassStop = () => {
                    releaseObservers();
                    removeElementById(styleId);
                };
            }

            function applyLoginPopupBypass(active) {
                if (!active) return stopLoginPopupBypass();
                const host = getCurrentHost();
                const ignoredSites = readLoginPopupBypassIgnoredSites();
                if (host && ignoredSites.indexOf(host) !== -1) return stopLoginPopupBypass();
                startLoginPopupBypass();
            }

            function isCsdnHost(host) {
                const h = String(host || '').toLowerCase();
                if (!h) return false;
                return h === 'csdn.net' || h.endsWith('.csdn.net');
            }

            function stopCsdnLoginJumpGuard() {
                if (!csdnLoginJumpGuardStop) return;
                try {
                    csdnLoginJumpGuardStop();
                } catch (e) {}
                csdnLoginJumpGuardStop = null;
            }

            function startCsdnLoginJumpGuard() {
                if (!isTopWindow()) return;
                if (csdnLoginJumpGuardStop) return;
                const host = getCurrentHost();
                if (!isCsdnHost(host) || host === 'link.csdn.net') return;

                const LAST_URL_KEY = 'newtab-pro-csdn-last-url';
                const LAST_URL_AT_KEY = 'newtab-pro-csdn-last-url-at';
                const LAST_GESTURE_AT_KEY = 'newtab-pro-csdn-last-gesture-at';

                const isPassportLoginUrl = (href) => {
                    let u;
                    try {
                        u = new URL(String(href || ''), location.href);
                    } catch (e) {
                        return false;
                    }
                    const h = String(u.hostname || '').toLowerCase();
                    if (h !== 'passport.csdn.net') return false;
                    const p = String(u.pathname || '');
                    if (!p.startsWith('/login')) return false;
                    const code = String(u.searchParams.get('code') || '').toLowerCase();
                    return code === 'applets';
                };

                const now = Date.now();
                if (host !== 'passport.csdn.net') {
                    try {
                        GM_setValue(LAST_URL_KEY, String(location.href || ''));
                        GM_setValue(LAST_URL_AT_KEY, now);
                    } catch (e) {}
                } else {
                    try {
                        const lastUrl = String(GM_getValue(LAST_URL_KEY, '') || '');
                        const lastAt = Number(GM_getValue(LAST_URL_AT_KEY, 0) || 0);
                        const lastGestureAt = Number(GM_getValue(LAST_GESTURE_AT_KEY, 0) || 0);
                        const recentEnough = lastUrl && Number.isFinite(lastAt) && now - lastAt >= 0 && now - lastAt <= 30000;
                        const notUserInitiated = !Number.isFinite(lastGestureAt) || now - lastGestureAt > 1200;
                        const refOk = lastUrl && normalizeTipUrl(document.referrer || '') === normalizeTipUrl(lastUrl);
                        if (recentEnough && notUserInitiated && refOk && isPassportLoginUrl(location.href)) {
                            showPassiveTip('CSDNï¼šå·²è¿”å›æ–‡ç« é¡µ');
                            try {
                                location.replace(lastUrl);
                            } catch (e) {
                                try {
                                    location.href = lastUrl;
                                } catch (e2) {}
                            }
                            csdnLoginJumpGuardStop = () => {};
                            return;
                        }
                    } catch (e) {}
                }

                let lastGestureAt = 0;
                let lastPersistAt = 0;
                const markGesture = () => {
                    const t = Date.now();
                    lastGestureAt = t;
                    if (t - lastPersistAt < 400) return;
                    lastPersistAt = t;
                    try {
                        GM_setValue(LAST_GESTURE_AT_KEY, t);
                    } catch (e) {}
                };

                const onGesture = () => markGesture();
                document.addEventListener('click', onGesture, true);
                document.addEventListener('keydown', onGesture, true);
                document.addEventListener('pointerdown', onGesture, true);

                const shouldBlock = (href) => {
                    if (!href) return false;
                    if (lastGestureAt && Date.now() - lastGestureAt <= 1200) return false;
                    return isPassportLoginUrl(href);
                };

                const origOpen = typeof window.open === 'function' ? window.open.bind(window) : null;
                const origAssign = location && typeof location.assign === 'function' ? location.assign.bind(location) : null;
                const origReplace = location && typeof location.replace === 'function' ? location.replace.bind(location) : null;

                const patchOpen = () => {
                    if (!origOpen) return;
                    try {
                        window.open = function(url, target, features) {
                            if (shouldBlock(url)) {
                                showPassiveTip('CSDNï¼šå·²æ‹¦æˆªå¼ºåˆ¶ç™»å½•è·³è½¬');
                                debugLog('csdnBlockLoginJump', { url: String(url || ''), from: location.href }, 'WARN');
                                return null;
                            }
                            return origOpen(url, target, features);
                        };
                    } catch (e) {}
                };

                const patchLocation = () => {
                    if (origAssign) {
                        try {
                            location.assign = function(url) {
                                if (shouldBlock(url)) {
                                    showPassiveTip('CSDNï¼šå·²æ‹¦æˆªå¼ºåˆ¶ç™»å½•è·³è½¬');
                                    debugLog('csdnBlockLoginJump', { url: String(url || ''), from: location.href, method: 'assign' }, 'WARN');
                                    return;
                                }
                                return origAssign(url);
                            };
                        } catch (e) {}
                    }
                    if (origReplace) {
                        try {
                            location.replace = function(url) {
                                if (shouldBlock(url)) {
                                    showPassiveTip('CSDNï¼šå·²æ‹¦æˆªå¼ºåˆ¶ç™»å½•è·³è½¬');
                                    debugLog('csdnBlockLoginJump', { url: String(url || ''), from: location.href, method: 'replace' }, 'WARN');
                                    return;
                                }
                                return origReplace(url);
                            };
                        } catch (e2) {}
                    }
                };

                patchOpen();
                patchLocation();

                csdnLoginJumpGuardStop = () => {
                    try {
                        document.removeEventListener('click', onGesture, true);
                        document.removeEventListener('keydown', onGesture, true);
                        document.removeEventListener('pointerdown', onGesture, true);
                    } catch (e) {}
                    try {
                        if (origOpen) window.open = origOpen;
                    } catch (e2) {}
                    try {
                        if (origAssign) location.assign = origAssign;
                    } catch (e3) {}
                    try {
                        if (origReplace) location.replace = origReplace;
                    } catch (e4) {}
                };
            }

            function applyCsdnLoginJumpGuard(active) {
                if (!Boolean(active)) return stopCsdnLoginJumpGuard();
                startCsdnLoginJumpGuard();
            }

            function stopCsdnStrongCopy() {
                if (!csdnStrongCopyStop) return;
                try {
                    csdnStrongCopyStop();
                } catch (e) {}
                csdnStrongCopyStop = null;
                if (csdnClipboardBypassStop) {
                    try { csdnClipboardBypassStop(); } catch (e) {}
                    csdnClipboardBypassStop = null;
                }
            }

            function stopCsdnCleanPage() {
                if (!csdnCleanPageStop) return;
                try {
                    csdnCleanPageStop();
                } catch (e) {}
                csdnCleanPageStop = null;
                csdnCleanPageCssSig = '';
            }

            function buildCsdnCleanPageCss(currentSettings) {
                const s = currentSettings && typeof currentSettings === 'object' ? currentSettings : settings;
                const rules = [];
                const push = (enabled, css) => {
                    if (!enabled) return;
                    const v = String(css || '').trim();
                    if (v) rules.push(v);
                };
                push(
                    Boolean(s.csdnCleanHideTopToolbar),
                    [
                        '#csdn-toolbar{display:none !important;}',
                        '#toolBarBox{display:none !important;}',
                        '#toolbarBox{display:none !important;}',
                        '.csdn-toolbar{display:none !important;}',
                        'body #main, .margin_sides{margin-top:unset !important;padding-top:unset !important;}',
                        '#article .article_title{margin-top:.32rem !important;padding-top:unset !important;}',
                    ].join('\n')
                );
                push(Boolean(s.csdnCleanHideSideToolbar), ['.csdn-side-toolbar{display:none !important;}', '.left-toolbox{display:none !important;}'].join('\n'));
                push(Boolean(s.csdnCleanHideLoginPopup), CSDN_LOGIN_POPUP_CSS);
                push(
                    Boolean(s.csdnCleanHideRecommend),
                    ['.recommend-box{display:none !important;}', '.recommend-item-box{display:none !important;}', '.recommendNps{display:none !important;}', '#recommendNps{display:none !important;}'].join('\n')
                );
                push(
                    Boolean(s.csdnCleanHideRightAside),
                    [
                        '#asideNewArticle,#asideHotArticle,#asideCategory,#asideArchive,#asideProfile,#asideCustom{display:none !important;}',
                        '.blog_container_aside{display:none !important;}',
                        '#rightAside{display:none !important;}',
                    ].join('\n')
                );
                push(
                    Boolean(s.csdnCleanHideAds),
                    [
                        '.ad-box{display:none !important;}',
                        '.ad-wrap{display:none !important;}',
                        '.advertisement{display:none !important;}',
                        '.advert{display:none !important;}',
                        '.slide-ads{display:none !important;}',
                        '#kp_box{display:none !important;}',
                        '#asideAd{display:none !important;}',
                        '.blog-ad-box{display:none !important;}',
                        '.csdn-common-logo-ad{display:none !important;}',
                    ].join('\n')
                );
                push(
                    Boolean(s.csdnCenterContentEnabled),
                    [
                        '#content_views{max-width:980px !important;margin:0 auto !important;}',
                        '.article-content{max-width:980px !important;margin:0 auto !important;}',
                        '.blog-content-box{max-width:980px !important;margin:0 auto !important;}',
                        '#mainBox{max-width:980px !important;margin:0 auto !important;}',
                        '.blog_container .main{max-width:980px !important;margin:0 auto !important;}',
                        '.blog_container .container{max-width:980px !important;margin:0 auto !important;}',
                    ].join('\n')
                );
                return rules.join('\n').trim();
            }

            function startCsdnCleanPage() {
                if (!isTopWindow()) return;
                const host = getCurrentHost();
                if (!isCsdnHost(host) || host === 'link.csdn.net') return;
                const styleId = 'newtab-open-links-csdn-clean-style';
                const css = buildCsdnCleanPageCss(settings);
                if (!css) return stopCsdnCleanPage();
                if (css === csdnCleanPageCssSig && csdnCleanPageStop) return;
                upsertStyleText(styleId, css);
                csdnCleanPageStop = () => removeElementById(styleId);
                csdnCleanPageCssSig = css;
            }

            function applyCsdnCleanPage(active) {
                const host = getCurrentHost();
                const shouldEnable = Boolean(active) && isCsdnHost(host) && host !== 'link.csdn.net';
                if (!shouldEnable) return stopCsdnCleanPage();
                startCsdnCleanPage();
            }

            function stopBaiduSearchEnhance() {
                if (!baiduSearchEnhanceStop) return;
                try {
                    baiduSearchEnhanceStop();
                } catch (e) {}
                baiduSearchEnhanceStop = null;
                baiduSearchEnhanceCssSig = '';
                if (baiduPinOfficialStop) {
                    try {
                        baiduPinOfficialStop();
                    } catch (e2) {}
                    baiduPinOfficialStop = null;
                }
                if (baiduAiAutoExpandStop) {
                    try {
                        baiduAiAutoExpandStop();
                    } catch (e3) {}
                    baiduAiAutoExpandStop = null;
                }
                if (baiduPaginationPatchStop) {
                    try {
                        baiduPaginationPatchStop();
                    } catch (e4) {}
                    baiduPaginationPatchStop = null;
                }
                if (baiduRecommendListCleanupStop) {
                    try {
                        baiduRecommendListCleanupStop();
                    } catch (e5) {}
                    baiduRecommendListCleanupStop = null;
                }
            }

            function applyBaiduPaginationRuntime() {
                const host = getCurrentHost();
                const isSearchPage = host === 'www.baidu.com' && location && String(location.pathname || '') === '/s';
                let isDouble = false;
                try {
                    isDouble = Boolean(document.body && document.body.classList && document.body.classList.contains('double-column'));
                } catch (e0) {}

                const restore = () => {
                    const page = document.getElementById('page');
                    if (!page) return;
                    const spans = page.querySelectorAll('a.n .n-word_1TXWP[data-ntp-orig-text]');
                    if (!spans || !spans.length) return;
                    for (let i = 0; i < spans.length; i++) {
                        const el = spans[i];
                        if (!(el instanceof Element)) continue;
                        const orig = el.getAttribute('data-ntp-orig-text');
                        if (orig == null) continue;
                        try {
                            el.textContent = String(orig);
                        } catch (e1) {}
                        try {
                            el.removeAttribute('data-ntp-orig-text');
                        } catch (e2) {}
                    }
                };

                if (baiduPaginationPatchStop) {
                    try {
                        baiduPaginationPatchStop();
                    } catch (e3) {}
                    baiduPaginationPatchStop = null;
                }

                try {
                    restore();
                } catch (e4) {}

                if (!isSearchPage || !isDouble) return;

                let timerId = 0;
                const patchOnce = () => {
                    const page = document.getElementById('page');
                    if (!page) return;
                    const spans = page.querySelectorAll('a.n .n-word_1TXWP');
                    if (!spans || !spans.length) return;
                    for (let i = 0; i < spans.length; i++) {
                        const el = spans[i];
                        if (!(el instanceof Element)) continue;
                        let text = '';
                        try {
                            text = String(el.textContent || '').trim();
                        } catch (e0) {
                            text = '';
                        }
                        if (!text) continue;
                        if (text.includes('ä¸Šä¸€é¡µ')) {
                            try {
                                if (!el.hasAttribute('data-ntp-orig-text')) el.setAttribute('data-ntp-orig-text', text);
                            } catch (e1) {}
                            try {
                                el.textContent = '<';
                            } catch (e2) {}
                            continue;
                        }
                        if (text.includes('ä¸‹ä¸€é¡µ')) {
                            try {
                                if (!el.hasAttribute('data-ntp-orig-text')) el.setAttribute('data-ntp-orig-text', text);
                            } catch (e3) {}
                            try {
                                el.textContent = '>';
                            } catch (e4) {}
                            continue;
                        }
                    }
                };

                const schedule = () => {
                    if (timerId) return;
                    timerId = TimerRegistry.setTimeout(() => {
                        timerId = 0;
                        try {
                            patchOnce();
                        } catch (e) {}
                    }, 80);
                };

                schedule();
                const obsRoot = document.getElementById('page') || document.body;
                const obs = obsRoot ? MutationRegistry.observe(obsRoot, { childList: true, subtree: true }, schedule, 30 * 1000) : null;
                baiduPaginationPatchStop = () => {
                    try {
                        if (timerId) clearTimeout(timerId);
                    } catch (e1) {}
                    timerId = 0;
                    try {
                        if (obs) obs.disconnect();
                    } catch (e2) {}
                };
            }

            function applyBaiduRecommendListCleanupRuntime(active) {
                const host = getCurrentHost();
                const isSearchPage =
                    (host === 'www.baidu.com' || host === 'm.baidu.com') && location && String(location.pathname || '') === '/s';
                const on = Boolean(active);

                if (baiduRecommendListCleanupStop) {
                    try {
                        baiduRecommendListCleanupStop();
                    } catch (e1) {}
                    baiduRecommendListCleanupStop = null;
                }
                if (!on || !isSearchPage) return;

                const isHit = (el) => {
                    if (!(el instanceof Element)) return false;
                    if (el.id === 'content_left' || el === document.body || el === document.documentElement) return false;
                    const tpl = String(el.getAttribute('tpl') || '').trim();
                    if (tpl === 'recommend_list' || tpl === 'short_video') return true;
                    const mName = String(el.getAttribute('m-name') || '').trim();
                    if (mName && (mName.indexOf('recommend_list') !== -1 || mName.indexOf('short_video') !== -1)) return true;
                    const mu = String(el.getAttribute('mu') || '').trim();
                    if (mu && mu.indexOf('recommend_list.baidu.com') !== -1) return true;
                    const click = String(el.getAttribute('data-click') || '').trim();
                    if (mu && (mu.indexOf('secure.mydown.com') !== -1 || mu.indexOf('mydown.com') !== -1)) return true;
                    if (click && (click.indexOf('secure.mydown.com') !== -1 || click.indexOf('mydown.com') !== -1))
                        return true;
                    if (mu && mu.indexOf('/sf/vsearch?') !== -1) return true;
                    if (click && click.indexOf('/sf/vsearch?') !== -1) return true;
                    try {
                        const a = el.querySelector('a[href*="/sf/vsearch?"]');
                        if (a) return true;
                    } catch (e0) {}
                    return false;
                };

                const removeOnce = () => {
                    const root = document.getElementById('content_left') || document.body;
                    if (!root) return;
                    let first = null;
                    try {
                        first = root.querySelector(
                            'div[tpl="recommend_list"],div[m-name*="recommend_list"],div[mu*="recommend_list.baidu.com"],div[mu*="secure.mydown.com"],div[mu*="mydown.com"],div[data-click*="secure.mydown.com"],div[data-click*="mydown.com"],div[tpl="short_video"],div[m-name*="short_video"],div[mu*="/sf/vsearch?"],div[data-click*="/sf/vsearch?"]'
                        );
                    } catch (e00) {}
                    if (!first && !isHit(root)) return;
                    const queue = [];
                    if (isHit(root)) queue.push(root);
                    try {
                        const list = root.querySelectorAll(
                            'div[tpl="recommend_list"],div[m-name*="recommend_list"],div[mu*="recommend_list.baidu.com"],div[mu*="secure.mydown.com"],div[mu*="mydown.com"],div[data-click*="secure.mydown.com"],div[data-click*="mydown.com"],div[tpl="short_video"],div[m-name*="short_video"],div[mu*="/sf/vsearch?"],div[data-click*="/sf/vsearch?"]'
                        );
                        for (let i = 0; i < list.length; i++) {
                            const el = list[i];
                            if (isHit(el)) queue.push(el);
                        }
                    } catch (e0) {}
                    try {
                        const children = Array.from(root.children);
                        for (let i = 0; i < children.length; i++) {
                            const el = children[i];
                            if (!(el instanceof Element)) continue;
                            if (isHit(el)) queue.push(el);
                        }
                    } catch (e00) {}
                    for (let i = queue.length - 1; i >= 0; i--) {
                        const el = queue[i];
                        try {
                            el.style.setProperty('display', 'none', 'important');
                        } catch (e1) {}
                        try {
                            el.remove();
                        } catch (e2) {}
                    }
                };

                let scheduled = 0;
                const schedule = () => {
                    if (scheduled) return;
                    scheduled = TimerRegistry.setTimeout(() => {
                        scheduled = 0;
                        try {
                            removeOnce();
                        } catch (e) {}
                    }, 50);
                };

                schedule();
                const obsRoot = document.getElementById('content_left') || document.body;
                const obs = obsRoot ? MutationRegistry.observe(obsRoot, { childList: true, subtree: true }, schedule) : null;
                baiduRecommendListCleanupStop = () => {
                    try {
                        if (scheduled) clearTimeout(scheduled);
                    } catch (e3) {}
                    scheduled = 0;
                    try {
                        if (obs) obs.disconnect();
                    } catch (e4) {}
                };
            }

            function applyBaiduHideAiRuntime(active) {
                const on = Boolean(active);
                try {
                    const root = document.documentElement;
                    if (root && root.classList) root.classList.toggle(BAIDU_HIDE_AI_BODY_CLASS, on);
                } catch (e) {}
                try {
                    if (document.body && document.body.classList) document.body.classList.toggle(BAIDU_HIDE_AI_BODY_CLASS, on);
                } catch (e) {}
                try {
                    const btn = document.getElementById(BAIDU_AI_TOGGLE_ID);
                    if (btn) {
                        btn.setAttribute('data-on', on ? '1' : '0');
                        btn.setAttribute('aria-pressed', on ? 'true' : 'false');
                        btn.textContent = on ? 'AIï¼šå·²å±è”½' : 'AIï¼šå·²æ˜¾ç¤º';
                    }
                } catch (e2) {}
                try {
                    const panel = document.getElementById(BAIDU_FLOAT_PANEL_ID);
                    if (panel) {
                        const toggle = panel.querySelector('.ntp-baidu-toggle[data-role="ai"]');
                        if (toggle) toggle.classList.toggle('ntp-on', on);
                    }
                } catch (e3) {}
            }

            function applyBaiduDarkRuntime(active) {
                const on = Boolean(active);
                try {
                    const root = document.documentElement;
                    if (root && root.classList) root.classList.toggle(BAIDU_DARK_BODY_CLASS, on);
                } catch (e) {}
                try {
                    if (document.body && document.body.classList) document.body.classList.toggle(BAIDU_DARK_BODY_CLASS, on);
                } catch (e) {}
                try {
                    const panel = document.getElementById(BAIDU_FLOAT_PANEL_ID);
                    if (panel) {
                        const toggle = panel.querySelector('.ntp-baidu-toggle[data-role="dark"]');
                        if (toggle) toggle.classList.toggle('ntp-on', on);
                    }
                } catch (e2) {}
            }

            function applyBaiduAiAutoExpandRuntime(active) {
                const host = getCurrentHost();
                const isSearchPage = host === 'www.baidu.com' && location && String(location.pathname || '') === '/s';
                const on = Boolean(active);
                try {
                    const panel = document.getElementById(BAIDU_FLOAT_PANEL_ID);
                    if (panel) {
                        const toggle = panel.querySelector('.ntp-baidu-toggle[data-role="autoExpand"]');
                        if (toggle) toggle.classList.toggle('ntp-on', on);
                    }
                } catch (e0) {}
                if (baiduAiAutoExpandStop) {
                    try {
                        baiduAiAutoExpandStop();
                    } catch (e1) {}
                    baiduAiAutoExpandStop = null;
                }
                if (!isSearchPage) return;
                let timerId = 0;
                const tryAutoToggle = (expand) => {
                    const list = document.querySelectorAll(
                        'div[tpl="wenda_generate"],div[tpl="ai_ask"],div[tpl="ai_index"],.result-op[tpl="wenda_generate"],.result-op[tpl="ai_ask"],.result-op[tpl="ai_index"],div[m-name^="mirror-san/app/wenda_generate"],div[m-name^="mirror-san/app/ai_ask"]'
                    );
                    if (!list || !list.length) return;
                    for (let i = 0; i < list.length; i++) {
                        const card = list[i];
                        if (!(card instanceof Element)) continue;
                        if (expand && card.getAttribute('data-ntp-ai-auto-expanded') === '1') continue;
                        let clicked = false;
                        const foldTexts = card.querySelectorAll('.cos-fold-switch-text');
                        for (let j = 0; j < foldTexts.length; j++) {
                            const el = foldTexts[j];
                            if (!(el instanceof Element)) continue;
                            const text = String(el.textContent || '')
                                .replace(/\s+/g, '')
                                .trim();
                            if (!text) continue;
                            if (expand) {
                                if (!(text === 'å±•å¼€' || text.startsWith('å±•å¼€'))) continue;
                                const clickable = el.closest('.cos-fold-switch-context') || el.closest('button,[role="button"],a') || el;
                                try {
                                    clickable.click();
                                    clicked = true;
                                } catch (e) {}
                                break;
                            }
                            if (!expand) {
                                if (!(text === 'æ”¶èµ·' || text.startsWith('æ”¶èµ·'))) continue;
                                const clickable = el.closest('.cos-fold-switch-context') || el.closest('button,[role="button"],a') || el;
                                try {
                                    clickable.click();
                                    clicked = true;
                                } catch (e) {}
                                break;
                            }
                        }
                        if (!clicked) {
                            const clickables = card.querySelectorAll('button,a,[role="button"]');
                            for (let j = 0; j < clickables.length; j++) {
                                const el = clickables[j];
                                if (!(el instanceof Element)) continue;
                                const text = String(el.textContent || '')
                                    .replace(/\s+/g, '')
                                    .trim();
                                if (!text) continue;
                                if (expand && (text === 'å±•å¼€' || text.startsWith('å±•å¼€'))) {
                                    try {
                                        el.click();
                                        clicked = true;
                                    } catch (e) {}
                                    break;
                                }
                                if (!expand && (text === 'æ”¶èµ·' || text.startsWith('æ”¶èµ·'))) {
                                    try {
                                        el.click();
                                        clicked = true;
                                    } catch (e) {}
                                    break;
                                }
                            }
                        }
                        if (clicked) {
                            if (expand) {
                                try {
                                    card.setAttribute('data-ntp-ai-auto-expanded', '1');
                                } catch (e) {}
                            } else {
                                try {
                                    card.removeAttribute('data-ntp-ai-auto-expanded');
                                } catch (e) {}
                            }
                        }
                    }
                };

                if (!on || Boolean(settings.baiduHideAiAnswerEnabled)) {
                    try {
                        tryAutoToggle(false);
                    } catch (e2) {}
                    try {
                        TimerRegistry.setTimeout(() => {
                            try {
                                tryAutoToggle(false);
                            } catch (e3) {}
                        }, 420);
                    } catch (e4) {}
                    return;
                }

                const root = document.getElementById('content_left') || document.body;
                if (!root) return;
                const schedule = () => {
                    if (timerId) return;
                    timerId = TimerRegistry.setTimeout(() => {
                        timerId = 0;
                        try {
                            tryAutoToggle(true);
                        } catch (e) {}
                    }, 120);
                };
                schedule();
                const obs = MutationRegistry.observe(root, { childList: true, subtree: true }, schedule, 60 * 1000);
                baiduAiAutoExpandStop = () => {
                    try {
                        if (timerId) clearTimeout(timerId);
                    } catch (e2) {}
                    timerId = 0;
                    try {
                        if (obs) obs.disconnect();
                    } catch (e3) {}
                };
            }

            function applyBaiduLayoutRuntime(mode) {
                const normalized = String(mode || '').toLowerCase() === 'double' ? 'double' : 'single';
                settings.baiduLayoutMode = normalized;
                try {
                    setValue('baiduLayoutMode', normalized);
                } catch (e) {}
                const applyClass = () => {
                    try {
                        let applied = false;
                        const root = document.documentElement;
                        if (root && root.classList) {
                            root.classList.toggle('single-column', normalized === 'single');
                            root.classList.toggle('double-column', normalized === 'double');
                            applied = true;
                        }
                        const body = document.body;
                        if (body && body.classList) {
                            body.classList.toggle('single-column', normalized === 'single');
                            body.classList.toggle('double-column', normalized === 'double');
                            applied = true;
                        }
                        return applied;
                    } catch (e2) {
                        return false;
                    }
                };
                if (!applyClass()) {
                    let attempts = 0;
                    const tick = () => {
                        attempts++;
                        if (applyClass()) return;
                        if (attempts >= 60) return;
                        try {
                            TimerRegistry.setTimeout(tick, 50);
                        } catch (e3) {}
                    };
                    try {
                        TimerRegistry.setTimeout(tick, 0);
                    } catch (e4) {}
                    try {
                        document.addEventListener('DOMContentLoaded', tick, { once: true });
                    } catch (e5) {}
                }
                try {
                    const panel = document.getElementById(BAIDU_FLOAT_PANEL_ID);
                    if (panel) {
                        const toggle = panel.querySelector('.ntp-baidu-toggle[data-role="layout"]');
                        if (toggle) toggle.classList.toggle('ntp-on', normalized === 'double');
                    }
                } catch (e3) {}
                try {
                    applyBaiduPaginationRuntime();
                } catch (e4) {}
            }

            function removeBaiduFloatControls() {
                try {
                    if (baiduFloatControlsStop) {
                        try {
                            baiduFloatControlsStop();
                        } catch (e) {}
                        baiduFloatControlsStop = null;
                    }
                    const root = document.getElementById(BAIDU_FLOAT_ROOT_ID);
                    if (root && root.parentNode) root.parentNode.removeChild(root);
                } catch (e2) {}
            }

            function ensureBaiduFloatControls() {
                if (!document.body) return;
                try {
                    removeBaiduFloatControls();
                } catch (e0) {}
                const root = document.createElement('div');
                root.id = BAIDU_FLOAT_ROOT_ID;
                root.innerHTML =
                    '<button id="' + BAIDU_FLOAT_BTN_ID + '" type="button" aria-label="ç™¾åº¦æœç´¢è®¾ç½®">' +
                    '  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">' +
                    '    <path d="M12 8.5A3.5 3.5 0 1 0 12 15.5 3.5 3.5 0 0 0 12 8.5zm0-6.5a1 1 0 0 1 .98.8l.38 2.06a7.07 7.07 0 0 1 1.73 1l2.02-.78a1 1 0 0 1 1.2.45l1.5 2.6a1 1 0 0 1-.22 1.25l-1.64 1.32a6.9 6.9 0 0 1 0 2l1.64 1.32a1 1 0 0 1 .22 1.25l-1.5 2.6a1 1 0 0 1-1.2.45l-2.02-.78a7.07 7.07 0 0 1-1.73 1l-.38 2.06A1 1 0 0 1 12 24h-3a1 1 0 0 1-.98-.8l-.38-2.06a7.07 7.07 0 0 1-1.73-1l-2.02.78a1 1 0 0 1-1.2-.45l-1.5-2.6a1 1 0 0 1 .22-1.25L2.06 14a6.9 6.9 0 0 1 0-2L.42 10.68a1 1 0 0 1-.22-1.25l1.5-2.6a1 1 0 0 1 1.2-.45l2.02.78a7.07 7.07 0 0 1 1.73-1L8.02 2.8A1 1 0 0 1 9 2h3z" />' +
                    '  </svg>' +
                    '</button>' +
                    '<div id="' + BAIDU_FLOAT_PANEL_ID + '">' +
                    '  <div class="ntp-baidu-item">' +
                    '    <div class="ntp-baidu-label">' +
                    '      <span class="ntp-baidu-icon">ğŸŒ™</span><span>æ·±è‰²æ¨¡å¼</span>' +
                    '    </div>' +
                    '    <div class="ntp-baidu-toggle" data-role="dark"></div>' +
                    '  </div>' +
                    '  <div class="ntp-baidu-separator"></div>' +
                    '  <div class="ntp-baidu-item">' +
                    '    <div class="ntp-baidu-label">' +
                    '      <span class="ntp-baidu-icon">â˜·</span><span>åŒåˆ—å¸ƒå±€</span>' +
                    '    </div>' +
                    '    <div class="ntp-baidu-toggle" data-role="layout"></div>' +
                    '  </div>' +
                    '  <div class="ntp-baidu-separator"></div>' +
                    '  <div class="ntp-baidu-item">' +
                    '    <div class="ntp-baidu-label">' +
                    '      <span class="ntp-baidu-icon">ğŸ¤–</span><span>å±è”½AIå›ç­”</span>' +
                    '    </div>' +
                    '    <div class="ntp-baidu-toggle" data-role="ai"></div>' +
                    '  </div>' +
                    '  <div class="ntp-baidu-separator"></div>' +
                    '  <div class="ntp-baidu-item">' +
                    '    <div class="ntp-baidu-label">' +
                    '      <span class="ntp-baidu-icon">â¤µ</span><span>è‡ªåŠ¨å±•å¼€</span>' +
                    '    </div>' +
                    '    <div class="ntp-baidu-toggle" data-role="autoExpand"></div>' +
                    '  </div>' +
                    '</div>';
                const applyStoredPosition = () => {
                    if (!root) return;
                    let raw = '';
                    try {
                        raw = String(getValue(BAIDU_FLOAT_POSITION_KEY, '') || '').trim();
                    } catch (e) {
                        raw = '';
                    }
                    if (!raw) return;
                    const parts = raw.split(',');
                    if (!parts || parts.length !== 2) return;
                    let x = Number(parts[0]);
                    let y = Number(parts[1]);
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                    let vw = 0;
                    let vh = 0;
                    try {
                        vw = window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || 0;
                        vh = window.innerHeight || (document.documentElement && document.documentElement.clientHeight) || 0;
                    } catch (e2) {}
                    let rect = null;
                    try {
                        rect = root.getBoundingClientRect();
                    } catch (e3) {}
                    const width = rect ? rect.width : 0;
                    const height = rect ? rect.height : 0;
                    if (vw && width) {
                        const maxX = vw - width - 8;
                        if (x < 8) x = 8;
                        else if (x > maxX) x = maxX;
                    }
                    if (vh && height) {
                        const maxY = vh - height - 8;
                        if (y < 8) y = 8;
                        else if (y > maxY) y = maxY;
                    }
                    try {
                        root.style.left = x + 'px';
                        root.style.top = y + 'px';
                        root.style.right = 'auto';
                        root.style.bottom = 'auto';
                    } catch (e4) {}
                };
                try {
                    document.body.appendChild(root);
                } catch (e1) {
                    return;
                }
                applyStoredPosition();

                let open = false;
                const btn = document.getElementById(BAIDU_FLOAT_BTN_ID);
                const panel = document.getElementById(BAIDU_FLOAT_PANEL_ID);
                const darkToggle = panel && panel.querySelector('.ntp-baidu-toggle[data-role="dark"]');
                const layoutToggle = panel && panel.querySelector('.ntp-baidu-toggle[data-role="layout"]');
                const aiToggle = panel && panel.querySelector('.ntp-baidu-toggle[data-role="ai"]');
                const autoExpandToggle = panel && panel.querySelector('.ntp-baidu-toggle[data-role="autoExpand"]');
                let dragging = false;
                let dragOffsetX = 0;
                let dragOffsetY = 0;
                let lastX = 0;
                let lastY = 0;

                const setOpen = (value) => {
                    open = Boolean(value);
                    try {
                        if (root) root.classList.toggle('ntp-open', open);
                    } catch (e2) {}
                };

                const handleDragStart = (event) => {
                    if (!event || typeof event.button === 'number' && event.button !== 0) return;
                    const target = event.target;
                    if (!root || !target) return;
                    try {
                        if (typeof target.closest === 'function') {
                            const toggleEl = target.closest('.ntp-baidu-toggle');
                            if (toggleEl) return;
                        }
                    } catch (e) {}
                    try {
                        if (event.stopPropagation) event.stopPropagation();
                    } catch (e2) {}
                    try {
                        if (event.preventDefault) event.preventDefault();
                    } catch (e3) {}
                    let rect = null;
                    try {
                        rect = root.getBoundingClientRect();
                    } catch (e4) {}
                    const startX = event.clientX || 0;
                    const startY = event.clientY || 0;
                    dragOffsetX = rect ? startX - rect.left : 0;
                    dragOffsetY = rect ? startY - rect.top : 0;
                    lastX = rect ? rect.left : 0;
                    lastY = rect ? rect.top : 0;
                    dragging = true;
                };

                const handleDragMove = (event) => {
                    if (!dragging || !root) return;
                    const x = (event && event.clientX) || 0;
                    const y = (event && event.clientY) || 0;
                    let nextX = x - dragOffsetX;
                    let nextY = y - dragOffsetY;
                    let vw = 0;
                    let vh = 0;
                    try {
                        vw = window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || 0;
                        vh = window.innerHeight || (document.documentElement && document.documentElement.clientHeight) || 0;
                    } catch (e) {}
                    let rect = null;
                    try {
                        rect = root.getBoundingClientRect();
                    } catch (e2) {}
                    const width = rect ? rect.width : 0;
                    const height = rect ? rect.height : 0;
                    if (vw && width) {
                        const maxX = vw - width - 8;
                        if (nextX < 8) nextX = 8;
                        else if (nextX > maxX) nextX = maxX;
                    }
                    if (vh && height) {
                        const maxY = vh - height - 8;
                        if (nextY < 8) nextY = 8;
                        else if (nextY > maxY) nextY = maxY;
                    }
                    lastX = nextX;
                    lastY = nextY;
                    try {
                        root.style.left = nextX + 'px';
                        root.style.top = nextY + 'px';
                        root.style.right = 'auto';
                        root.style.bottom = 'auto';
                    } catch (e3) {}
                };

                const handleDragEnd = () => {
                    if (!dragging) return;
                    dragging = false;
                    try {
                        setValue(BAIDU_FLOAT_POSITION_KEY, String(lastX || 0) + ',' + String(lastY || 0));
                    } catch (e) {}
                };

                if (btn) {
                    EventRegistry.add(btn, 'click', (event) => {
                        try {
                            if (event && event.stopPropagation) event.stopPropagation();
                        } catch (e3) {}
                        setOpen(!open);
                    });
                }

                if (root) {
                    EventRegistry.add(root, 'mousedown', handleDragStart);
                    EventRegistry.add(document, 'mousemove', handleDragMove);
                    EventRegistry.add(document, 'mouseup', handleDragEnd);
                }

                EventRegistry.add(document, 'click', (event) => {
                    try {
                        const target = event && event.target;
                        if (!root || !root.contains(target)) setOpen(false);
                    } catch (e4) {}
                });

                if (darkToggle) {
                    EventRegistry.add(darkToggle, 'click', (event) => {
                        try {
                            if (event && event.stopPropagation) event.stopPropagation();
                        } catch (e5) {}
                        let next = false;
                        try {
                            next = !Boolean(getValue(BAIDU_FLOAT_DARK_KEY, false));
                            setValue(BAIDU_FLOAT_DARK_KEY, next);
                        } catch (e6) {}
                        applyBaiduDarkRuntime(next);
                    });
                }

                if (layoutToggle) {
                    EventRegistry.add(layoutToggle, 'click', (event) => {
                        try {
                            if (event && event.stopPropagation) event.stopPropagation();
                        } catch (e7) {}
                        const current = String(settings.baiduLayoutMode || '').toLowerCase() === 'double' ? 'double' : 'single';
                        const next = current === 'double' ? 'single' : 'double';
                        applyBaiduLayoutRuntime(next);
                    });
                }

                if (aiToggle) {
                    EventRegistry.add(aiToggle, 'click', (event) => {
                        try {
                            if (event && event.stopPropagation) event.stopPropagation();
                        } catch (e8) {}
                        const next = !Boolean(settings.baiduHideAiAnswerEnabled);
                        settings.baiduHideAiAnswerEnabled = next;
                        try {
                            setValue('baiduHideAiAnswerEnabled', next);
                        } catch (e9) {}
                        applyBaiduHideAiRuntime(next);
                        applyBaiduAiAutoExpandRuntime(Boolean(settings.baiduAiAutoExpandEnabled));
                    });
                }

                if (autoExpandToggle) {
                    EventRegistry.add(autoExpandToggle, 'click', (event) => {
                        try {
                            if (event && event.stopPropagation) event.stopPropagation();
                        } catch (e10) {}
                        const next = !Boolean(settings.baiduAiAutoExpandEnabled);
                        settings.baiduAiAutoExpandEnabled = next;
                        try {
                            setValue('baiduAiAutoExpandEnabled', next);
                        } catch (e11) {}
                        applyBaiduAiAutoExpandRuntime(next);
                    });
                }

                const darkStored = Boolean(getValue(BAIDU_FLOAT_DARK_KEY, false));
                applyBaiduDarkRuntime(darkStored);
                applyBaiduLayoutRuntime(settings.baiduLayoutMode);
                applyBaiduHideAiRuntime(Boolean(settings.baiduHideAiAnswerEnabled));
                applyBaiduAiAutoExpandRuntime(Boolean(settings.baiduAiAutoExpandEnabled));

                baiduFloatControlsStop = () => {
                    try {
                        setOpen(false);
                    } catch (e10) {}
                };
            }

            function startBaiduSearchEnhance() {
                if (!isTopWindow()) return;
                const host = getCurrentHost();
                if (host !== 'www.baidu.com' && host !== 'm.baidu.com') return;
                const styleId = 'newtab-pro-baidu-search-enhance-style';
                const cssRules = [];
                if (host === 'www.baidu.com') {
                    try {
                        const root = document.documentElement;
                        if (root && root.classList) root.classList.remove('single-column', 'double-column');
                        if (document.body && document.body.classList) document.body.classList.remove('single-column', 'double-column');
                    } catch (e) {}
                    const shouldOptimize = Boolean(settings.baiduStyleOptimizeEnabled);
                    if (shouldOptimize) {
                        const mode = String(settings.baiduLayoutMode || '').toLowerCase() === 'double' ? 'double' : 'single';
                        const applyLayoutClass = () => {
                            try {
                                let applied = false;
                                const root = document.documentElement;
                                if (root && root.classList) {
                                    root.classList.toggle('single-column', mode === 'single');
                                    root.classList.toggle('double-column', mode === 'double');
                                    applied = true;
                                }
                                const body = document.body;
                                if (body && body.classList) {
                                    body.classList.toggle('single-column', mode === 'single');
                                    body.classList.toggle('double-column', mode === 'double');
                                    applied = true;
                                }
                                return applied;
                            } catch (e2) {
                                return false;
                            }
                        };
                        if (!applyLayoutClass()) {
                            let attempts = 0;
                            const tick = () => {
                                attempts++;
                                if (applyLayoutClass()) return;
                                if (attempts >= 60) return;
                                try {
                                    TimerRegistry.setTimeout(tick, 50);
                                } catch (e3) {}
                            };
                            try {
                                TimerRegistry.setTimeout(tick, 0);
                            } catch (e5) {}
                            try {
                                document.addEventListener('DOMContentLoaded', tick, { once: true });
                            } catch (e7) {}
                            try {
                                document.addEventListener('pageshow', tick, { once: true });
                            } catch (e8) {}
                        }
                        try {
                            if (location && String(location.pathname || '') === '/s') {
                                let hasValidHead = false;
                                const patchHead = () => {
                                    try {
                                        const header = document.getElementById('head');
                                        if (!header) return false;
                                        const headerHtml = String(header.innerHTML || '').trim();
                                        if (!headerHtml) return false;
                                        if (!header.querySelector('#kw') && !header.querySelector('input[name="wd"]') && !header.querySelector('input#kw')) return false;
                                        if (!baiduHeadPatched) {
                                            baiduOriginalHeadHtml = String(header.innerHTML || '');
                                            baiduHeadPatched = true;
                                        }
                                        header.innerHTML =
                                            '<div class="gm-search-container" id="newtab-pro-baidu-search-box">' +
                                            '<input class="gm-search-input" type="text" maxlength="255" autocomplete="off" placeholder="è¯·è¾“å…¥æœç´¢å†…å®¹">' +
                                            '<button class="gm-search-button" type="button">ç™¾åº¦ä¸€ä¸‹</button>' +
                                            '</div>';
                                        const input = header.querySelector('.gm-search-input');
                                        const button = header.querySelector('.gm-search-button');
                                        try {
                                            const query = new URLSearchParams(String(location.search || '')).get('wd');
                                            if (query && input) input.value = query;
                                        } catch (e1) {}
                                        const doSearch = () => {
                                            const q = input && input.value ? String(input.value).trim() : '';
                                            if (!q) return;
                                            location.href = 'https://www.baidu.com/s?wd=' + encodeURIComponent(q);
                                        };
                                        if (button) button.onclick = doSearch;
                                        if (input)
                                            input.onkeydown = (event) => {
                                                try {
                                                    if (event && event.key === 'Enter') doSearch();
                                                } catch (e2) {}
                                            };
                                        hasValidHead = true;
                                        return true;
                                    } catch (e0) {
                                        return false;
                                    }
                                };
                                if (!patchHead()) {
                                    let attempts = 0;
                                    const tick = () => {
                                        attempts++;
                                        if (hasValidHead) return;
                                        if (patchHead()) return;
                                        if (attempts >= 60) return;
                                        try {
                                            TimerRegistry.setTimeout(tick, 50);
                                        } catch (e1) {}
                                    };
                                    try {
                                        TimerRegistry.setTimeout(tick, 0);
                                    } catch (e2) {}
                                    try {
                                        document.addEventListener('DOMContentLoaded', tick, { once: true });
                                    } catch (e3) {}
                                    try {
                                        document.addEventListener('pageshow', tick, { once: true });
                                    } catch (e4) {}
                                }
                            }
                        } catch (e5) {}
                        cssRules.push(
                            [
                                '#wrapper_wrapper,#container{max-width:100% !important;padding:0 !important;box-sizing:border-box !important;}',
                                '#s_form,#u{display:none !important;}',
                                '#head{height:60px !important;display:flex !important;align-items:center !important;justify-content:center !important;background:#fff !important;border-bottom:1px solid #e4e7ed !important;transition:background-color 0.3s,border-color 0.3s !important;}',
                                '#container{padding-top:10px !important;}',
                                '.gm-search-container{display:flex !important;margin:0 auto !important;justify-content:center !important;}',
                                '.gm-search-input{width:600px !important;height:42px !important;padding-left:25px !important;border:1px solid #c4c7ce !important;box-sizing:border-box !important;border-right:none !important;outline:none !important;font-size:16px !important;color:#000 !important;background:#fff !important;border-radius:24px 0 0 24px !important;-webkit-appearance:none !important;}',
                                '.gm-search-input:focus{border-color:#4e6ef2 !important;outline:none !important;box-shadow:none !important;}',
                                '.gm-search-button{height:42px !important;padding:0 25px !important;border:none !important;box-sizing:border-box !important;outline:none !important;cursor:pointer !important;font-size:17px !important;background:#4e6ef2 !important;border-radius:0 24px 24px 0 !important;color:#fff !important;display:flex !important;align-items:center !important;justify-content:center !important;}',
                                '.gm-search-button:hover{background:#3079e8 !important;}',
                                'body #content_left .c-container .gm-official-hint{position:absolute !important;left:0 !important;bottom:0 !important;top:auto !important;right:auto !important;width:auto !important;min-width:0 !important;max-width:none !important;height:30px !important;line-height:30px !important;padding:0 12px !important;margin:0 !important;background:#4e6ef2 !important;color:white !important;border-radius:0 10px 0 0 !important;font-size:13px !important;box-shadow:2px -2px 5px rgba(0,0,0,0.1) !important;z-index:999 !important;flex:none !important;}',
                                '#s_tab{width:100% !important;padding-left:0 !important;display:flex !important;justify-content:center !important;background:transparent !important;}',
                                '#s_tab_inner{display:flex !important;align-items:center !important;justify-content:center !important;width:auto !important;float:none !important;}',
                                '#s_tab .s-tab-item{display:inline-flex !important;align-items:center !important;float:none !important;margin:0 10px !important;vertical-align:middle !important;}',
                                '#s_tab .s-tab-item img{height:18px !important;width:auto !important;margin-right:5px !important;vertical-align:text-bottom !important;object-fit:contain !important;}',
                                '.tag-container_ksKXH,.wrapper_l .tag-wrapper_1sGop{width:100% !important;margin:10px auto !important;position:relative !important;display:flex !important;justify-content:center !important;top:unset !important;bottom:unset !important;float:none !important;}',
                                '.tag-scroll_3EMBO{display:flex !important;justify-content:center !important;width:auto !important;}',
                                '#searchTag,#searchTag>div{width:100% !important;max-width:1200px !important;margin:0 auto !important;box-sizing:border-box !important;}',
                                'body.single-column #container.sam_newgrid,body.single-column #content_left,body.single-column .wrapper_new #content_left,body.single-column #container.sam_newgrid #content_left{width:100% !important;max-width:1200px !important;margin:0 auto !important;padding:0 !important;display:flex !important;flex-direction:column !important;align-items:center !important;}',
                                'body.single-column .c-container,body.single-column .result-op,body.single-column .result{width:100% !important;max-width:800px !important;margin:0 auto 25px auto !important;padding:25px !important;border-radius:10px !important;box-shadow:0 3px 10px rgba(0,0,0,0.08) !important;background-color:#fff !important;transition:all 0.3s ease !important;box-sizing:border-box !important;position:relative !important;}',
                                'body.single-column #content_left > .c-container:first-child{margin-top:30px !important;}',
                                'body.single-column div[class*=\"site-img\"],body.single-column div[class*=\"site-img\"] *{width:16px !important;height:16px !important;max-width:16px !important;min-width:16px !important;overflow:hidden !important;}',
                                'body.single-column .c-showurl .c-img-s,body.single-column .c-showurl .c-img-s *{width:16px !important;height:16px !important;max-width:16px !important;min-width:16px !important;overflow:hidden !important;}',
                                'body.double-column #container.sam_newgrid,body.double-column #content_left,body.double-column .wrapper_new #content_left,body.double-column #container.sam_newgrid #content_left{width:100% !important;max-width:1400px !important;margin:0 auto !important;padding:10px !important;display:flex !important;flex-wrap:wrap !important;gap:20px !important;align-items:stretch !important;justify-content:space-between !important;}',
                                'body.double-column .c-container,body.double-column .result-op,body.double-column .result{width:calc(50% - 10px) !important;margin:0 !important;padding:20px !important;border-radius:10px !important;box-shadow:0 3px 10px rgba(0,0,0,0.08) !important;background-color:#fff !important;transition:all 0.3s ease !important;box-sizing:border-box !important;overflow:hidden !important;display:flex !important;flex-direction:column !important;max-height:none !important;position:relative !important;}',
                                'body.double-column #content_left > .c-container:first-child:not(.ntp-baidu-official-span),body.double-column #content_left > .result:first-child:not(.ntp-baidu-official-span),body.double-column #content_left > .result-op:first-child:not(.ntp-baidu-official-span){width:calc(50% - 10px) !important;max-width:calc(50% - 10px) !important;flex:0 0 calc(50% - 10px) !important;margin:0 !important;}',
                                'body.double-column #content_left > .ntp-baidu-official-span{width:100% !important;max-width:100% !important;flex:0 0 100% !important;}',
                                'body.double-column #content_left > .c-container:first-child *,body.double-column #content_left > .result:first-child *,body.double-column #content_left > .result-op:first-child *{max-width:100% !important;}',
                                'body.double-column .c-abstract,body.double-column .c-span-last{max-height:4.8em !important;overflow:hidden !important;display:-webkit-box !important;-webkit-line-clamp:3 !important;-webkit-box-orient:vertical !important;line-height:1.6 !important;}',
                                'body.double-column h3.t,body.double-column h3[class*=\"title\"]{font-size:16px !important;line-height:1.4 !important;margin-bottom:10px !important;max-height:2.8em !important;overflow:hidden !important;display:-webkit-box !important;-webkit-line-clamp:2 !important;-webkit-box-orient:vertical !important;}',
                                'body.double-column .c-container *,body.double-column .result-op *,body.double-column .result *{max-width:100% !important;box-sizing:border-box !important;word-wrap:break-word !important;}',
                                'body.double-column img,body.double-column video{max-width:100% !important;max-height:200px !important;height:auto !important;display:block !important;object-fit:cover !important;}',
                                'body.double-column .c-img,body.double-column .c-img6{max-height:200px !important;overflow:hidden !important;}',
                                'body.double-column #rs, body.double-column #page { display: block !important; width: 100% !important; max-width: 1400px !important; margin: 20px auto !important; margin-left: auto !important; margin-right: auto !important; padding: 0 20px !important; box-sizing: border-box !important; float: none !important; left: auto !important; right: auto !important; transform: none !important; }',
                                'body.double-column #rs > div, body.double-column #page > div { margin-left: 0 !important; margin-right: auto !important; padding-left: 0 !important; padding-right: 0 !important; left: auto !important; right: auto !important; float: none !important; transform: none !important; }',
                                'body.double-column #page > div[class*="page-inner_"]{display:flex !important;align-items:center !important;justify-content:center !important;flex-wrap:wrap !important;gap:8px !important;width:100% !important;max-width:100% !important;margin:0 auto !important;box-sizing:border-box !important;}',
                                'body.double-column #page > div[class*="page-inner_"] > a,body.double-column #page > div[class*="page-inner_"] > strong,body.double-column #page > div[class*="page-inner_"] > span{display:inline-flex !important;align-items:center !important;justify-content:center !important;vertical-align:middle !important;margin:0 !important;}',
                                'body.double-column #page a.n{display:inline-flex !important;align-items:center !important;justify-content:center !important;line-height:1 !important;vertical-align:middle !important;}body.double-column #page a.n .n-word_1TXWP,body.double-column #page a.n img{display:inline-block !important;vertical-align:middle !important;line-height:1 !important;}',
                                'body.double-column #page a.n img.leftArrow_ag-Qe,body.double-column #page a.n img.rightArrow_2RcSz,body.double-column #page a.n img[alt="ä¸Šä¸€é¡µ"],body.double-column #page a.n img[alt="ä¸‹ä¸€é¡µ"]{display:none !important;}',
                                'body.double-column #rs > div > div, body.double-column #page > div > div { margin-left: 0 !important; margin-right: auto !important; }',
                                'body.single-column #rs, body.single-column #rs_new, body.single-column #page { display: block !important; width: 100% !important; max-width: 1200px !important; margin: 20px auto !important; margin-left: auto !important; margin-right: auto !important; padding: 0 20px !important; box-sizing: border-box !important; float: none !important; left: auto !important; right: auto !important; transform: none !important; }',
                                'body.single-column #rs > div, body.single-column #rs_new > div, body.single-column #page > div { margin-left: 0 !important; margin-right: auto !important; padding-left: 0 !important; padding-right: 0 !important; left: auto !important; right: auto !important; float: none !important; transform: none !important; }',
                                'body.single-column #page > div[class*="page-inner_"]{display:flex !important;align-items:center !important;justify-content:center !important;flex-wrap:wrap !important;gap:8px !important;width:100% !important;max-width:100% !important;margin:0 auto !important;box-sizing:border-box !important;}',
                                'body.single-column #rs > div > div, body.single-column #rs_new > div > div, body.single-column #page > div > div { margin-left: 0 !important; margin-right: auto !important; }',
                            ].join('\n')
                        );
                        cssRules.push(
                            [
                                'body.double-column .c-group-wrapper,body.double-column div[tpl*="baike"],body.double-column div[data-module="baike"],body.double-column .pc-fresh-wrapper-con,body.double-column .c-container[tpl="kg_entity_card"]{overflow:visible !important;max-height:none !important;height:auto !important;display:block !important;}',
                                'body.double-column .c-container.pc-fresh-wrapper-con,body.double-column .c-container.c-group-wrapper,body.double-column .c-container[tpl="kg_entity_card"]{width:100% !important;max-width:100% !important;flex:0 0 100% !important;margin-bottom:20px !important;}',
                                'body.double-column .c-group-wrapper .c-group-inner,body.double-column .c-group-wrapper ._content_1ml43_4,body.double-column .c-group-wrapper .content_309tE,body.double-column .pc-fresh-wrapper-con .c-group-inner{width:100% !important;padding:15px !important;max-height:none !important;overflow:visible !important;}',
                                'body.double-column ._bg-header_1ml43_46{width:100% !important;padding:15px 15px 0 15px !important;}',
                                'body.double-column .c-group-wrapper .sc-paragraph{max-height:4.8em !important;overflow:hidden !important;display:-webkit-box !important;-webkit-line-clamp:3 !important;-webkit-box-orient:vertical !important;}',
                                'body.double-column div[tpl*="soft"],body.double-column .result[tpl="soft"]{max-height:350px !important;}',
                                'body.double-column div[tpl*="video"],body.double-column .result[tpl*="video"]{max-height:380px !important;}',
                                'body.double-column iframe,body.double-column video{max-height:180px !important;}',
                                'body.double-column .c-img-border{max-height:180px !important;overflow:hidden !important;}',
                                'body.double-column .c-img-radius-large{max-height:180px !important;overflow:hidden !important;border-radius:8px !important;}',
                                'body.double-column .c-gap-top-small,body.double-column .c-gap-bottom-small{margin-top:8px !important;margin-bottom:8px !important;}',
                                'body.double-column ul,body.double-column ol{max-height:150px !important;overflow:hidden !important;}',
                                'body.double-column .tag-wrapper_1sGop,body.double-column .tag-container_ksKXH{width:100% !important;grid-column:1 / -1 !important;}',
                                'body.double-column .c-showurl{margin-top:10px !important;padding-top:10px !important;flex-shrink:0 !important;}',
                                'body.double-column .c-tools{flex-shrink:0 !important;}',
                                'body.double-column .c-moreinfo,body.double-column .show-more{display:inline-block !important;color:#4e6ef2 !important;cursor:pointer !important;margin-top:8px !important;}',
                                '@media (max-width:1200px){body.double-column #container.sam_newgrid,body.double-column #content_left{grid-template-columns:1fr !important;}body.double-column .c-container,body.double-column .result-op,body.double-column .result{max-height:none !important;min-height:auto !important;}}',
                                '.c-container:hover,.result-op:hover,.result:hover{box-shadow:0 6px 15px rgba(0,0,0,0.12) !important;transform:translateY(-3px) !important;}',
                                'body.double-column .c-span24{width:100% !important;max-width:100% !important;float:none !important;}',
                                'body.double-column div[tpl="tieba_general"] .c-row{width:100% !important;}',
                                'body.double-column div[tpl="tieba_general"] .c-span18{width:100% !important;max-width:none !important;}',
                                'body.double-column .op_tieba_general_main{width:100% !important;}',
                                'body.double-column .op_exactqa_main,body.double-column .op_exactqa_body{width:100% !important;}',
                                'body.double-column table{width:100% !important;display:table !important;}',
                                'body.double-column .c-container > div,body.double-column .result-op > div{width:100% !important;}',
                                'body.double-column .op-soft-title,body.double-column .op_soft_title{max-width:100% !important;}',
                                'body.double-column [class*="open-source-software-blog-card"] section,body.double-column [class*="open-source-software-blog-card"] .blog-list-container,body.double-column [class*="open-source-software-blog-card"] .c-row{width:100% !important;max-width:100% !important;display:flex !important;}',
                                'body.double-column [class*="blog-summary"]{max-width:100% !important;white-space:normal !important;}',
                                '.pc-fresh-wrapper-con .new-pmd .c-row.card-normal_3X7DX,.bk_polysemy_1Ef6j .c-row.card-normal_3X7DX{display:flex !important;flex-direction:row !important;align-items:flex-start !important;gap:15px !important;flex-wrap:nowrap !important;}',
                                '.pc-fresh-wrapper-con .new-pmd .c-span3.left-image_3TJlK,.bk_polysemy_1Ef6j .c-span3.left-image_3TJlK{flex:0 0 120px !important;width:120px !important;max-width:120px !important;}',
                                '.pc-fresh-wrapper-con .new-pmd .c-span9.main-info_4Q_kj,.bk_polysemy_1Ef6j .c-span9.main-info_4Q_kj{flex:1 !important;min-width:0 !important;display:flex !important;flex-direction:column !important;}',
                                'body.double-column .source_1Vdff{display:flex !important;flex-direction:row !important;align-items:center !important;flex-wrap:nowrap !important;justify-content:flex-start !important;width:100% !important;min-width:0 !important;gap:8px !important;}',
                                'body.double-column .source_1Vdff > a[class*="siteLink"]{display:inline-flex !important;align-items:center !important;min-width:0 !important;flex:0 1 auto !important;}',
                                'body.double-column .source_1Vdff div[class*="site-img"]{position:static !important;flex:0 0 16px !important;}',
                                'body.double-column .source_1Vdff .c-tools{margin-left:auto !important;margin-top:0 !important;padding-top:0 !important;align-self:center !important;}',
                                '.pc-fresh-wrapper-con .source_1Vdff,.bk_polysemy_1Ef6j .source_1Vdff{display:flex !important;flex-direction:row !important;align-items:center !important;flex-wrap:nowrap !important;justify-content:flex-start !important;width:100% !important;white-space:nowrap !important;margin-top:10px !important;}',
                                '.pc-fresh-wrapper-con .siteLink_9TPP3,.bk_polysemy_1Ef6j .siteLink_9TPP3{flex-shrink:0 !important;margin-right:15px !important;display:flex !important;align-items:center !important;}',
                                '.pc-fresh-wrapper-con .tts-wrapper_1Lt-9,.bk_polysemy_1Ef6j .tts-wrapper_1Lt-9,div[class*="tts-wrapper"]{display:flex !important;flex-direction:row !important;align-items:center !important;margin-right:auto !important;flex-shrink:0 !important;}',
                                'div[class*="tts-wrapper"] > div,div[class*="tts-wrapper"] .voice-btn{display:inline-flex !important;align-items:center !important;margin-right:10px !important;}',
                                '.pc-fresh-wrapper-con .c-tools,.bk_polysemy_1Ef6j .c-tools{margin-left:auto !important;flex-shrink:0 !important;display:flex !important;align-items:center !important;position:static !important;}',
                                'body.double-column .bk_polysemy_1Ef6j .video-wrapper_MQNVE{width:10% !important;height:16px !important;margin-bottom:8px !important;position:relative !important;border:1px solid rgba(0,0,0,0.05) !important;border-radius:12px !important;overflow:hidden !important;-webkit-mask-image:-webkit-radial-gradient(white,black) !important;}',
                                'body.double-column .pc-fresh-wrapper-con .new-pmd .c-img-s{padding-bottom:10% !important;}',
                                'body.double-column .pc-fresh-wrapper-con .new-pmd .c-img img{width:100% !important;}',
                                'body.double-column .c-span3{width:25% !important;float:left !important;}',
                                'body.double-column .c-span9{width:75% !important;float:right !important;}',
                                'body.double-column div[class*="site-img"],body.double-column div[class*="site-img"] *{width:16px !important;height:16px !important;max-width:16px !important;min-width:16px !important;flex:0 0 16px !important;box-sizing:border-box !important;}',
                                'body.double-column div[class*="site-img"]{margin-right:6px !important;overflow:hidden !important;display:flex !important;align-items:center !important;}',
                                'body.double-column div[class*="site-img"] img{object-fit:contain !important;display:block !important;border:none !important;}',
                                'body.double-column .c-showurl .c-img-s,body.double-column .c-showurl .c-img-s *{width:16px !important;height:16px !important;max-width:16px !important;min-width:16px !important;overflow:hidden !important;}',
                                'body.double-column a[class*="siteLink"]{display:flex !important;align-items:center !important;text-decoration:none !important;}'
                            ].join('\n')
                        );
                    }
                }
                if (settings.baiduCleanAdsEnabled) {
                    cssRules.push(
                        [
                            '#top-ad{display:none !important;}',
                            '.EC_result,.ec_result,[data-tuiguang],[data-ecimtimesign],[data-placeid],[data-cmatchid],.ec-tuiguang,.c-recomm-wrap,#content_left > div[style*="display:block !important"],#content_left > div[data-ec-ad-type],#s_popup_advert{display:none !important;}',
                            '#s_popup_advert,.popup-advert,.advert-shrink,.advert-shrink2,#s_popup_advert *{display:none !important;visibility:hidden !important;width:0 !important;height:0 !important;opacity:0 !important;pointer-events:none !important;position:fixed !important;top:-9999px !important;left:-9999px !important;z-index:-999999 !important;clip:rect(0 0 0 0) !important;}',
                            'ins.adsbygoogle,.adsbygoogle,[data-adsense],[data-ad-client],[data-ad-slot],[data-adsbygoogle-status],.tag-container_ksKXH,.wrapper_l .tag-wrapper_1sGop,.foot-container_2X1Nt{display:none !important;}',
                            '#rs_new,[tpl="app/rs"],div[tpl="app/rs"],div[m-name^="molecules/app/rs/"]{display:none !important;}',
                            'div[tpl="recommend_list"],div[m-name*="recommend_list"],div[mu*="recommend_list.baidu.com"]{display:none !important;}',
                            'div[mu*="secure.mydown.com"],div[mu*="mydown.com"],div[data-click*="secure.mydown.com"],div[data-click*="mydown.com"]{display:none !important;}',
                            "[tpl='feed-ad']{display:none !important;}",
                            "[tpl='sp_hot_sale']{display:none !important;}",
                            "[tpl='short_video'],[tpl^='short_video'],[tpl*='short_video'],[data-module*='short_video'],[m-name*='short_video']{display:none !important;}",
                            'a[href^="https://www.baidu.com/sf/vsearch?"],a[href^="/sf/vsearch?"],a[href*="//www.baidu.com/sf/vsearch?"],a[href*="/sf/vsearch?"]{display:none !important;}',
                            "[tpl='sp_rank']{display:none !important;}",
                            "[tpl*='game-page']{display:none !important;}",
                            "[tpl*='b2b_prod']{display:none !important;}",
                            '.ec-pc_comp_banner_cc_float_video-fwc{display:none !important;}',
                            "[class*='tuiguang']{display:none !important;}",
                            "[id*='tuiguang']{display:none !important;}",
                        ].join('\n')
                    );
                }
                if (settings.baiduHideRightContent) {
                    cssRules.push(
                        [
                            '#content_right{display:none !important;}',
                            '#rrecom-container{display:none !important;}',
                            '.opr-recommends-merge-content{display:none !important;}',
                        ].join('\n')
                    );
                }
                if (settings.baiduHideHotSearch) {
                    cssRules.push(
                        [
                            '#s-hotsearch-wrapper{display:none !important;}',
                            '#s_menu_gurd{display:none !important;}',
                            '#s_wrap{display:none !important;}',
                            '.s-manhattan-index{display:none !important;}',
                        ].join('\n')
                    );
                }
                cssRules.push(
                    [
                        `body.${BAIDU_HIDE_AI_BODY_CLASS} div[tpl="new_baikan_index"], body.${BAIDU_HIDE_AI_BODY_CLASS} [tpl="wenda_generate"], body.${BAIDU_HIDE_AI_BODY_CLASS} .ai-entry.cos-space-mb-xs, body.${BAIDU_HIDE_AI_BODY_CLASS} .result-op.c-container.new-pmd[tpl="ai_index"], body.${BAIDU_HIDE_AI_BODY_CLASS} .result-op[tpl="ai_index"], body.${BAIDU_HIDE_AI_BODY_CLASS} .result-op[tpl="wenda_generate"], body.${BAIDU_HIDE_AI_BODY_CLASS} div[m-name^="mirror-san/app/wenda_generate"], body.${BAIDU_HIDE_AI_BODY_CLASS} div[tpl="ai_ask"]{display:none !important;}`,
                        '#page + #help,#page ~ #help{display:none !important;}',
                        '#rs_new,[tpl="app/rs"],div[tpl="app/rs"],div[m-name^="molecules/app/rs/"]{display:none !important;}',
                        `#${BAIDU_FLOAT_ROOT_ID}{position:fixed;right:20px;bottom:24px;z-index:2147483647;display:flex;flex-direction:column;align-items:flex-end;gap:8px;font-family:-apple-system,BlinkMacSystemFont,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}`,
                        `#${BAIDU_FLOAT_BTN_ID}{position:relative;width:44px;height:44px;border-radius:999px;border:none;background:linear-gradient(135deg,#ff4d8d 0%,#ff7ac8 100%);display:flex;align-items:center;justify-content:center;color:#f9fafb;cursor:pointer;box-shadow:0 4px 12px rgba(255,77,141,.38);backdrop-filter:blur(10px);padding:0;overflow:hidden;transition:transform .25s cubic-bezier(.25,.8,.25,1),box-shadow .25s cubic-bezier(.25,.8,.25,1);}`,
                        `#${BAIDU_FLOAT_BTN_ID}::before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.35) 0,transparent 55%);opacity:0;transition:opacity .25s ease;}`,
                        `#${BAIDU_FLOAT_BTN_ID} svg{width:20px;height:20px;fill:currentColor;filter:drop-shadow(0 1px 2px rgba(15,23,42,.5));}`,
                        `#${BAIDU_FLOAT_BTN_ID}:hover{transform:scale(1.07) rotate(5deg);box-shadow:0 8px 20px rgba(255,77,141,.65);}`,
                        `#${BAIDU_FLOAT_BTN_ID}:hover::before{opacity:1;}`,
                        `#${BAIDU_FLOAT_BTN_ID}:active{transform:scale(.98);box-shadow:0 4px 12px rgba(255,77,141,.55);}`,
                        `#${BAIDU_FLOAT_PANEL_ID}{min-width:200px;border-radius:16px;border:1px solid rgba(255,110,175,.35);background:linear-gradient(180deg,rgba(255,244,248,.94),rgba(255,236,246,.96));box-shadow:0 18px 45px rgba(255,110,175,.25);padding:12px 14px;box-sizing:border-box;opacity:0;transform:translateY(10px) scale(.98);transform-origin:bottom right;transition:opacity .2s ease,transform .2s cubic-bezier(0.68,-0.55,0.265,1.55);pointer-events:none;color:#3d3d3d;backdrop-filter:blur(12px);}`,
                        `#${BAIDU_FLOAT_ROOT_ID}.ntp-open #${BAIDU_FLOAT_PANEL_ID}{opacity:1;transform:translateY(0) scale(1);pointer-events:auto;}`,
                        `.ntp-baidu-item{display:flex;align-items:center;justify-content:space-between;padding:4px 2px;}`,
                        `.ntp-baidu-label{display:flex;align-items:center;font-size:13px;gap:6px;color:#3d3d3d;}`,
                        `.ntp-baidu-icon{width:18px;text-align:center;font-size:14px;}`,
                        `.ntp-baidu-toggle{width:38px;height:22px;border-radius:999px;border:1px solid rgba(255,110,175,.6);background:#fff;position:relative;cursor:pointer;box-sizing:border-box;transition:all .25s cubic-bezier(0.4,0,0.2,1);box-shadow:inset 0 1px 3px rgba(255,110,175,.2);}`,
                        `.ntp-baidu-toggle::after{content:"";position:absolute;top:2px;left:2px;width:18px;height:18px;border-radius:999px;background:linear-gradient(135deg,#fff 0%,#f9fafb 100%);box-shadow:0 2px 4px rgba(15,23,42,.25);transition:all .25s cubic-bezier(0.68,-0.55,0.265,1.55);}`,
                        `.ntp-baidu-toggle.ntp-on{background:linear-gradient(135deg,#ff4d8d 0%,#ff7ac8 100%);border-color:rgba(255,110,175,1);box-shadow:inset 0 1px 3px rgba(15,23,42,.35),0 0 0 1px rgba(255,110,175,.45);}`,
                        `.ntp-baidu-toggle.ntp-on::after{transform:translateX(16px);box-shadow:0 2px 6px rgba(15,23,42,.4);}`,
                        `.ntp-baidu-separator{height:1px;margin:6px 0;background:linear-gradient(to right,transparent,rgba(255,110,175,.45),transparent);}`,
                        `body.${BAIDU_DARK_BODY_CLASS}{background-color:#1a1a1a !important;color:#e8e6e3 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #head{background:#252525 !important;border-bottom:1px solid #333 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #wrapper_wrapper,body.${BAIDU_DARK_BODY_CLASS} #container{background:transparent !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .gm-search-input{background:#333 !important;border-color:#555 !important;color:#e8e6e3 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .c-container,body.${BAIDU_DARK_BODY_CLASS} .result-op,body.${BAIDU_DARK_BODY_CLASS} .result[tpl="soft"],body.${BAIDU_DARK_BODY_CLASS} div[class*="_aladdin"]{background-color:#252525 !important;border:1px solid #333 !important;border-radius:8px !important;padding:15px !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .c-container > .t.c-title,body.${BAIDU_DARK_BODY_CLASS} .tags_2yHYj,body.${BAIDU_DARK_BODY_CLASS} .cos-tabs.cos-tabs-bar .cos-tabs-header,body.${BAIDU_DARK_BODY_CLASS} .tag-container_ksKXH,body.${BAIDU_DARK_BODY_CLASS} .wrapper_l .tag-wrapper_1sGop{background-color:transparent !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #content_left a,body.${BAIDU_DARK_BODY_CLASS} #content_left h3[class*="title"],body.${BAIDU_DARK_BODY_CLASS} #content_left h3[class*="title"] *,body.${BAIDU_DARK_BODY_CLASS} #content_left .op-soft-title,body.${BAIDU_DARK_BODY_CLASS} #content_left .op-soft-title *,body.${BAIDU_DARK_BODY_CLASS} .tag-container_ksKXH a,body.${BAIDU_DARK_BODY_CLASS} .wrapper_l .tag-wrapper_1sGop a{color:#8ab4f8 !important;text-decoration:none !important;background-color:transparent !important;text-shadow:0 0 2px rgba(0,0,0,0.5) !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #content_left a:hover{text-decoration:underline !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .c-abstract,body.${BAIDU_DARK_BODY_CLASS} .c-abstract *,body.${BAIDU_DARK_BODY_CLASS} .c-span-last,body.${BAIDU_DARK_BODY_CLASS} .summary-text_560AW,body.${BAIDU_DARK_BODY_CLASS} .summary-text_560AW *,body.${BAIDU_DARK_BODY_CLASS} #content_left em,body.${BAIDU_DARK_BODY_CLASS} .new-pmd .c-color-text,body.${BAIDU_DARK_BODY_CLASS} .cu-color-text,body.${BAIDU_DARK_BODY_CLASS} .content-summary_2vT1Z .summary_7f0uR,body.${BAIDU_DARK_BODY_CLASS} .cos-text-body,body.${BAIDU_DARK_BODY_CLASS} .orientation-title-wrapper_YgpKw .orientation-title_50ct8,body.${BAIDU_DARK_BODY_CLASS} .pc_5KjyO .text_4wMIj,body.${BAIDU_DARK_BODY_CLASS} .pc_ZVQ8P .title_6sD3p,body.${BAIDU_DARK_BODY_CLASS} ._group-title_klgk1_34{color:#e8e6e3 !important;text-shadow:0 0 2px rgba(0,0,0,0.5) !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #content_left em{font-style:italic !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .op-soft-info-text,body.${BAIDU_DARK_BODY_CLASS} .c-showurl,body.${BAIDU_DARK_BODY_CLASS} .c-showurl *,body.${BAIDU_DARK_BODY_CLASS} .cosc-source-text,body.${BAIDU_DARK_BODY_CLASS} .cos-color-text-minor,body.${BAIDU_DARK_BODY_CLASS} .op_translation_usertip,body.${BAIDU_DARK_BODY_CLASS} .fy-dictwisenew-tip_79GW0,body.${BAIDU_DARK_BODY_CLASS} .cos-color-text-tiny,body.${BAIDU_DARK_BODY_CLASS} .stockStateContainer_bpzBK,body.${BAIDU_DARK_BODY_CLASS} .phrase-text_1u3Zc,body.${BAIDU_DARK_BODY_CLASS} .fy-dictwisenew-tip_1tVMp,body.${BAIDU_DARK_BODY_CLASS} .cos-item-desc_7mnJc{color:#999 !important;text-shadow:none !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} div[class*="stock-container"] *{color:#e8e6e3 !important;background:none !important;background-color:transparent !important;text-shadow:0 0 2px rgba(0,0,0,0.5) !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} a{color:#8ab4f8 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} a:visited{color:#a5b4fc !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} div[tpl="new_baikan_index"],body.${BAIDU_DARK_BODY_CLASS} [tpl="wenda_generate"],body.${BAIDU_DARK_BODY_CLASS} .ai-entry.cos-space-mb-xs,body.${BAIDU_DARK_BODY_CLASS} .result-op.c-container.new-pmd[tpl="ai_index"],body.${BAIDU_DARK_BODY_CLASS} .result-op[tpl="ai_index"],body.${BAIDU_DARK_BODY_CLASS} .result-op[tpl="wenda_generate"],body.${BAIDU_DARK_BODY_CLASS} div[m-name^="mirror-san/app/wenda_generate"],body.${BAIDU_DARK_BODY_CLASS} div[tpl="ai_ask"]{background-color:#252525 !important;color:#e8e6e3 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} div[tpl="new_baikan_index"] a,body.${BAIDU_DARK_BODY_CLASS} [tpl="wenda_generate"] a,body.${BAIDU_DARK_BODY_CLASS} .ai-entry.cos-space-mb-xs a,body.${BAIDU_DARK_BODY_CLASS} .result-op.c-container.new-pmd[tpl="ai_index"] a,body.${BAIDU_DARK_BODY_CLASS} .result-op[tpl="ai_index"] a,body.${BAIDU_DARK_BODY_CLASS} .result-op[tpl="wenda_generate"] a,body.${BAIDU_DARK_BODY_CLASS} div[m-name^="mirror-san/app/wenda_generate"] a,body.${BAIDU_DARK_BODY_CLASS} div[tpl="ai_ask"] a{color:#8ab4f8 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS}.double-column #rs,body.${BAIDU_DARK_BODY_CLASS}.double-column #page{background:transparent !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS}.double-column .rs-title{color:#e8e6e3 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS}.double-column .rs-list .rs-item a{color:#8ab4f8 !important;background:#3c4043 !important;border:1px solid #555 !important;border-radius:4px !important;padding:4px 12px !important;text-decoration:none !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS}.double-column .rs-list .rs-item a:hover{background:#4e6ef2 !important;color:#fff !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #s_tab a,body.${BAIDU_DARK_BODY_CLASS} #s_tab span{color:#ccc !important;text-decoration:none !important;text-shadow:none !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #s_tab .s-tab-item.current span{color:#fff !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #s_tab .s-tab-item.current{border-bottom-color:#4e6ef2 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #page a,body.${BAIDU_DARK_BODY_CLASS} #page strong{background-color:#333 !important;border:1px solid #555 !important;color:#e8e3e3 !important;text-shadow:none !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} #page strong,body.${BAIDU_DARK_BODY_CLASS} #page a.n:hover{background-color:#4e6ef2 !important;color:#fff !important;border-color:#4e6ef2 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .text-con_6ko8Y *,body.${BAIDU_DARK_BODY_CLASS} .common-content_6I4X7,body.${BAIDU_DARK_BODY_CLASS} .common-content_6I4X7 *,body.${BAIDU_DARK_BODY_CLASS} .common-text_4MwRe,body.${BAIDU_DARK_BODY_CLASS} .bg_75N1H,body.${BAIDU_DARK_BODY_CLASS} .marklang-paragraph,body.${BAIDU_DARK_BODY_CLASS} .item-text_1uePL,body.${BAIDU_DARK_BODY_CLASS} .detail-text_6bA6P,body.${BAIDU_DARK_BODY_CLASS} .item-num_13Q8D,body.${BAIDU_DARK_BODY_CLASS} .scroll-box_2RZdL .week-box_5twsY .week-item_4zjYh .value_1wQkq,body.${BAIDU_DARK_BODY_CLASS} .pc-sub-title_eKXM1{color:#e8e6e3 !important;text-shadow:0 0 2px rgba(0,0,0,0.5) !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .words-text_5Ps7D,body.${BAIDU_DARK_BODY_CLASS} .words-text_5Ps7D span,body.${BAIDU_DARK_BODY_CLASS} .cos-search-link-text,body.${BAIDU_DARK_BODY_CLASS} .cos-icon-research,body.${BAIDU_DARK_BODY_CLASS} .cos-more-link-text,body.${BAIDU_DARK_BODY_CLASS} .cos-tabs-header .cos-tab,body.${BAIDU_DARK_BODY_CLASS} .detail-underline_7dWH2,body.${BAIDU_DARK_BODY_CLASS} .detail-icon_3mni6 i{color:#8ab4f8 !important;text-shadow:0 0 2px rgba(0,0,0,0.5) !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .common-text_2R17p.cos-font-medium,body.${BAIDU_DARK_BODY_CLASS} object.cos-line-clamp-2 .mean-text_4MwRe{color:#e8e6e3 !important;text-shadow:0 0 2px rgba(0,0,0,0.5) !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .marklang,body.${BAIDU_DARK_BODY_CLASS} .marklang *{color:#e8e6e3 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .marklang a{color:#8ab4f8 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .marklang code{background:rgba(255,255,255,0.08) !important;color:#e8e6e3 !important;border-radius:4px !important;padding:0 4px !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .marklang pre,body.${BAIDU_DARK_BODY_CLASS} .marklang pre code{background:#111827 !important;color:#e5e7eb !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .cosd-citation,body.${BAIDU_DARK_BODY_CLASS} .cosd-citation *{color:#e8e6e3 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .cosd-citation-citationId{background:#3c4043 !important;border:1px solid #5f6368 !important;color:#e8e6e3 !important;}`,
                        `body.${BAIDU_DARK_BODY_CLASS} .cosd-question-guide-title,body.${BAIDU_DARK_BODY_CLASS} .cosd-question-guide-title *,body.${BAIDU_DARK_BODY_CLASS} .cosd-question-guide-option-text,body.${BAIDU_DARK_BODY_CLASS} .cosd-question-guide-option-text *{color:#e8e6e3 !important;}`,
                    ].join('\n')
                );
                let css = cssRules.join('\n').trim();
                if (!css) return stopBaiduSearchEnhance();
                try {
                    css = css
                        .replace(/body\.single-column/g, ':root.single-column')
                        .replace(/body\.double-column/g, ':root.double-column')
                        .replace(new RegExp('body\\.' + BAIDU_DARK_BODY_CLASS, 'g'), ':root.' + BAIDU_DARK_BODY_CLASS)
                        .replace(new RegExp('body\\.' + BAIDU_HIDE_AI_BODY_CLASS, 'g'), ':root.' + BAIDU_HIDE_AI_BODY_CLASS);
                } catch (e) {}
                const shouldUpdateStyle = !(css === baiduSearchEnhanceCssSig && baiduSearchEnhanceStop);
                if (shouldUpdateStyle) {
                    upsertStyleText(styleId, css);
                    try {
                        const el = document.getElementById(styleId);
                        if (el) (document.head || document.documentElement || document.body || document).appendChild(el);
                    } catch (e0) {}
                    try {
                        setTimeout(() => {
                            try {
                                const el = document.getElementById(styleId);
                                if (el) (document.head || document.documentElement || document.body || document).appendChild(el);
                            } catch (e1) {}
                        }, 800);
                    } catch (e2) {}
                    try {
                        if (localStorage.getItem('placeholderData')) localStorage.removeItem('placeholderData');
                    } catch (e) {}
                    baiduSearchEnhanceStop = () => {
                        removeElementById(styleId);
                        applyBaiduHideAiRuntime(false);
                        applyBaiduDarkRuntime(false);
                        removeBaiduFloatControls();
                        try {
                            if (baiduHeadPatched) {
                                const header = document.getElementById('head');
                                if (header) header.innerHTML = baiduOriginalHeadHtml;
                            }
                        } catch (e3) {}
                        baiduOriginalHeadHtml = '';
                        baiduHeadPatched = false;
                        try {
                            const root = document.documentElement;
                            if (root && root.classList) root.classList.remove('single-column', 'double-column');
                            if (document.body && document.body.classList) document.body.classList.remove('single-column', 'double-column');
                        } catch (e4) {}
                        try {
                            applyBaiduPaginationRuntime();
                        } catch (e5) {}
                    };
                    baiduSearchEnhanceCssSig = css;
                }

                if (host === 'www.baidu.com') {
                    try {
                        const isSearchPage = location && String(location.pathname || '') === '/s';
                        if (isSearchPage) {
                            const ensure = () => {
                                try {
                                    if (!document.body) return false;
                                    ensureBaiduFloatControls();
                                    return true;
                                } catch (e2) {
                                    return false;
                                }
                            };
                            if (!ensure()) {
                                let attempts = 0;
                                const tick = () => {
                                    attempts++;
                                    if (ensure()) return;
                                    if (attempts >= 60) return;
                                    try {
                                        TimerRegistry.setTimeout(tick, 50);
                                    } catch (e3) {}
                                };
                                try {
                                    TimerRegistry.setTimeout(tick, 0);
                                } catch (e5) {}
                                try {
                                    document.addEventListener('DOMContentLoaded', tick, { once: true });
                                } catch (e7) {}
                            }
                        }
                        else removeBaiduFloatControls();
                    } catch (e) {}
                }
                applyBaiduHideAiRuntime(Boolean(settings.baiduHideAiAnswerEnabled));
                applyBaiduAiAutoExpandRuntime(Boolean(settings.baiduAiAutoExpandEnabled));
                try {
                    applyBaiduPaginationRuntime();
                } catch (e1) {}
                try {
                    applyBaiduRecommendListCleanupRuntime(Boolean(settings.baiduCleanAdsEnabled));
                } catch (e2) {}

                if (baiduPinOfficialStop) {
                    try {
                        baiduPinOfficialStop();
                    } catch (e2) {}
                    baiduPinOfficialStop = null;
                }
                if (host === 'www.baidu.com' && settings.baiduPinOfficialEnabled) {
                    const install = () => {
                        const root = document.getElementById('content_left');
                        if (!root) return false;
                        let scheduled = 0;

                        const normalizeQueryText = (s) =>
                            String(s || '')
                                .trim()
                                .toLowerCase()
                                .replace(/\s/g, '');
                        const safeDecodeMaybe = (s) => {
                            const raw = String(s || '');
                            if (!raw) return '';
                            try {
                                return decodeURIComponent(raw);
                            } catch (e) {
                                return raw;
                            }
                        };
                        const tryGetDomain = (url) => {
                            try {
                                const u = new URL(String(url || ''));
                                return String(u.hostname || '').replace(/^www\./i, '');
                            } catch (e) {
                                return '';
                            }
                        };
                        const extractBaiduResultUrl = (linkEl, resultEl) => {
                            const pick = (v) => {
                                const s = String(v || '').trim();
                                if (!s) return '';
                                if (/^https?:\/\//i.test(s)) return s;
                                return '';
                            };
                            try {
                                if (linkEl) {
                                    const ds = linkEl.dataset || {};
                                    const a =
                                        pick(ds.landurl) ||
                                        pick(ds.lurl) ||
                                        pick(ds.url) ||
                                        pick(linkEl.getAttribute('data-landurl')) ||
                                        pick(linkEl.getAttribute('data-lurl')) ||
                                        pick(linkEl.getAttribute('data-url')) ||
                                        pick(linkEl.getAttribute('mu')) ||
                                        pick(linkEl.getAttribute('url'));
                                    if (a) return a;
                                }
                            } catch (e) {}
                            try {
                                if (resultEl) {
                                    const ds = resultEl.dataset || {};
                                    const a =
                                        pick(ds.landurl) ||
                                        pick(ds.lurl) ||
                                        pick(ds.url) ||
                                        pick(resultEl.getAttribute('data-landurl')) ||
                                        pick(resultEl.getAttribute('data-lurl')) ||
                                        pick(resultEl.getAttribute('data-url')) ||
                                        pick(resultEl.getAttribute('mu')) ||
                                        pick(resultEl.getAttribute('url'));
                                    if (a) return a;
                                }
                            } catch (e) {}
                            const tryParseLog = (el) => {
                                try {
                                    if (!el) return '';
                                    const log = String(el.getAttribute('data-log') || el.getAttribute('data-tools') || '');
                                    if (!log) return '';
                                    const m =
                                        /"mu"\s*:\s*"([^"]+)"/.exec(log) ||
                                        /"url"\s*:\s*"([^"]+)"/.exec(log) ||
                                        /"link"\s*:\s*"([^"]+)"/.exec(log);
                                    if (!m) return '';
                                    return safeDecodeMaybe(m[1]);
                                } catch (e) {
                                    return '';
                                }
                            };
                            return tryParseLog(linkEl) || tryParseLog(resultEl);
                        };
                        const runPin = () => {
                            const results = Array.from(root.children).filter((el) => el instanceof Element && el.matches('.c-container, .result, .result-op'));
                            if (!results.length) return;

                            try {
                                const oldPins = root.querySelectorAll('.ntp-baidu-official-pinned');
                                for (let i = 0; i < oldPins.length; i++) oldPins[i].classList.remove('ntp-baidu-official-pinned');
                            } catch (e00) {}
                            try {
                                const oldSpans = root.querySelectorAll('.ntp-baidu-official-span');
                                for (let i = 0; i < oldSpans.length; i++) oldSpans[i].classList.remove('ntp-baidu-official-span');
                            } catch (e01) {}
                            try {
                                const oldHints = root.querySelectorAll('.gm-official-hint');
                                for (let i = 0; i < oldHints.length; i++) oldHints[i].remove();
                            } catch (e02) {}
                            let bestResult = null;
                            let topScore = -1;
                            let bestIsOfficial = false;
                            let query = '';
                            try {
                                query = new URLSearchParams(String(location.search || '')).get('wd') || '';
                            } catch (e0) {
                                query = '';
                            }
                            const normalizedQuery = normalizeQueryText(query);
                            const isDellQuery = normalizedQuery.includes('dell') || normalizedQuery.includes('æˆ´å°”');
                            for (let index = 0; index < results.length; index++) {
                                const result = results[index];
                                const linkElement = result.querySelector('h3 a, .t a');
                                if (!linkElement) continue;
                                const href = String(linkElement.href || '');
                                const realUrl = extractBaiduResultUrl(linkElement, result) || href;
                                const title = String(linkElement.textContent || '');
                                let score = 0;
                                const hasOfficialMark = Boolean(
                                    result.querySelector('span.suffix-icon_3Ox2w span.tag_6iNm4.www-tag-fill-blue_3n0y3') ||
                                    (result.querySelector('span.tag_6iNm4') && String(result.querySelector('span.tag_6iNm4').textContent || '').trim() === 'å®˜æ–¹') ||
                                    result.querySelector('[data-is-official=\"1\"]') ||
                                    result.querySelector('.c-icon-official')
                                );
                                const domain = tryGetDomain(realUrl);
                                const isKnownOfficialDomain =
                                    (isDellQuery && (domain === 'dell.com' || domain === 'dell.com.cn' || domain.endsWith('.dell.com') || domain.endsWith('.dell.com.cn'))) ||
                                    (isDellQuery && domain === 'delltechnologies.com');
                                if (hasOfficialMark) score += 150;
                                if (isKnownOfficialDomain) score += 260;
                                if (index === 0) score += 50;
                                try {
                                    if (normalizedQuery && domain && domain.startsWith(normalizedQuery)) score += 30;
                                    if (isDellQuery && domain && domain.includes('dell')) score += 40;
                                } catch (e1) {}
                                if (title.includes('å®˜ç½‘') || title.includes('å®˜æ–¹')) score += 20;
                                if (score > topScore) {
                                    topScore = score;
                                    bestResult = result;
                                    bestIsOfficial = hasOfficialMark || isKnownOfficialDomain;
                                }
                            }
                            if (!bestResult || !bestIsOfficial || topScore <= 100) return;
                            try {
                                if (root.firstElementChild !== bestResult) {
                                    root.insertBefore(bestResult, root.firstElementChild);
                                }
                            } catch (e2) {}
                            try {
                                bestResult.classList.add('ntp-baidu-official-pinned');
                            } catch (e22) {}
                            try {
                                const isDouble = Boolean(document.body && document.body.classList && document.body.classList.contains('double-column'));
                                const isFullWidthCard =
                                    bestResult.matches('.pc-fresh-wrapper-con,.c-group-wrapper,[tpl=\"kg_entity_card\"],[tpl*=\"baike\"],[data-module=\"baike\"]');
                                if (isDouble && !isFullWidthCard) {
                                    const allCards = Array.from(root.children).filter(
                                        (el) => el instanceof Element && el.matches('.c-container, .result, .result-op')
                                    );
                                    const visibleCards = allCards.filter((el) => {
                                        try {
                                            return el.getClientRects().length > 0;
                                        } catch (e0) {
                                            return true;
                                        }
                                    });
                                    const halfCards = visibleCards.filter(
                                        (el) =>
                                            el instanceof Element &&
                                            !el.matches('.pc-fresh-wrapper-con,.c-group-wrapper,[tpl=\"kg_entity_card\"],[tpl*=\"baike\"],[data-module=\"baike\"]')
                                    );
                                    if (halfCards.indexOf(bestResult) !== -1 && halfCards.length % 2 === 1)
                                        bestResult.classList.add('ntp-baidu-official-span');
                                }
                            } catch (e23) {}
                            try {
                                let hint = bestResult.querySelector('.gm-official-hint');
                                if (!hint) {
                                    hint = document.createElement('div');
                                    hint.className = 'gm-official-hint';
                                    bestResult.appendChild(hint);
                                }
                                hint.textContent = 'å®˜æ–¹ç½‘ç«™ç»“æœå·²ç½®é¡¶';
                            } catch (e3) {}
                        };
                        const scheduleRun = () => {
                            if (scheduled) return;
                            scheduled = TimerRegistry.setTimeout(() => {
                                scheduled = 0;
                                try {
                                    runPin();
                                } catch (e4) {}
                            }, 500);
                        };
                        scheduleRun();
                        const obs = MutationRegistry.observe(root, { childList: true, subtree: true }, scheduleRun, 60 * 1000);
                        baiduPinOfficialStop = () => {
                            try {
                                if (scheduled) clearTimeout(scheduled);
                            } catch (e5) {}
                            scheduled = 0;
                            try {
                                if (obs) obs.disconnect();
                            } catch (e6) {}
                        };
                        return true;
                    };
                    const ok = install();
                    if (!ok) {
                        const id = TimerRegistry.setTimeout(() => {
                            try {
                                install();
                            } catch (e7) {}
                        }, 300);
                        baiduPinOfficialStop = () => {
                            try {
                                if (id) clearTimeout(id);
                            } catch (e8) {}
                        };
                    }
                }
            }

            function applyBaiduSearchEnhance(runtimeShouldActive) {
                const host = getCurrentHost();
                const isSearchPage =
                    (host === 'www.baidu.com' || host === 'm.baidu.com') && location && String(location.pathname || '') === '/s';
                const shouldEnable =
                    Boolean(runtimeShouldActive) &&
                    Boolean(settings.baiduSearchEnhanceEnabled) &&
                    (host === 'www.baidu.com' || host === 'm.baidu.com') &&
                    isSearchPage;
                if (!shouldEnable) return stopBaiduSearchEnhance();
                startBaiduSearchEnhance();
            }

            /*
             * ç§»æ¤æ¥æºï¼šCSDNä¼˜åŒ–.user.js
             * - PC è¯„è®ºåŒºå®¹å™¨ï¼š#pcCommentBoxï¼ˆåŸé”® csdn-blog-blockCommentï¼‰
             * - PC åº•éƒ¨æ¨èï¼šmain > div.recommend-boxï¼ˆåŸé”® csdn-blog-bottomRecommendArticleEnableï¼‰
             * - ç§»åŠ¨ç«¯è¯„è®ºï¼š#commentï¼ˆåŸé”® m-csdn-blog-comment-enableï¼‰
             * - ç§»åŠ¨ç«¯åº•éƒ¨æ–‡ç« ï¼š#recommendï¼ˆåŸé”® m-csdn-blog-bottomArticleEnableï¼‰
             */
            function stopCsdnCommentControl() {
                if (!csdnCommentStop) return;
                try {
                    csdnCommentStop();
                } catch (e) {}
                csdnCommentStop = null;
            }

            function startCsdnCommentControl() {
                if (!isTopWindow()) return;
                const host = getCurrentHost();
                if (!isCsdnHost(host) || host === 'link.csdn.net') return;
                const styleId = 'newtab-open-links-csdn-comment-style';
                const css = ['#pcCommentBox{display:none !important;}', '#comment{display:none !important;}'].join('\n');
                upsertStyleText(styleId, css);
                csdnCommentStop = () => removeElementById(styleId);
            }

            function applyCsdnCommentControl(runtimeShouldActive) {
                const host = getCurrentHost();
                const shouldHandle = Boolean(runtimeShouldActive) && isCsdnHost(host) && host !== 'link.csdn.net';
                if (!shouldHandle) return stopCsdnCommentControl();
                const shouldHide = Boolean(settings.csdnCommentEnabled);
                if (!shouldHide) return stopCsdnCommentControl();
                startCsdnCommentControl();
            }

            function stopCsdnBottomArticleControl() {
                if (!csdnBottomArticleStop) return;
                try {
                    csdnBottomArticleStop();
                } catch (e) {}
                csdnBottomArticleStop = null;
            }

            function startCsdnBottomArticleControl() {
                if (!isTopWindow()) return;
                const host = getCurrentHost();
                if (!isCsdnHost(host) || host === 'link.csdn.net') return;
                const styleId = 'newtab-open-links-csdn-bottom-article-style';
                const css = ['main > div.recommend-box{display:none !important;}', '#recommend{display:none !important;}'].join('\n');
                upsertStyleText(styleId, css);
                csdnBottomArticleStop = () => removeElementById(styleId);
            }

            function applyCsdnBottomArticleControl(runtimeShouldActive) {
                const host = getCurrentHost();
                const shouldHandle = Boolean(runtimeShouldActive) && isCsdnHost(host) && host !== 'link.csdn.net';
                if (!shouldHandle) return stopCsdnBottomArticleControl();
                const shouldHide = Boolean(settings.csdnBottomArticleEnabled);
                if (!shouldHide) return stopCsdnBottomArticleControl();
                startCsdnBottomArticleControl();
            }

            function stopQqMailCleanVipBubble() {
                if (!qqMailCleanVipBubbleStop) return;
                try {
                    qqMailCleanVipBubbleStop();
                } catch (e) {}
                qqMailCleanVipBubbleStop = null;
            }

            function startQqMailCleanVipBubble() {
                if (!isTopWindow()) return;
                const host = getCurrentHost();
                const isQqMail =
                    host === 'mail.qq.com' || host === 'wx.mail.qq.com' || host === 'exmail.qq.com' || host === 'en.mail.qq.com' || host === 'service.mail.qq.com';
                if (!isQqMail) return;
                const styleId = 'newtab-open-links-qqmail-clean-vip-bubble-style';
                const css = ['.cmp-vip-float-bubble-body{display:none !important;}'].join('\n');
                upsertStyleText(styleId, css);
                qqMailCleanVipBubbleStop = () => removeElementById(styleId);
            }

            function applyQqMailCleanVipBubble(runtimeShouldActive) {
                const shouldEnable = Boolean(runtimeShouldActive) && Boolean(settings.qqMailCleanVipBubbleEnabled);
                if (!shouldEnable) return stopQqMailCleanVipBubble();
                startQqMailCleanVipBubble();
            }

            function stopCsdnUnfreezeScroll() {
                if (!csdnUnfreezeScrollStop) return;
                try {
                    csdnUnfreezeScrollStop();
                } catch (e) {}
                csdnUnfreezeScrollStop = null;
            }

            function startCsdnUnfreezeScroll() {
                if (!isTopWindow()) return;
                if (csdnUnfreezeScrollStop) return;
                const host = getCurrentHost();
                if (!isCsdnHost(host) || host === 'link.csdn.net') return;
                const styleId = 'newtab-open-links-csdn-unfreeze-style';
                const css = ['html,body{overflow:auto !important;height:auto !important;position:static !important;}'].join('\n');
                const existing = document.getElementById(styleId);
                const style = existing || document.createElement('style');
                style.id = styleId;
                style.type = 'text/css';
                style.textContent = css;
                if (!existing) {
                    try {
                        (document.head || document.documentElement || document.body || document).appendChild(style);
                    } catch (e) {}
                }
                const shouldHealNow = () => {
                    try {
                        const cs = window.getComputedStyle ? getComputedStyle(document.body) : null;
                        if (cs && cs.overflow === 'hidden') return true;
                    } catch (e) {}
                    try {
                        const v = String(document.body && document.body.style ? document.body.style.overflow : '');
                        if (v && v.toLowerCase() === 'hidden') return true;
                    } catch (e2) {}
                    return false;
                };
                const heal = () => {
                    try {
                        if (document.documentElement) {
                            document.documentElement.style.setProperty('overflow', 'auto', 'important');
                            document.documentElement.style.setProperty('height', 'auto', 'important');
                        }
                    } catch (e) {}
                    try {
                        if (document.body) {
                            document.body.style.setProperty('overflow', 'auto', 'important');
                            document.body.style.setProperty('height', 'auto', 'important');
                        }
                    } catch (e2) {}
                };
                if (shouldHealNow()) heal();
                let observer = null;
                try {
                    const root = document.documentElement || document.body;
                    observer = MutationRegistry.observe(root, { attributes: true, subtree: true, attributeFilter: ['style', 'class'] }, () => {
                        if (!shouldHealNow()) return;
                        heal();
                    }, 1500);
                } catch (e) {}
                csdnUnfreezeScrollStop = () => {
                    try {
                        if (observer) observer.disconnect();
                    } catch (e2) {}
                    observer = null;
                    try {
                        const el = document.getElementById(styleId);
                        if (el) el.remove();
                    } catch (e3) {}
                };
            }

            function applyCsdnUnfreezeScroll(active) {
                const host = getCurrentHost();
                const shouldEnable = Boolean(active) && isCsdnHost(host) && host !== 'link.csdn.net';
                if (!shouldEnable) return stopCsdnUnfreezeScroll();
                startCsdnUnfreezeScroll();
            }

            function resolveCsdnRedirectTargetFromUrl(urlStr) {
                let u;
                try {
                    u = new URL(String(urlStr || ''));
                } catch (e) {
                    return null;
                }
                let raw = '';
                try {
                    raw = u.searchParams.get('target') || u.searchParams.get('url') || '';
                } catch (e) {}
                return normalizeSmartRedirectTargetValue(raw);
            }

            function applyCsdnRedirectFastJump(active) {
                if (!active) return;
                if (!isTopWindow()) return;
                const host = getCurrentHost();
                if (host !== 'link.csdn.net') return;
                const from = normalizeTipUrl(location.href);
                const target = resolveCsdnRedirectTargetFromUrl(location.href);
                if (!target || normalizeTipUrl(target) === from) return;
                showPassiveTip('CSDNï¼šå·²è·³è¿‡ä¸­è½¬é¡µ');
                try {
                    location.replace(target);
                } catch (e) {
                    try {
                        location.href = target;
                    } catch (e2) {}
                }
                setTimeout(() => {
                    if (normalizeTipUrl(location.href) !== from) return;
                    try {
                        location.replace(target);
                    } catch (e3) {
                        try {
                            location.href = target;
                        } catch (e4) {}
                    }
                }, 200);
            }

            function sanitizeCsdnCopyText(text) {
                let t = String(text || '');
                if (!t) return t;
                t = t.replace(/\r/g, '').replace(/\u00A0/g, ' ');
                t = t.replace(/^[\t ]*è¿è¡Œé¡¹ç›®å¹¶ä¸‹è½½æºç [ï¼Œ,ï¼š:\s]*/gm, '');
                t = t.replace(/AIå†™ä»£ç pythonç‚¹å‡»å¤åˆ¶è¿è¡Œ[ \t\u3000]*/gi, '');
                t = t.replace(/(?:^|\s)markdown\d{3,}(?:\s|$)/gi, ' ').replace(/[ \t]+\n/g, '\n');
                const lines = t.split('\n');
                for (let i = lines.length - 1; i >= 0; i--) {
                    const s = String(lines[i] || '').trim();
                    if (!s) continue;
                    if (/AIå†™ä»£ç pythonç‚¹å‡»å¤åˆ¶è¿è¡Œ/i.test(s)) {
                        lines.splice(i, 1);
                        continue;
                    }
                    if (/^\d{20,}$/.test(s)) {
                        lines.splice(i, 1);
                        continue;
                    }
                }
                let headRemoved = 0;
                while (lines.length > 1 && headRemoved < 6) {
                    const s = String(lines[0] || '').trim();
                    if (!s) {
                        lines.shift();
                        headRemoved++;
                        continue;
                    }
                    if (/^(?:è¿è¡Œé¡¹ç›®å¹¶ä¸‹è½½æºç |å¤åˆ¶ä»£ç |ç™»å½•å¤åˆ¶|ç™»å½•åå¤åˆ¶|å¤åˆ¶)$/.test(s)) {
                        lines.shift();
                        headRemoved++;
                        continue;
                    }
                    break;
                }
                const tailText = lines.slice(Math.max(0, lines.length - 30)).join('\n');
                const hasCsdnTail =
                    /æ¥æº[:ï¼š]\s*CSDN/i.test(tailText) ||
                    /ç‰ˆæƒå£°æ˜[:ï¼š]/i.test(tailText) ||
                    /åŸæ–‡é“¾æ¥[:ï¼š]/i.test(tailText) ||
                    /csdn\.net\//i.test(tailText) ||
                    /æœ¬æ–‡ä¸º\s*CSDN\s*åšä¸»/i.test(tailText);
                if (!hasCsdnTail) return lines.join('\n').trimEnd();
                const isNoiseLine = (line) => {
                    const s = String(line || '').trim();
                    if (!s) return true;
                    if (/^[-â€”_]{6,}$/.test(s)) return true;
                    if (/^(?:æ¥æº|åŸæ–‡é“¾æ¥|ç‰ˆæƒå£°æ˜)[:ï¼š]/i.test(s)) return true;
                    if (/æœ¬æ–‡ä¸º\s*CSDN\s*åšä¸»/i.test(s)) return true;
                    if (/csdn\.net\//i.test(s) && /https?:\/\//i.test(s)) return true;
                    if (/^markdown\d{3,}$/i.test(s)) return true;
                    return false;
                };
                while (lines.length && String(lines[lines.length - 1] || '').trim() === '') lines.pop();
                let removed = 0;
                while (lines.length && isNoiseLine(lines[lines.length - 1])) {
                    lines.pop();
                    if (++removed > 25) break;
                }
                return lines.join('\n').trimEnd();
            }

            function stripCsdnClipboardHijack() {
                try {
                    const el = document.querySelector('.article-copyright');
                    if (el && el.parentNode) el.parentNode.removeChild(el);
                } catch (e) {}
                try {
                    if (typeof window.articleType !== 'undefined' && window.articleType) {
                        window.articleType = 0;
                    }
                } catch (e2) {}
                try {
                    const csdn = window.csdn;
                    if (csdn && csdn.copyright) {
                        if (typeof csdn.copyright.textData === 'string') {
                            csdn.copyright.textData = '';
                        }
                        if (typeof csdn.copyright.htmlData === 'string') {
                            csdn.copyright.htmlData = '';
                        }
                    }
                } catch (e3) {}
            }

            function scheduleCsdnClipboardHijackCleanup() {
                stripCsdnClipboardHijack();
                setTimeout(stripCsdnClipboardHijack, 1200);
                setTimeout(stripCsdnClipboardHijack, 3500);
            }

            function startCsdnStrongCopy() {
                if (!isTopWindow()) return;
                if (csdnStrongCopyStop) return;
                if (!isCsdnHost(getCurrentHost())) return;
                scheduleCsdnClipboardHijackCleanup();
                const styleId = 'newtab-open-links-csdn-strong-copy-style';
                const css = [
                    '#content_views, #content_views * { -webkit-user-select: text !important; user-select: text !important; }',
                    '.blog-content-box, .blog-content-box * { -webkit-user-select: text !important; user-select: text !important; }',
                    'pre, code, pre *, code * { -webkit-user-select: text !important; user-select: text !important; }',
                    '.hljs-button{min-width:72px !important;padding:0 10px !important;box-sizing:border-box !important;border-radius:8px !important;font-weight:600 !important;letter-spacing:.2px !important;white-space:nowrap !important;overflow:visible !important;text-overflow:clip !important;cursor:pointer !important;}',
                    '.hljs-button{mask-image:none !important;-webkit-mask-image:none !important;}',
                    '.hljs-button::before{display:none !important;content:none !important;}',
                    '.hljs-button::after{white-space:nowrap !important;max-width:none !important;overflow:visible !important;text-overflow:clip !important;}',
                    '.hljs-button i,.hljs-button svg,.hljs-button img{display:none !important;}',
                    '.hljs-button:hover,.hljs-button:active,.hljs-button:focus{box-shadow:none !important;outline:none !important;}',
                    '.hljs-button[data-title="å¤åˆ¶æˆåŠŸ"]{background:linear-gradient(135deg,#10b981,#34d399) !important;color:#fff !important;box-shadow:0 6px 18px rgba(16,185,129,.25) !important;}',
                    '.hljs-button[data-title="å¤åˆ¶æˆåŠŸ"]::after{color:#fff !important;}',
                ].join('\n');
                const existing = document.getElementById(styleId);
                const style = existing || document.createElement('style');
                style.id = styleId;
                style.type = 'text/css';
                style.textContent = css;
                if (!existing) {
                    try {
                        (document.head || document.documentElement || document.body || document).appendChild(style);
                    } catch (e) {}
                }

                const getSelectionText = () => {
                    try {
                        const sel = window.getSelection ? window.getSelection() : null;
                        const s = sel ? String(sel.toString() || '') : '';
                        if (s) return s;
                    } catch (e) {}
                    const ae = document.activeElement;
                    if (!ae || !(ae instanceof Element)) return '';
                    const tag = String(ae.tagName || '').toUpperCase();
                    if (tag !== 'TEXTAREA' && tag !== 'INPUT') return '';
                    const input = ae;
                    const type = tag === 'INPUT' ? String(input.type || '').toLowerCase() : '';
                    if (tag === 'INPUT' && type && !/^(?:text|search|url|email|tel|password)$/i.test(type)) return '';
                    try {
                        const start = Number(input.selectionStart);
                        const end = Number(input.selectionEnd);
                        if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) return '';
                        const value = String(input.value || '');
                        return value.slice(start, end);
                    } catch (e) {
                        return '';
                    }
                };

                const onContextMenuCapture = (e) => {
                    if (!e) return;
                    try {
                        e.stopImmediatePropagation();
                    } catch (e2) {}
                };

                const onSelectStartCapture = (e) => {
                    if (!e) return;
                    try {
                        e.stopImmediatePropagation();
                    } catch (e2) {}
                };

                const onKeyDownCapture = (e) => {
                    if (!e) return;
                    const key = String(e.key || '').toLowerCase();
                    const isCopyKey = (e.ctrlKey || e.metaKey) && key === 'c';
                    const isCopyInsert = e.ctrlKey && key === 'insert';
                    if (!isCopyKey && !isCopyInsert) return;
                    try {
                        e.stopImmediatePropagation();
                    } catch (e2) {}
                };

                const onCopyCapture = (e) => {
                    if (!e) return;
                    const raw = getSelectionText();
                    if (!raw) return;
                    const cleaned = sanitizeCsdnCopyText(raw);
                    if (!cleaned) return;
                    try {
                        e.stopImmediatePropagation();
                    } catch (e2) {}
                    if (e.clipboardData && typeof e.clipboardData.setData === 'function') {
                        try {
                            e.clipboardData.setData('text/plain', cleaned);
                            e.preventDefault();
                        } catch (e3) {}
                    }
                };

                document.addEventListener('contextmenu', onContextMenuCapture, true);
                document.addEventListener('selectstart', onSelectStartCapture, true);
                document.addEventListener('keydown', onKeyDownCapture, true);
                document.addEventListener('copy', onCopyCapture, true);

                csdnStrongCopyStop = () => {
                    try {
                        document.removeEventListener('contextmenu', onContextMenuCapture, true);
                        document.removeEventListener('selectstart', onSelectStartCapture, true);
                        document.removeEventListener('keydown', onKeyDownCapture, true);
                        document.removeEventListener('copy', onCopyCapture, true);
                    } catch (e) {}
                    try {
                        const el = document.getElementById(styleId);
                        if (el) el.remove();
                    } catch (e2) {}
                };
                if (!csdnClipboardBypassStop) {
                    let initTimer = 0;
                    let resetTimer = 0;
                    const normalizeBtn = (btn) => {
                        if (!btn || !(btn instanceof Element)) return;
                        try {
                            btn.removeAttribute('disabled');
                            btn.removeAttribute('aria-disabled');
                        } catch (e) {}
                        try {
                            const cls = String(btn.className || '');
                            if (/(?:^|\s)(?:signin|btn-signin|disabled|is-disabled|forbid|forbidden)(?:\s|$)/i.test(cls)) {
                                const list = String(cls).split(/\s+/g).filter(Boolean);
                                for (let i = 0; i < list.length; i++) {
                                    const c = list[i];
                                    if (/(?:signin|btn-signin|disabled|is-disabled|forbid|forbidden)/i.test(c)) {
                                        try { btn.classList.remove(c); } catch (e) {}
                                    }
                                }
                            }
                        } catch (e) {}
                        try {
                            btn.style && btn.style.setProperty && btn.style.setProperty('cursor', 'pointer', 'important');
                        } catch (e) {}
                    };
                    const resetHljsButtonTitle = (btn) => {
                        if (!btn || !(btn instanceof Element)) return;
                        normalizeBtn(btn);
                        try {
                            btn.removeAttribute('onclick');
                            btn.removeAttribute('data-report-click');
                        } catch (e) {}
                        try {
                            btn.setAttribute('data-title', 'å¤åˆ¶');
                        } catch (e2) {}
                    };
                    const resetAllHljsButtons = () => {
                        try {
                            const list = document.querySelectorAll('.hljs-button');
                            for (let i = 0; i < list.length; i++) resetHljsButtonTitle(list[i]);
                        } catch (e) {}
                    };

                    const onHljsCopyClick = (event) => {
                        const t = event && event.target;
                        if (!(t instanceof Element)) return;
                        const btn = t.closest('.hljs-button');
                        if (!btn) return;
                        normalizeBtn(btn);
                        try {
                            event.stopImmediatePropagation();
                            event.preventDefault();
                        } catch (e) {}
                        let codeText = '';
                        try {
                            const hljs = btn.closest('.hljs') || btn.closest('pre');
                            const parent = btn.parentElement;
                            const codeEl = (hljs && (hljs.querySelector('code') || hljs)) || (parent && (parent.querySelector('code') || parent));
                            const raw = codeEl ? (codeEl.innerText != null ? codeEl.innerText : codeEl.textContent) : '';
                            codeText = sanitizeCsdnCopyText(raw);
                        } catch (e2) {
                            codeText = '';
                        }
                        if (!codeText) return;
                        copyTextToClipboard(codeText).then((ok) => {
                            if (!ok) {
                                try { showPassiveTip('CSDNï¼šå¤åˆ¶å¤±è´¥'); } catch (e) {}
                                return;
                            }
                            try {
                                btn.setAttribute('data-title', 'å¤åˆ¶æˆåŠŸ');
                            } catch (e2) {}
                            try { showPassiveTip('CSDNï¼šå¤åˆ¶æˆåŠŸ'); } catch (e3) {}
                        });
                    };

                    const onPreHover = (event) => {
                        const t = event && event.target;
                        if (!t || t.localName !== 'pre') return;
                        const btn = t.querySelector && t.querySelector('.hljs-button');
                        if (!btn) return;
                        resetHljsButtonTitle(btn);
                        if (resetTimer) return;
                        resetTimer = setTimeout(() => {
                            resetTimer = 0;
                            resetAllHljsButtons();
                        }, 80);
                    };

                    document.addEventListener('click', onHljsCopyClick, true);
                    document.addEventListener('mouseenter', onPreHover, true);
                    document.addEventListener('mouseleave', onPreHover, true);
                    initTimer = setTimeout(resetAllHljsButtons, 250);

                    csdnClipboardBypassStop = () => {
                        try {
                            document.removeEventListener('click', onHljsCopyClick, true);
                            document.removeEventListener('mouseenter', onPreHover, true);
                            document.removeEventListener('mouseleave', onPreHover, true);
                        } catch (e) {}
                        try { if (initTimer) clearTimeout(initTimer); } catch (e2) {}
                        try { if (resetTimer) clearTimeout(resetTimer); } catch (e3) {}
                        initTimer = 0;
                        resetTimer = 0;
                    };
                }
            }

            function applyCsdnStrongCopy(active) {
                const shouldEnable = Boolean(active) && isCsdnHost(getCurrentHost());
                if (!shouldEnable) return stopCsdnStrongCopy();
                startCsdnStrongCopy();
            }

            function stopPanCodeAssist() {
                if (!panCodeAssistStop) return;
                try {
                    panCodeAssistStop();
                } catch (e) {}
                panCodeAssistStop = null;
            }

            function normalizePanCodeValue(code) {
                const v = String(code || '').trim();
                if (!v) return '';
                if (/^wss:[a-zA-Z0-9]+$/.test(v)) return v;
                if (!/^[a-zA-Z0-9]{3,8}$/.test(v)) return '';
                return v;
            }

            function getPanCodeProviderInfoByHost(hostRaw) {
                const host = String(hostRaw || '').trim().toLowerCase();
                if (!host) return null;
                const direct = PanCodeProviderIndex.exactMap.get(host);
                if (direct) return direct;
                const matchers = PanCodeProviderIndex.matchers;
                for (let i = 0; i < matchers.length; i++) {
                    const m = matchers[i];
                    if (!m || typeof m.test !== 'function') continue;
                    let ok = false;
                    try {
                        ok = !!m.test(host);
                    } catch (e) {
                        ok = false;
                    }
                    if (ok) return m.info;
                }
                return null;
            }

            function getPanCodeProviderInfoByHref(href) {
                let u;
                try {
                    u = new URL(String(href || ''), location.href);
                } catch (e) {
                    return null;
                }
                return getPanCodeProviderInfoByHost(u.hostname);
            }

            function sanitizePanShareUrl(hrefRaw) {
                const href = String(hrefRaw || '').trim();
                if (!href) return '';
                let u;
                try {
                    u = new URL(href, location.href);
                } catch (e) {
                    return href;
                }
                const info = getPanCodeProviderInfoByHost(u.hostname);
                if (!info) return href;
                try {
                    const hash = String(u.hash || '');
                    if (hash && hash.startsWith('#')) {
                        const c = normalizePanCodeValue(hash.slice(1));
                        if (c) u.hash = '';
                    }
                } catch (e) {}
                try {
                    let path = String(u.pathname || '');
                    const m = /[,\sï¼Œã€‚ï¼›;ï¼š:ã€ã€ã€‘\[\]ï¼ˆï¼‰()<>ã€Šã€‹"'â€œâ€â€˜â€™\u4E00-\u9FFF]/.exec(path);
                    if (m && typeof m.index === 'number' && m.index > 0) path = path.slice(0, m.index);
                    if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
                    u.pathname = path;
                } catch (e) {}
                try {
                    return u.toString();
                } catch (e) {
                    return href;
                }
            }

            function extractPanCodeFromText(textRaw) {
                const text = String(textRaw || '');
                if (!text) return '';
                const base = text
                    .replace(/\s+/g, ' ')
                    .replace(/[ï¼šï¹•]/g, ':')
                    .replace(/[ï¼]/g, '=')
                    .replace(/[ï¼â€“â€”]/g, '-')
                    .trim();
                if (!base) return '';
                const s = base
                    .replace(/[ã€ï¼»ï½›]/g, '[')
                    .replace(/[ã€‘ï¼½ï½]/g, ']')
                    .replace(/[ï¼ˆ]/g, '(')
                    .replace(/[ï¼‰]/g, ')');
                const loose = s
                    .replace(/[\[\]ã€ã€‘()ï¼ˆï¼‰{}ã€Œã€â€œâ€â€˜â€™]/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                const isLikelyFalseToken = (c) => {
                    const v = String(c || '').trim().toLowerCase();
                    if (!v) return true;
                    if (v === 'http' || v === 'https') return true;
                    if (v === 'www') return true;
                    if (v === 'com' || v === 'net' || v === 'org' || v === 'cn') return true;
                    return false;
                };
                const patternsBracket = [
                    /(?:æå–ç |æå–ç¢¼|æå–|è®¿é—®ç |è¨ªå•ç¢¼|å¯†ç |å¯†ç¢¼|å¯†é’¥|å¯†é‘°|å£ä»¤|åˆ†äº«ç |åˆ†äº«ç¢¼|åˆ†äº«|\bcode\b|\bkey\b|\bpwd\b|\bpass(?:word)?\b)\s*(?::|=|-|\s)*[\[({ï¼ˆã€]\s*(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})\s*[\])}ï¼‰ã€‘]/i,
                    /[\[({ï¼ˆã€]\s*(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})\s*[\])}ï¼‰ã€‘]\s*(?:æå–ç |æå–ç¢¼|æå–|è®¿é—®ç |è¨ªå•ç¢¼|å¯†ç |å¯†ç¢¼|å¯†é’¥|å¯†é‘°|å£ä»¤|åˆ†äº«ç |åˆ†äº«ç¢¼|åˆ†äº«)/i,
                ];
                for (let i = 0; i < patternsBracket.length; i++) {
                    const m = patternsBracket[i].exec(s);
                    if (m && m[1]) {
                        const c = normalizePanCodeValue(m[1]);
                        if (c && !isLikelyFalseToken(c)) return c;
                    }
                }
                if (!loose) return '';
                const patterns = [
                    /(wss:[a-zA-Z0-9]+)/i,
                    /[?#&](?:p|pwd|pass|password|key)\s*=?\s*(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})(?![a-zA-Z0-9])/i,
                    /#\s*(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})\b/i,
                    /(?:æå–ç |æå–ç¢¼|æå–|è®¿é—®ç |è¨ªå•ç¢¼|å¯†ç |å¯†ç¢¼|å¯†é’¥|å¯†é‘°|å£ä»¤|\bcode\b|\bkey\b|\bpwd\b|\bpass(?:word)?\b)\s*(?::|=|-|\s)\s*(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})(?![a-zA-Z0-9])/i,
                    /(?:æå–ç |æå–ç¢¼|æå–|è®¿é—®ç |è¨ªå•ç¢¼|å¯†ç |å¯†ç¢¼|å¯†é’¥|å¯†é‘°|å£ä»¤|\bcode\b|\bkey\b|\bpwd\b|\bpass(?:word)?\b)[^a-zA-Z0-9]{0,6}(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})(?![a-zA-Z0-9])/i,
                    /(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})(?![a-zA-Z0-9])\s*(?:æå–ç |æå–ç¢¼|æå–|è®¿é—®ç |è¨ªå•ç¢¼|å¯†ç |å¯†ç¢¼|å¯†é’¥|å¯†é‘°|å£ä»¤)/i,
                    /(?:^|\s)(?:å¯†é’¥|å¯†é‘°|å¯†ç¢¼|å¯†ç |æå–|è®¿é—®|è¨ªå•|\bkey\b|\bpassword\b|\bpwd\b|\bpass\b)\s*(?:ç |ç¢¼)?\s*(?::|=|-)\s*(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})(?![a-zA-Z0-9])/i,
                    /(?:åˆ†äº«ç |åˆ†äº«ç¢¼)\s*(?::|=|-|\s)\s*(wss:[a-zA-Z0-9]+|[a-zA-Z0-9]{3,8})/i,
                ];
                for (let i = 0; i < patterns.length; i++) {
                    const m = patterns[i].exec(loose);
                    if (m && m[1]) {
                        const c = normalizePanCodeValue(m[1]);
                        if (c && !isLikelyFalseToken(c)) return c;
                    }
                }
                return '';
            }

            function extractPanCodeFromUrl(href) {
                let u;
                try {
                    u = new URL(String(href || ''), location.href);
                } catch (e) {
                    return '';
                }
                const search = u.searchParams;
                const keys = [
                    'pwd',
                    'code',
                    'passcode',
                    'access_code',
                    'accessCode',
                    'extract_code',
                    'extractCode',
                    'extraction_code',
                    'password',
                    'passwd',
                    'pass',
                    'p',
                    'k',
                ];
                for (let i = 0; i < keys.length; i++) {
                    const v = search.get(keys[i]);
                    const code = normalizePanCodeValue(v);
                    if (code) return code;
                }
                const hash = String(u.hash || '').replace(/^#/, '');
                if (hash && hash.indexOf('=') !== -1) {
                    try {
                        const hp = new URLSearchParams(hash);
                        for (let i = 0; i < keys.length; i++) {
                            const v = hp.get(keys[i]);
                            const code = normalizePanCodeValue(v);
                            if (code) return code;
                        }
                    } catch (e) {}
                }
                return '';
            }

            function normalizePanCodeCacheKey(href) {
                let u;
                try {
                    u = new URL(String(href || ''), location.href);
                } catch (e) {
                    return '';
                }
                const host = String(u.hostname || '').toLowerCase();
                const info = getPanCodeProviderInfoByHost(host);
                if (!info) return '';
                let path = String(u.pathname || '');
                if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
                if (info.key === '115') {
                    const m = /^\/s\/([a-zA-Z0-9_-]+)$/.exec(path);
                    if (m && m[1]) return `115/s/${m[1]}`;
                    return `115${path}`;
                }
                if (info.key === 'baidu') {
                    const sp = u.searchParams;
                    const su = String(sp.get('surl') || '').trim();
                    if (su) return `${host}?surl=${su}`;
                    const shareId = String(sp.get('shareid') || '').trim();
                    if (shareId) return `${host}?shareid=${shareId}`;
                    const m = /^\/s\/([a-zA-Z0-9_-]+)$/.exec(path);
                    if (m && m[1]) {
                        let id = String(m[1] || '');
                        if (id.startsWith('1') && id.length > 1) id = id.slice(1);
                        if (id) return `${host}?surl=${id}`;
                    }
                }
                if (info.key === 'weiyun') {
                    const sp = u.searchParams;
                    const shareId = String(sp.get('shareid') || sp.get('shareId') || '').trim();
                    if (shareId) return `${host}${path}?shareid=${shareId}`;
                    const shareKey = String(sp.get('sharekey') || sp.get('shareKey') || sp.get('skey') || sp.get('share_key') || '').trim();
                    if (shareKey) return `${host}${path}?sharekey=${shareKey}`;
                }
                if (info.key === '189') {
                    const sp = u.searchParams;
                    const shareCode = String(sp.get('code') || sp.get('shareCode') || sp.get('sharecode') || '').trim();
                    if (shareCode) return `189?code=${shareCode}`;
                    const m = /^\/t\/([a-zA-Z0-9]+)$/.exec(path);
                    if (m && m[1]) return `189?code=${m[1]}`;
                    const h = String(u.hash || '').replace(/^#/, '');
                    if (h && h.indexOf('=') !== -1) {
                        try {
                            const hp = new URLSearchParams(h);
                            const hc = String(hp.get('code') || hp.get('shareCode') || hp.get('sharecode') || '').trim();
                            if (hc) return `189?code=${hc}`;
                        } catch (e) {}
                    }
                }
                return `${host}${path}`;
            }

            function readPanCodeCache() {
                const raw = getValue(PAN_CODE_CACHE_STORAGE_KEY, null);
                const data = raw && typeof raw === 'object' ? raw : null;
                const items = data && Array.isArray(data.items) ? data.items : [];
                const now = Date.now();
                const keepMs = 1000 * 60 * 60 * 24 * 7;
                const nextItems = [];
                for (let i = 0; i < items.length; i++) {
                    const it = items[i];
                    if (!it || !Array.isArray(it) || it.length < 3) continue;
                    const k = String(it[0] || '');
                    const c = normalizePanCodeValue(it[1]);
                    const t = Number(it[2]);
                    if (!k || !c || !Number.isFinite(t)) continue;
                    if (now - t > keepMs) continue;
                    nextItems.push([k, c, t]);
                }
                if (nextItems.length > 50) nextItems.splice(0, nextItems.length - 50);
                return { v: 1, t: now, items: nextItems };
            }

            function writePanCodeCache(cache) {
                const data = cache && typeof cache === 'object' ? cache : null;
                const items = data && Array.isArray(data.items) ? data.items : [];
                setValue(PAN_CODE_CACHE_STORAGE_KEY, { v: 1, t: Date.now(), items });
            }

            function removeValue(key) {
                const k = String(key || '').trim();
                if (!k) return;
                if (typeof GM_deleteValue === 'function') {
                    try {
                        GM_deleteValue(k);
                        return;
                    } catch (e) {}
                }
                try {
                    localStorage.removeItem(`${STORAGE_PREFIX}${k}`);
                } catch (e2) {}
            }

            function stashPendingPanCode(codeRaw, ctxRaw) {
                const code = normalizePanCodeValue(codeRaw);
                if (!code) return false;
                const ctx = ctxRaw && typeof ctxRaw === 'object' ? ctxRaw : null;
                const providerKey = ctx ? String(ctx.providerKey || '').trim() : '';
                const cacheKey = ctx ? String(ctx.cacheKey || '').trim() : '';
                setValue(PAN_CODE_PENDING_STORAGE_KEY, { v: 2, t: Date.now(), code, providerKey, cacheKey });
                return true;
            }

            function consumePendingPanCode(maxAgeMs, ctxRaw) {
                const maxAge = Number(maxAgeMs);
                const raw = getValue(PAN_CODE_PENDING_STORAGE_KEY, null);
                const data = raw && typeof raw === 'object' ? raw : null;
                const t = data && typeof data.t === 'number' ? data.t : 0;
                const code = data && typeof data.code === 'string' ? normalizePanCodeValue(data.code) : '';
                const providerKey = data ? String(data.providerKey || '').trim() : '';
                const cacheKey = data ? String(data.cacheKey || '').trim() : '';
                const now = Date.now();
                if (!t || !code) {
                    removeValue(PAN_CODE_PENDING_STORAGE_KEY);
                    return '';
                }
                if (Number.isFinite(maxAge) && maxAge > 0 && now - t > maxAge) {
                    removeValue(PAN_CODE_PENDING_STORAGE_KEY);
                    return '';
                }
                const ctx = ctxRaw && typeof ctxRaw === 'object' ? ctxRaw : null;
                if (ctx) {
                    const wantProviderKey = String(ctx.providerKey || '').trim();
                    const wantCacheKey = String(ctx.cacheKey || '').trim();
                    if (providerKey && wantProviderKey && providerKey !== wantProviderKey) return '';
                    if (cacheKey && wantCacheKey && cacheKey !== wantCacheKey) {
                        const allowRedirect = providerKey && wantProviderKey && providerKey === wantProviderKey && now - t <= 45000;
                        if (!allowRedirect) return '';
                    }
                }
                removeValue(PAN_CODE_PENDING_STORAGE_KEY);
                return code;
            }

            function normalizePanCodeEntryFromArray(it) {
                if (!it || !Array.isArray(it) || it.length < 5) return null;
                const key = String(it[0] || '').trim();
                const href = String(it[1] || '').trim();
                const code = normalizePanCodeValue(it[2]);
                const provider = String(it[3] || '').trim();
                const t = Number(it[4]);
                if (!key || !href || !code || !provider || !Number.isFinite(t) || t <= 0) return null;
                return [key, href, code, provider, t];
            }

            function readPanCodeHistory(currentSettings) {
                const s = currentSettings && typeof currentSettings === 'object' ? currentSettings : settings;
                const limit = Math.max(10, Math.min(1000, Number(s.panCodeHistoryLimit) || 100));
                const raw = getValue(PAN_CODE_HISTORY_STORAGE_KEY, null);
                const data = raw && typeof raw === 'object' ? raw : null;
                const items = data && Array.isArray(data.items) ? data.items : [];
                const now = Date.now();
                const keepMs = 1000 * 60 * 60 * 24 * 90;
                const keep = [];
                for (let i = items.length - 1; i >= 0 && keep.length < limit; i--) {
                    const norm = normalizePanCodeEntryFromArray(items[i]);
                    if (!norm) continue;
                    if (now - norm[4] > keepMs) continue;
                    keep.push(norm);
                }
                keep.reverse();
                return { v: 1, t: now, items: keep };
            }

            function writePanCodeHistory(hist) {
                const data = hist && typeof hist === 'object' ? hist : null;
                const itemsRaw = data && Array.isArray(data.items) ? data.items : [];
                const items = [];
                for (let i = 0; i < itemsRaw.length; i++) {
                    const norm = normalizePanCodeEntryFromArray(itemsRaw[i]);
                    if (!norm) continue;
                    items.push(norm);
                    if (items.length >= 1200) break;
                }
                setValue(PAN_CODE_HISTORY_STORAGE_KEY, { v: 1, t: Date.now(), items });
            }

            function readPanCodeFavorites() {
                const raw = getValue(PAN_CODE_FAVORITES_STORAGE_KEY, null);
                const data = raw && typeof raw === 'object' ? raw : null;
                const items = data && Array.isArray(data.items) ? data.items : [];
                const now = Date.now();
                const out = [];
                for (let i = 0; i < items.length; i++) {
                    const norm = normalizePanCodeEntryFromArray(items[i]);
                    if (!norm) continue;
                    out.push(norm);
                }
                if (out.length > 300) out.splice(0, out.length - 300);
                return { v: 1, t: now, items: out };
            }

            function writePanCodeFavorites(fav) {
                const data = fav && typeof fav === 'object' ? fav : null;
                const itemsRaw = data && Array.isArray(data.items) ? data.items : [];
                const items = [];
                for (let i = 0; i < itemsRaw.length; i++) {
                    const norm = normalizePanCodeEntryFromArray(itemsRaw[i]);
                    if (!norm) continue;
                    items.push(norm);
                    if (items.length >= 300) break;
                }
                setValue(PAN_CODE_FAVORITES_STORAGE_KEY, { v: 1, t: Date.now(), items });
            }

            function upsertPanCodeFavorite(entry) {
                const norm = normalizePanCodeEntryFromArray(entry);
                if (!norm) return false;
                const key = norm[0];
                const fav = readPanCodeFavorites();
                const items = fav.items || [];
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = normalizePanCodeEntryFromArray(items[i]);
                    if (!it) {
                        items.splice(i, 1);
                        continue;
                    }
                    if (it[0] === key) items.splice(i, 1);
                }
                items.push(norm);
                if (items.length > 300) items.splice(0, items.length - 300);
                writePanCodeFavorites(fav);
                return true;
            }

            function removePanCodeFavoriteByKey(keyRaw) {
                const key = String(keyRaw || '').trim();
                if (!key) return false;
                const fav = readPanCodeFavorites();
                const items = fav.items || [];
                let changed = false;
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = normalizePanCodeEntryFromArray(items[i]);
                    if (!it) {
                        items.splice(i, 1);
                        changed = true;
                        continue;
                    }
                    if (it[0] !== key) continue;
                    items.splice(i, 1);
                    changed = true;
                }
                if (changed) writePanCodeFavorites(fav);
                return changed;
            }

            function recordPanCodeForHref(href, code) {
                const c = normalizePanCodeValue(code);
                if (!c) return;
                const key = normalizePanCodeCacheKey(href);
                if (!key) return;
                const cache = readPanCodeCache();
                const items = cache.items || [];
                const now = Date.now();
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = items[i];
                    if (!it || !Array.isArray(it) || String(it[0] || '') !== key) continue;
                    items.splice(i, 1);
                }
                items.push([key, c, now]);
                if (items.length > 50) items.splice(0, items.length - 50);
                writePanCodeCache(cache);

                try {
                    if (settings && settings.panCodeHistoryEnabled) {
                        const info = getPanCodeProviderInfoByHref(href);
                        const provider = info && info.provider ? String(info.provider) : '';
                        if (provider) {
                            let mergedHref = String(href || '').trim();
                            if (info && info.queryKey) {
                                const merged = mergePanCodeIntoUrl(mergedHref, info, c);
                                if (merged) mergedHref = merged;
                            }
                            const entry = [key, mergedHref, c, provider, now];
                            const hist = readPanCodeHistory(settings);
                            const list = hist.items || [];
                            for (let i = list.length - 1; i >= 0; i--) {
                                const it = normalizePanCodeEntryFromArray(list[i]);
                                if (!it) {
                                    list.splice(i, 1);
                                    continue;
                                }
                                if (it[0] === key) list.splice(i, 1);
                            }
                            list.push(entry);
                            const limit = Math.max(10, Math.min(1000, Number(settings.panCodeHistoryLimit) || 100));
                            if (list.length > limit) list.splice(0, list.length - limit);
                            writePanCodeHistory(hist);

                            const fav = readPanCodeFavorites();
                            const favItems = fav.items || [];
                            for (let i = favItems.length - 1; i >= 0; i--) {
                                const it = normalizePanCodeEntryFromArray(favItems[i]);
                                if (!it) {
                                    favItems.splice(i, 1);
                                    continue;
                                }
                                if (it[0] !== key) continue;
                                favItems.splice(i, 1);
                                favItems.push(entry);
                                writePanCodeFavorites(fav);
                                break;
                            }
                        }
                    }
                } catch (e) {}
            }

            function resolveCachedPanCodeForHref(href) {
                const key = normalizePanCodeCacheKey(href);
                if (!key) return '';
                const cache = readPanCodeCache();
                const items = cache.items || [];
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = items[i];
                    if (!it || !Array.isArray(it) || it.length < 2) continue;
                    if (String(it[0] || '') !== key) continue;
                    return normalizePanCodeValue(it[1]);
                }
                return '';
            }

            function mergePanCodeIntoUrl(href, info, code) {
                const c = normalizePanCodeValue(code);
                if (!c) return '';
                let u;
                try {
                    u = new URL(String(href || ''), location.href);
                } catch (e) {
                    return '';
                }
                const existing = extractPanCodeFromUrl(u.toString());
                if (existing) return u.toString();
                const queryKey = info && info.queryKey ? String(info.queryKey) : '';
                if (!queryKey) return '';
                try {
                    u.searchParams.set(queryKey, c);
                } catch (e) {
                    return '';
                }
                return u.toString();
            }

            function setInputValueWithEvents(input, value) {
                if (!input) return;
                try {
                    input.focus();
                } catch (e) {}
                try {
                    const v = String(value);
                    const proto = input instanceof HTMLTextAreaElement ? HTMLTextAreaElement.prototype : HTMLInputElement.prototype;
                    const desc = Object.getOwnPropertyDescriptor(proto, 'value');
                    const setter = desc && typeof desc.set === 'function' ? desc.set : null;
                    if (setter) setter.call(input, v);
                    else input.value = v;
                } catch (e2) {
                    try {
                        input.value = String(value);
                    } catch (e3) {}
                }
                try {
                    if (typeof InputEvent === 'function') input.dispatchEvent(new InputEvent('input', { bubbles: true, data: String(value), inputType: 'insertText' }));
                    else input.dispatchEvent(new Event('input', { bubbles: true }));
                } catch (e3) {}
                try {
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                } catch (e4) {}
            }

            function isElementDisabled(el) {
                if (!el || !(el instanceof Element)) return true;
                try {
                    const disabled = el.getAttribute && el.getAttribute('disabled');
                    if (disabled != null) return true;
                } catch (e) {}
                try {
                    if ('disabled' in el && el.disabled) return true;
                } catch (e2) {}
                try {
                    const aria = String(el.getAttribute && el.getAttribute('aria-disabled') ? el.getAttribute('aria-disabled') : '').trim().toLowerCase();
                    if (aria === 'true') return true;
                } catch (e3) {}
                return false;
            }

            function safeClickElement(el) {
                if (!el || !(el instanceof Element)) return false;
                if (!isElementVisible(el)) return false;
                if (isElementDisabled(el)) return false;
                try {
                    if (typeof el.scrollIntoView === 'function') el.scrollIntoView({ block: 'center', inline: 'center' });
                } catch (e) {}
                try {
                    if (typeof el.focus === 'function') el.focus();
                } catch (e2) {}
                const fire = (Ctor, type) => {
                    try {
                        el.dispatchEvent(new Ctor(type, { bubbles: true, cancelable: true, view: window }));
                    } catch (e) {}
                };
                if (typeof PointerEvent === 'function') {
                    fire(PointerEvent, 'pointerdown');
                    fire(PointerEvent, 'pointerup');
                }
                fire(MouseEvent, 'mousedown');
                fire(MouseEvent, 'mouseup');
                fire(MouseEvent, 'click');
                try {
                    if (typeof el.click === 'function') el.click();
                } catch (e2) {}
                return true;
            }

            function tryLockPanCodeAutoFill(sigRaw, ttlMsRaw) {
                const sig = String(sigRaw || '').trim();
                const ttlMs = Math.max(300, Math.min(10000, Number(ttlMsRaw) || 1800));
                if (!sig) return true;
                let now = 0;
                try {
                    now = Date.now();
                    const raw = sessionStorage.getItem(PAN_CODE_AUTOFILL_LOCK_KEY) || '';
                    const data = safeJsonParse(raw, null);
                    if (data && typeof data === 'object') {
                        const t = typeof data.t === 'number' ? data.t : 0;
                        const prev = String(data.sig || '');
                        if (t && prev && prev === sig && now - t < ttlMs) return false;
                    }
                    sessionStorage.setItem(PAN_CODE_AUTOFILL_LOCK_KEY, JSON.stringify({ t: now, sig }));
                    return true;
                } catch (e) {
                    return true;
                }
            }

            function isElementVisible(el) {
                if (!el || !(el instanceof Element)) return false;
                try {
                    const cs = window.getComputedStyle ? getComputedStyle(el) : null;
                    if (cs && (cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0')) return false;
                } catch (e) {}
                const rect = el.getBoundingClientRect ? el.getBoundingClientRect() : null;
                if (!rect) return true;
                return rect.width > 0 && rect.height > 0;
            }

            function collectQueryRootsForAutoFill(startRoot, maxNodesRaw) {
                const roots = [];
                const seen = new Set();
                const queue = [];
                const maxNodes = Math.max(200, Math.min(8000, Number(maxNodesRaw) || 2500));

                const pushRoot = (r) => {
                    if (!r) return;
                    if (seen.has(r)) return;
                    seen.add(r);
                    roots.push(r);
                    queue.push(r);
                };

                pushRoot(startRoot || document);

                let scanned = 0;
                while (queue.length && scanned < maxNodes && roots.length < 40) {
                    const root = queue.shift();
                    if (!root) continue;
                    let doc = null;
                    try {
                        if (root instanceof Document) doc = root;
                        else doc = root.ownerDocument || document;
                    } catch (e) {
                        doc = document;
                    }
                    let startNode = null;
                    try {
                        if (root instanceof Document) startNode = root.documentElement || root;
                        else startNode = root;
                    } catch (e2) {
                        startNode = null;
                    }
                    if (!startNode) continue;
                    let tw = null;
                    try {
                        tw = doc.createTreeWalker(startNode, NodeFilter.SHOW_ELEMENT, null, false);
                    } catch (e3) {
                        tw = null;
                    }
                    if (!tw) continue;
                    let node = null;
                    while ((node = tw.nextNode())) {
                        scanned++;
                        if (scanned >= maxNodes) break;
                        const el = node;
                        if (!el || !(el instanceof Element)) continue;
                        try {
                            const sr = el.shadowRoot;
                            if (sr) pushRoot(sr);
                        } catch (e4) {}
                        if (String(el.tagName || '').toUpperCase() === 'IFRAME') {
                            try {
                                const d = el.contentDocument;
                                if (d) pushRoot(d);
                            } catch (e5) {}
                        }
                    }
                }
                return roots;
            }

            function findFirstVisibleDeep(selector, rootsRaw) {
                const sel = String(selector || '').trim();
                if (!sel) return null;
                const roots = Array.isArray(rootsRaw) && rootsRaw.length ? rootsRaw : collectQueryRootsForAutoFill(document, 2500);
                for (let i = 0; i < roots.length; i++) {
                    const el = findFirstVisible(roots[i], sel);
                    if (el) return el;
                }
                return null;
            }

            function findFirstVisible(root, selector) {
                const base = root || document;
                let list = [];
                try {
                    list = base.querySelectorAll(selector);
                } catch (e) {
                    return null;
                }
                for (let i = 0; i < list.length; i++) {
                    const el = list[i];
                    if (isElementVisible(el)) return el;
                }
                return null;
            }

            function findFirstClickableByText(root, re) {
                const base = root || document;
                let list = [];
                try {
                    list = base.querySelectorAll('button, input[type="submit"], a, div[role="button"], span[role="button"]');
                } catch (e) {
                    return null;
                }
                for (let i = 0; i < list.length; i++) {
                    const el = list[i];
                    if (!isElementVisible(el)) continue;
                    const tag = String(el.tagName || '').toUpperCase();
                    let text = '';
                    if (tag === 'INPUT') text = String(el.value || '');
                    else text = String(el.textContent || '');
                    text = text.replace(/\s+/g, ' ').trim();
                    if (!text) continue;
                    if (re.test(text)) return el;
                }
                return null;
            }

            function findFirstClickableByTextLoose(root, re) {
                const base = root || document;
                let list = [];
                try {
                    list = base.querySelectorAll('button, input[type="submit"], a, div, span');
                } catch (e) {
                    return null;
                }
                for (let i = 0; i < list.length; i++) {
                    const el = list[i];
                    if (!isElementVisible(el)) continue;
                    if (isElementDisabled(el)) continue;
                    const tag = String(el.tagName || '').toUpperCase();
                    let text = '';
                    if (tag === 'INPUT') text = String(el.value || '');
                    else text = String(el.textContent || '');
                    text = text.replace(/\s+/g, ' ').trim();
                    if (!text) continue;
                    if (!re.test(text)) continue;
                    if (tag === 'BUTTON' || tag === 'A' || tag === 'INPUT') return el;
                    let role = '';
                    try {
                        role = String(el.getAttribute('role') || '').trim().toLowerCase();
                    } catch (e2) {
                        role = '';
                    }
                    if (role === 'button') return el;
                    try {
                        const tabindex = el.getAttribute('tabindex');
                        if (tabindex != null && String(tabindex).trim() !== '') return el;
                    } catch (e3) {}
                    try {
                        if (el.getAttribute('onclick') != null) return el;
                    } catch (e4) {}
                    try {
                        const cls = String(el.className || '').toLowerCase();
                        if (cls.indexOf('btn') !== -1 || cls.indexOf('button') !== -1) return el;
                    } catch (e5) {}
                    try {
                        const cs = window.getComputedStyle ? getComputedStyle(el) : null;
                        if (cs && cs.cursor === 'pointer') return el;
                    } catch (e6) {}
                }
                return null;
            }

            function maskPanCodeForLog(codeRaw) {
                const c = normalizePanCodeValue(codeRaw);
                if (!c) return '';
                if (c.length <= 2) return '*'.repeat(c.length);
                return `${c.slice(0, 1)}${'*'.repeat(c.length - 2)}${c.slice(-1)}`;
            }

            function readPanCodeFailures() {
                const raw = getValue(PAN_CODE_FAILURE_STORAGE_KEY, null);
                const data = raw && typeof raw === 'object' ? raw : null;
                const items = data && Array.isArray(data.items) ? data.items : [];
                const now = Date.now();
                const keepMs = 1000 * 60 * 60 * 24 * 30;
                const out = [];
                for (let i = 0; i < items.length; i++) {
                    const it = items[i];
                    if (!it || typeof it !== 'object') continue;
                    const t = typeof it.t === 'number' ? it.t : 0;
                    if (!t || now - t > keepMs) continue;
                    out.push(it);
                }
                if (out.length > 80) out.splice(0, out.length - 80);
                return { v: 1, t: now, items: out };
            }

            function writePanCodeFailures(list) {
                const itemsRaw = Array.isArray(list) ? list : [];
                const items = [];
                for (let i = 0; i < itemsRaw.length; i++) {
                    const it = itemsRaw[i];
                    if (!it || typeof it !== 'object') continue;
                    items.push(it);
                    if (items.length >= 120) break;
                }
                setValue(PAN_CODE_FAILURE_STORAGE_KEY, { v: 1, t: Date.now(), items });
            }

            function recordPanCodeFailure(kindRaw, payloadRaw) {
                const kind = String(kindRaw || '').trim();
                if (!kind) return false;
                const host = getCurrentHost();
                if (!host) return false;
                const payload = payloadRaw && typeof payloadRaw === 'object' ? payloadRaw : { value: payloadRaw };
                const entry = {
                    id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
                    t: Date.now(),
                    kind,
                    host,
                    url: String(location.href || ''),
                    payload,
                };
                try {
                    const f = readPanCodeFailures();
                    const items = f.items || [];
                    items.push(entry);
                    if (items.length > 80) items.splice(0, items.length - 80);
                    writePanCodeFailures(items);
                } catch (e) {}
                try {
                    debugLog('panCodeFailure', () => entry, 'WARN');
                } catch (e2) {}
                return true;
            }

            const PAN_CODE_AUTOFILL_SELECTORS = {
                baidu: {
                    input: [
                        '#accessCode',
                        '.share-access-code',
                        '.wpdoc-layout-sharepage .u-dialog__wrapper input.u-input__inner',
                        '.wpdoc-layout-sharepage .u-dialog__wrapper .u-input__inner',
                        '.u-dialog__wrapper input.u-input__inner',
                        '.u-dialog__wrapper .u-input__inner',
                    ],
                    button: [
                        '#submitBtn',
                        '.share-access .g-button',
                        '.wpdoc-layout-sharepage .u-dialog__wrapper .u-btn--primary',
                        '.u-dialog__wrapper .u-btn--primary',
                    ],
                },
                aliyun: {
                    input: ['form .ant-input', 'form input[type="text"]', 'input[name="pwd"]'],
                    button: ['form .button--fep7l', 'form button[type="submit"]'],
                },
                weiyun: {
                    input: ['.mod-card-s input[type=password]', 'input.pw-input'],
                    button: ['.mod-card-s .btn-main', '.pw-btn-wrap button.btn'],
                },
                lanzou: { input: ['#pwd'], button: ['.passwddiv-btn', '#sub'] },
                '189': {
                    input: [
                        '.access-code-item #code_txt',
                        'input#code_txt',
                        '.access-code-item input',
                        'input.access-code-input',
                        'input[placeholder*="è®¿é—®ç "]',
                        'input[placeholder*="è®¿é—®"]',
                    ],
                    button: ['.access-code-item .visit', '.access-code-item button', '.visit', '.button'],
                },
                caiyun: {
                    input: [
                        '.token-form input[type=text]',
                        '.token-form input',
                        '.bar-input-group input[type="text"]',
                        '.bar-input-group input',
                        'input[placeholder="è¯·è¾“å…¥æå–ç "]',
                        'input[name="token"]',
                        'input[name="code"]',
                        'input[name="pwd"]',
                    ],
                    button: ['.token-form .btn-token', '.token-form button', '.btn-token', '.bar-token', '.bar-token button'],
                },
                xunlei: { input: ['.pass-input-wrap .td-input__inner'], button: ['.pass-input-wrap .td-button'] },
                '123pan': { input: ['.ca-fot input', '.appinput .appinput'], button: ['.ca-fot button', '.appinput button'] },
                '360': { input: ['.pwd-input', 'input.pwd-input', 'input[placeholder*="æå–ç "]'], button: ['.submit-btn', 'button.submit-btn'] },
                '115': {
                    input: ['.form-decode input', 'input[placeholder*="è®¿é—®ç "]', 'input[placeholder="è¯·è¾“å…¥è®¿é—®ç "]', 'input.w-full.text-center'],
                    button: ['.form-decode .submit a', 'button.w-full.py-3', 'button[type="submit"]'],
                },
                cowtransfer: { input: ['.receive-code-input input'], button: ['.open-button'] },
                ctfile: { input: ['#passcode'], button: ['.card-body button'] },
                quark: { input: ['.ant-input'], button: ['.ant-btn-primary'] },
                vdisk: { input: ['#keypass', '#access_code'], button: ['.search_btn_wrap a', '#linkcommon_btn'] },
                wenshushu: { input: ['.pwd-inp .ivu-input'], button: ['.pwd-inp .ivu-btn'] },
                uc: { input: ["input[class*='ShareReceivePC--input']", '.input-wrap input'], button: ["button[class*='ShareReceivePC--submit-btn']", '.input-wrap button'] },
                jianguoyun: { input: ['input[type=password]'], button: ['.ok-button', '.confirm-button'] },
                wo: { input: ['input.el-input__inner', '.van-field__control'], button: ['.s-button', '.share-code button'] },
                mega: { input: ['.dlkey-dialog input'], button: ['.dlkey-dialog .fm-dialog-new-folder-button'] },
            };

            function tryPanCodeAutoFillOnce(info, code, queryRoots) {
                const c = normalizePanCodeValue(code);
                if (!c) return false;
                const host = getCurrentHost();
                if (!host) return false;
                const matched = getPanCodeProviderInfoByHost(host);
                if (!matched || matched.key !== (info && info.key)) return false;
                const preset = matched && matched.key ? PAN_CODE_AUTOFILL_SELECTORS[matched.key] : null;
                const inputSelectors = []
                    .concat(preset && Array.isArray(preset.input) ? preset.input : [])
                    .concat([
                    'input#accessCode',
                    'input#access_code',
                    'input#passcode',
                    'input#passCode',
                    'input[name="accessCode"]',
                    'input[name="access_code"]',
                    'input[name="pwd"]',
                    'input[name="code"]',
                    'input[name="passcode"]',
                    'input[name="password"]',
                    'input[type="password"]',
                    'input[placeholder*="æå–ç "]',
                    'input[placeholder*="æå–"]',
                    'input[placeholder*="è®¿é—®ç "]',
                    'input[placeholder*="è®¿é—®"]',
                    'input[placeholder*="å¯†ç "]',
                    'input[placeholder*="å£ä»¤"]',
                ]);
                if (matched.key === 'baidu') {
                    inputSelectors.unshift('input[type="text"][maxlength="4"]', 'input[type="tel"][maxlength="4"]', 'input[maxlength="4"]');
                }
                if (matched.key === 'xunlei') {
                    inputSelectors.push('input.td-input__inner', 'input[class*="td-input__inner"]');
                }
                const input = findFirstVisibleDeep(inputSelectors.join(', '), queryRoots);
                if (!input) return false;
                if (String(input.value || '') !== c) setInputValueWithEvents(input, c);

                const scopes = [];
                try {
                    const form = input.closest('form');
                    if (form) scopes.push(form);
                } catch (e) {
                    scopes.length = 0;
                }
                try {
                    const rn = input.getRootNode && input.getRootNode();
                    if (rn && rn instanceof ShadowRoot) {
                        scopes.push(rn);
                        if (rn.host) scopes.push(rn.host);
                    }
                } catch (e0) {}
                try {
                    const p = input.parentElement;
                    if (p) scopes.push(p);
                    const gp = p && p.parentElement ? p.parentElement : null;
                    if (gp) scopes.push(gp);
                } catch (e2) {}
                scopes.push(document);
                const uniqScopes = [];
                const seenScopes = new Set();
                for (let i = 0; i < scopes.length; i++) {
                    const s = scopes[i];
                    if (!s) continue;
                    if (seenScopes.has(s)) continue;
                    seenScopes.add(s);
                    uniqScopes.push(s);
                }

                const btnTextRe = /^(?:æå–æ–‡ä»¶|æå–|è¿›å…¥|æ‰“å¼€|ç¡®å®š|ç¡®è®¤|æäº¤|è®¿é—®|è§£é”|ç»§ç»­|å‰å¾€)$/i;
                let btn = null;
                let btnMaybeDisabled = null;
                const presetButtons = preset && Array.isArray(preset.button) && preset.button.length ? preset.button : null;
                for (let i = 0; i < uniqScopes.length; i++) {
                    const scope = uniqScopes[i];
                    if (presetButtons) {
                        const candidate = findFirstVisible(scope, presetButtons.join(', '));
                        if (candidate) {
                            if (!isElementDisabled(candidate)) {
                                btn = candidate;
                                break;
                            }
                            if (!btnMaybeDisabled) btnMaybeDisabled = candidate;
                        }
                    }
                    const submitCandidate = findFirstVisible(scope, 'button[type="submit"], input[type="submit"]');
                    if (submitCandidate) {
                        if (!isElementDisabled(submitCandidate)) {
                            btn = submitCandidate;
                            break;
                        }
                        if (!btnMaybeDisabled) btnMaybeDisabled = submitCandidate;
                    }
                    const byText = findFirstClickableByText(scope, btnTextRe);
                    if (byText) {
                        if (!isElementDisabled(byText)) {
                            btn = byText;
                            break;
                        }
                        if (!btnMaybeDisabled) btnMaybeDisabled = byText;
                    }
                    const byTextLoose = findFirstClickableByTextLoose(scope, btnTextRe);
                    if (byTextLoose) {
                        btn = byTextLoose;
                        break;
                    }
                }
                if (!btn) {
                    if (presetButtons) btn = findFirstVisibleDeep(presetButtons.join(', '), queryRoots);
                }
                if (!btn) {
                    const byText = findFirstClickableByText(document, btnTextRe) || findFirstClickableByText(document, /æå–|è¿›å…¥|æ‰“å¼€|ç¡®å®š|ç¡®è®¤|æäº¤|è®¿é—®|è§£é”|ç»§ç»­|å‰å¾€/i);
                    if (byText) {
                        if (!isElementDisabled(byText)) btn = byText;
                        else if (!btnMaybeDisabled) btnMaybeDisabled = byText;
                    }
                }
                if (!btn && btnMaybeDisabled) btn = btnMaybeDisabled;

                if (btn && btn !== input) {
                    const sig = `${matched.key}|${normalizePanCodeCacheKey(location.href)}|${c}`;
                    const clickAndReport = (target) => {
                        if (!target || !(target instanceof Element)) return false;
                        if (isElementDisabled(target)) return false;
                        const ok = safeClickElement(target);
                        if (!ok) return false;
                        try {
                            debugLog('panCodeAutoFill', () => ({ ok: true, provider: matched.provider, host, code: maskPanCodeForLog(c) }), 'INFO');
                        } catch (e) {}
                        try {
                            showPassiveTip(`${matched.provider}ï¼šå·²è‡ªåŠ¨å¡«å……æå–ç `);
                        } catch (e2) {}
                        return true;
                    };

                    if (clickAndReport(btn)) return true;

                    const retryClick = () => {
                        let tries = 0;
                        const maxTries = 40;
                        const pick = () => {
                            for (let i = 0; i < uniqScopes.length; i++) {
                                const scope = uniqScopes[i];
                                if (presetButtons) {
                                    const c1 = findFirstVisible(scope, presetButtons.join(', '));
                                    if (c1 && !isElementDisabled(c1)) return c1;
                                }
                                const c2 = findFirstVisible(scope, 'button[type="submit"], input[type="submit"]');
                                if (c2 && !isElementDisabled(c2)) return c2;
                                const c3 = findFirstClickableByTextLoose(scope, btnTextRe);
                                if (c3 && !isElementDisabled(c3)) return c3;
                                const c4 = findFirstClickableByText(scope, btnTextRe);
                                if (c4 && !isElementDisabled(c4)) return c4;
                            }
                            return null;
                        };
                        const step = () => {
                            tries++;
                            const candidate = pick();
                            if (candidate) {
                                clickAndReport(candidate);
                                return;
                            }
                            if (tries >= maxTries) return;
                            setTimeout(step, 100);
                        };
                        setTimeout(step, 60);
                    };

                    if (isElementDisabled(btn)) {
                        const waitSig = `${sig}|waitBtn`;
                        if (tryLockPanCodeAutoFill(waitSig, 350)) {
                            try {
                                debugLog('panCodeAutoFill', () => ({ stage: 'waitButtonEnable', provider: matched.provider, host, code: maskPanCodeForLog(c) }), 'INFO');
                            } catch (e) {}
                            retryClick();
                        }
                    }
                }

                try {
                    const form = input.form || (input.closest && input.closest('form'));
                    if (form && typeof form.requestSubmit === 'function') {
                        form.requestSubmit();
                        try {
                            debugLog('panCodeAutoFill', () => ({ ok: true, provider: matched.provider, host, method: 'requestSubmit', code: maskPanCodeForLog(c) }), 'INFO');
                        } catch (e) {}
                        try { showPassiveTip(`${matched.provider}ï¼šå·²è‡ªåŠ¨å¡«å……æå–ç `); } catch (e3) {}
                        return true;
                    }
                } catch (e2) {}
                try {
                    const sig = `${matched.key}|${normalizePanCodeCacheKey(location.href)}|${c}`;
                    if (!tryLockPanCodeAutoFill(sig, 900)) return false;
                    const fireKey = (type) => {
                        try {
                            input.dispatchEvent(new KeyboardEvent(type, { key: 'Enter', code: 'Enter', keyCode: 13, which: 13, bubbles: true, cancelable: true }));
                        } catch (e) {}
                    };
                    fireKey('keydown');
                    fireKey('keypress');
                    fireKey('keyup');
                } catch (e3) {}
                return false;
            }

            function startPanCodeAutoFill(currentSettings) {
                const s = currentSettings && typeof currentSettings === 'object' ? currentSettings : settings;
                if (!Boolean(s.panCodeAutoFillEnabled)) return null;
                const host = getCurrentHost();
                const info = getPanCodeProviderInfoByHost(host);
                if (!info) return null;
                const fromUrl = extractPanCodeFromUrl(location.href);
                let code = fromUrl || resolveCachedPanCodeForHref(location.href);
                if (!code) code = consumePendingPanCode(300000, { providerKey: info.key, cacheKey: normalizePanCodeCacheKey(location.href) });
                if (!code) return null;
                try {
                    debugLog(
                        'panCodeAutoFill',
                        () => ({
                            stage: 'start',
                            provider: info.provider,
                            host,
                            code: maskPanCodeForLog(code),
                            source: fromUrl ? 'url' : 'cacheOrPending',
                        }),
                        'INFO'
                    );
                } catch (e) {}
                let done = false;
                let ticks = 0;
                let queryRoots = null;
                let queryRootsAt = 0;
                const timer = setInterval(() => {
                    if (done) return;
                    if (++ticks > 60) {
                        done = true;
                        try {
                            recordPanCodeFailure('autoFillTimeout', { provider: info.provider, host, code: maskPanCodeForLog(code) });
                        } catch (e) {}
                        stop();
                        return;
                    }
                    if (!queryRoots || Date.now() - queryRootsAt > 1000) {
                        queryRoots = collectQueryRootsForAutoFill(document, 2500);
                        queryRootsAt = Date.now();
                    }
                    if (tryPanCodeAutoFillOnce(info, code, queryRoots)) {
                        done = true;
                        recordPanCodeForHref(location.href, code);
                        stop();
                    }
                }, 250);
                const stop = () => {
                    try {
                        clearInterval(timer);
                    } catch (e) {}
                };
                return stop;
            }

            function startPanCodeAssist() {
                if (panCodeAssistStop) return;

                let autoFillStop = null;
                try {
                    autoFillStop = startPanCodeAutoFill(settings);
                } catch (e) {
                    autoFillStop = null;
                }
                if (!isTopWindow()) {
                    panCodeAssistStop = () => {
                        try {
                            if (autoFillStop) autoFillStop();
                        } catch (e3) {}
                        autoFillStop = null;
                    };
                    return;
                }

                const toAbsHref = (hrefRaw, a) => resolveAbsoluteHref(hrefRaw, a);

                const getLimitedTextFromElement = (el, maxChars) => {
                    if (!el || !(el instanceof Element)) return '';
                    const limit = typeof maxChars === 'number' && maxChars > 0 ? Math.floor(maxChars) : 900;
                    let out = '';
                    try {
                        const w = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
                        let node;
                        while ((node = w.nextNode())) {
                            const t = String(node.nodeValue || '');
                            if (!t) continue;
                            out += t;
                            if (out.length >= limit) break;
                        }
                    } catch (e) {
                        try {
                            out = String(el.textContent || '');
                        } catch (e2) {
                            out = '';
                        }
                    }
                    out = out.replace(/\s+/g, ' ').trim();
                    if (!out) return '';
                    return out.length > limit ? out.slice(0, limit) : out;
                };

                const getNearbyText = (a) => {
                    const parts = [];
                    const seen = new Set();
                    const pushText = (t) => {
                        const s = String(t || '').replace(/\s+/g, ' ').trim();
                        if (!s) return;
                        if (seen.has(s)) return;
                        seen.add(s);
                        parts.push(s);
                    };
                    const pushFromEl = (el, limit) => {
                        if (!el || !(el instanceof Element)) return;
                        const t = getLimitedTextFromElement(el, limit);
                        if (t) pushText(t);
                    };

                    try {
                        pushText(a && a.textContent ? a.textContent : '');
                    } catch (e) {}
                    try {
                        pushText((a && a.getAttribute && a.getAttribute('title')) || '');
                    } catch (e2) {}

                    const p = a && a.parentElement ? a.parentElement : null;
                    const gp = p && p.parentElement ? p.parentElement : null;
                    pushFromEl(p, 700);
                    pushFromEl(gp, 700);
                    try {
                        if (p) {
                            pushFromEl(p.previousElementSibling, 500);
                            pushFromEl(p.nextElementSibling, 500);
                        }
                    } catch (e3) {}
                    try {
                        if (gp) {
                            pushFromEl(gp.previousElementSibling, 360);
                            pushFromEl(gp.nextElementSibling, 360);
                        }
                    } catch (e4) {}

                    const merged = parts.join(' ').replace(/\s+/g, ' ').trim();
                    if (!merged) return '';
                    return merged.length > 1200 ? merged.slice(0, 1200) : merged;
                };

                const openInNewTab = (url) => {
                    const u = String(url || '').trim();
                    if (!u) return { ok: false, method: 'none' };
                    if (typeof GM_openInTab === 'function') {
                        try {
                            GM_openInTab(u, { active: true, insert: true, setParent: true });
                            return { ok: true, method: 'GM_openInTab' };
                        } catch (e) {}
                    }
                    try {
                        const w = window.open(u, '_blank', 'noopener,noreferrer');
                        if (w) {
                            try {
                                w.opener = null;
                            } catch (e2) {}
                            return { ok: true, method: 'window.open' };
                        }
                    } catch (e3) {}
                    return { ok: false, method: 'none' };
                };

                const isEditableElement = (el) => {
                    if (!el || !(el instanceof Element)) return false;
                    const tag = String(el.tagName || '').toUpperCase();
                    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
                    try {
                        if (el.isContentEditable) return true;
                    } catch (e) {}
                    return false;
                };

                const cleanUrlToken = (raw) => {
                    let s = String(raw || '').trim();
                    if (!s) return '';
                    s = s.replace(/^[`"'â€œâ€â€˜â€™\(ï¼ˆ\[ã€<{]+/, '').replace(/[`"'â€œâ€â€˜â€™\)ï¼‰\]ã€‘>}]+$/, '');
                    s = s.replace(/[ï¼Œã€‚,.;!?ï¼ï¼Ÿã€ã€‘ã€ã€‹ï¼‰\]]+$/g, '');
                    s = s.replace(/[\u200B\u200C\u200D\uFEFF]/g, '');
                    return s.trim();
                };

                const stripEmojiUnsafe = (input) => {
                    const s = String(input || '');
                    if (!s) return '';
                    try {
                        const re = new RegExp('\\p{Extended_Pictographic}', 'gu');
                        return s.replace(re, '');
                    } catch (e) {
                        return s.replace(/[\u{1F000}-\u{1FAFF}]/gu, '');
                    }
                };

                const deobfuscateUrlLikeText = (raw) => {
                    let s = String(raw || '').trim();
                    if (!s) return '';
                    s = s.replace(/[\u200B\u200C\u200D\uFEFF]/g, '');
                    s = s.replace(/[ç‚¹é»]/g, '.');
                    s = s.replace(/[ï¼šï¹•]/g, ':').replace(/[ï¼]/g, '=').replace(/[ï¼]/g, '/');
                    s = s.replace(/\s+/g, '');
                    const allowedRe = /[A-Za-z0-9\-._~:/?#\[\]@!$&'()*+,;=%]/;
                    let out = '';
                    for (let i = 0; i < s.length; i++) {
                        const ch = s[i];
                        if (allowedRe.test(ch)) out += ch;
                    }
                    return out;
                };

                const normalizeCandidateUrl = (tokenRaw) => {
                    const cleaned = cleanUrlToken(tokenRaw);
                    if (!cleaned) return '';
                    const token = deobfuscateUrlLikeText(cleaned);
                    if (!token) return '';
                    let u = '';
                    if (/^https?:\/\//i.test(token)) u = token;
                    else if (/^\/\//.test(token)) u = `${location.protocol}${token}`;
                    else if (/^[a-z0-9.-]+\.[a-z]{2,}(?:\/|$)/i.test(token)) u = `https://${token}`;
                    else return '';
                    try {
                        return new URL(u, location.href).toString();
                    } catch (e) {
                        return u;
                    }
                };

                const extractUrlCandidatesFromText = (text) => {
                    let base = String(text || '');
                    if (!base) return [];
                    try {
                        base = decodeURIComponent(base);
                    } catch (e) {}
                    base = base.replace(/[ç‚¹é»]/g, '.').replace(/%3A/gi, ':').replace(/[\u200B\u200C\u200D\uFEFF]/g, '');
                    const variants = [
                        base,
                        stripEmojiUnsafe(base),
                        base.replace(/[\u4E00-\u9FFF]/g, ''),
                        stripEmojiUnsafe(base).replace(/[\u4E00-\u9FFF]/g, ''),
                        deobfuscateUrlLikeText(stripEmojiUnsafe(base)),
                    ];
                    const re = /(?:https?:\/\/|\/\/)?[A-Za-z0-9.-]+\.[A-Za-z]{2,}(?:\/[\w\-\.~%:/?#\[\]@!$&'()*+,;=\u4E00-\u9FFF]*)?/g;
                    const out = [];
                    const seen = new Set();
                    for (let vi = 0; vi < variants.length && out.length < 12; vi++) {
                        const t = variants[vi];
                        if (!t) continue;
                        let m;
                        re.lastIndex = 0;
                        while ((m = re.exec(t))) {
                            const raw = m[0];
                            const token = cleanUrlToken(raw);
                            if (!token) continue;
                            if (seen.has(token)) continue;
                            seen.add(token);
                            out.push(token);
                            if (out.length >= 12) break;
                        }
                    }
                    return out;
                };

                const resolveAnchorFromSelection = (sel) => {
                    if (!sel || typeof sel.rangeCount !== 'number' || sel.rangeCount <= 0) return null;
                    let range;
                    try {
                        range = sel.getRangeAt(0);
                    } catch (e) {
                        range = null;
                    }
                    if (!range) return null;
                    try {
                        const c = range.commonAncestorContainer;
                        const el = c && c.nodeType === 1 ? c : (c && c.parentElement ? c.parentElement : null);
                        if (el && el.closest) {
                            const a = el.closest('a[href]');
                            if (a) return a;
                        }
                    } catch (e2) {}
                    try {
                        const frag = range.cloneContents();
                        const box = document.createElement('div');
                        box.appendChild(frag);
                        const a = box.querySelector('a[href]');
                        return a || null;
                    } catch (e3) {
                        return null;
                    }
                };

                const resolvePanLinkFromSelection = (selectionText, eventTarget, sel) => {
                    const candidates = extractUrlCandidatesFromText(selectionText);
                    for (let i = 0; i < candidates.length; i++) {
                        const abs0 = normalizeCandidateUrl(candidates[i]);
                        if (!abs0) continue;
                        const abs = sanitizePanShareUrl(abs0) || abs0;
                        const info = getPanCodeProviderInfoByHref(abs);
                        if (!info) continue;
                        if (SelectionClickSuppressState.until && Date.now() < SelectionClickSuppressState.until) {
                            const keys = SelectionClickSuppressState.keys || [];
                            if (keys && keys.length) {
                                let canon = abs;
                                try {
                                    canon = new URL(String(canon || ''), location.href).href;
                                } catch (e) {
                                    canon = abs;
                                }
                                let sanitized = '';
                                try {
                                    sanitized = sanitizePanShareUrl(canon);
                                } catch (e) {
                                    sanitized = '';
                                }
                                const candidates2 = [];
                                if (canon) candidates2.push(canon);
                                if (sanitized && sanitized !== canon) candidates2.push(sanitized);
                                try {
                                    const panKey = normalizePanCodeCacheKey(sanitized || canon);
                                    if (panKey) candidates2.push(`pan:${panKey}`);
                                } catch (e) {}
                                let hit = false;
                                for (let ci = 0; ci < candidates2.length && !hit; ci++) {
                                    const v = String(candidates2[ci] || '');
                                    for (let ki = 0; ki < keys.length; ki++) {
                                        if (v && v === String(keys[ki] || '')) {
                                            hit = true;
                                            break;
                                        }
                                    }
                                }
                                if (hit) continue;
                            }
                        }
                        return { href: abs, rawHref: abs0, info, anchor: null };
                    }
                    const a = eventTarget && eventTarget.closest ? eventTarget.closest('a') : null;
                    if (a && isElementVisible(a)) {
                        const rawHrefAttr = a.getAttribute ? a.getAttribute('href') : '';
                        const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                        const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(a.href || rawHref) : rawHref;
                        const abs0 = href ? toAbsHref(href, a) : '';
                        const abs = abs0 ? (sanitizePanShareUrl(abs0) || abs0) : '';
                        if (abs) {
                            const info = getPanCodeProviderInfoByHref(abs);
                            if (info) return { href: abs, rawHref: abs0, info, anchor: a };
                        }
                    }
                    const fromSel = resolveAnchorFromSelection(sel);
                    if (fromSel && isElementVisible(fromSel)) {
                        const rawHrefAttr = fromSel.getAttribute ? fromSel.getAttribute('href') : '';
                        const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                        const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(fromSel.href || rawHref) : rawHref;
                        const abs0 = href ? toAbsHref(href, fromSel) : '';
                        const abs = abs0 ? (sanitizePanShareUrl(abs0) || abs0) : '';
                        if (abs) {
                            const info = getPanCodeProviderInfoByHref(abs);
                            if (info) return { href: abs, rawHref: abs0, info, anchor: fromSel };
                        }
                    }
                    return null;
                };

                const isStoreUrlLike = (hrefRaw) => {
                    let u;
                    try {
                        u = new URL(String(hrefRaw || '').trim(), location.href);
                    } catch (e) {
                        return false;
                    }
                    const host = String(u.hostname || '').toLowerCase();
                    const path = String(u.pathname || '');
                    if (!host) return false;
                    if (host === 'chrome.google.com') return path.startsWith('/webstore/detail/');
                    if (host === 'chromewebstore.google.com') return path.startsWith('/detail/');
                    if (host === 'microsoftedge.microsoft.com') return path.startsWith('/addons/detail/');
                    if (host === 'addons.mozilla.org') return path.indexOf('/firefox/addon/') !== -1;
                    if (host === 'apps.microsoft.com') return path.startsWith('/store/detail/');
                    if (host === 'www.microsoft.com') return path.startsWith('/store/') || path.startsWith('/p/');
                    return false;
                };

                const getStoreNameByUrl = (hrefRaw) => {
                    let u;
                    try {
                        u = new URL(String(hrefRaw || '').trim(), location.href);
                    } catch (e) {
                        return 'å•†åº—';
                    }
                    const host = String(u.hostname || '').toLowerCase();
                    if (host === 'chrome.google.com' || host === 'chromewebstore.google.com') return 'Chrome å•†åº—';
                    if (host === 'microsoftedge.microsoft.com') return 'Edge å•†åº—';
                    if (host === 'addons.mozilla.org') return 'Firefox å•†åº—';
                    if (host === 'apps.microsoft.com' || host === 'www.microsoft.com') return 'Microsoft å•†åº—';
                    return 'å•†åº—';
                };

                const resolveStoreLinkFromSelection = (selectionText, eventTarget, sel) => {
                    const tryResolve = (abs0, anchor) => {
                        const raw = String(abs0 || '').trim();
                        if (!raw) return null;
                        let target = '';
                        try {
                            const match = resolveSmartRedirectChainFromUrl(raw, ['link', 'both']);
                            target = match && match.target ? String(match.target || '').trim() : '';
                        } catch (e) {
                            target = '';
                        }
                        if (target && isStoreUrlLike(target)) return { href: target, rawHref: raw, name: getStoreNameByUrl(target), anchor: anchor || null };
                        if (isStoreUrlLike(raw)) return { href: raw, rawHref: raw, name: getStoreNameByUrl(raw), anchor: anchor || null };
                        return null;
                    };

                    const candidates = extractUrlCandidatesFromText(selectionText);
                    for (let i = 0; i < candidates.length; i++) {
                        const abs0 = normalizeCandidateUrl(candidates[i]);
                        const hit = tryResolve(abs0, null);
                        if (hit) return hit;
                    }

                    const a = eventTarget && eventTarget.closest ? eventTarget.closest('a') : null;
                    if (a && isElementVisible(a)) {
                        const rawHrefAttr = a.getAttribute ? a.getAttribute('href') : '';
                        const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                        const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(a.href || rawHref) : rawHref;
                        const abs0 = href ? toAbsHref(href, a) : '';
                        const hit = tryResolve(abs0, a);
                        if (hit) return hit;
                    }

                    const fromSel = resolveAnchorFromSelection(sel);
                    if (fromSel && isElementVisible(fromSel)) {
                        const rawHrefAttr = fromSel.getAttribute ? fromSel.getAttribute('href') : '';
                        const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                        const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(fromSel.href || rawHref) : rawHref;
                        const abs0 = href ? toAbsHref(href, fromSel) : '';
                        const hit = tryResolve(abs0, fromSel);
                        if (hit) return hit;
                    }

                    return null;
                };

                let lastSelectionSig = '';
                let lastSelectionAt = 0;
                let lastSelectionOpenAt = 0;
                const RecentOpenState = {
                    map: new Map(),
                };

                const canSelectionOpenOnce = (ttlMsRaw) => {
                    const ttlMs = Math.max(300, Math.min(5000, Number(ttlMsRaw) || 900));
                    const now = Date.now();
                    const prev = lastSelectionOpenAt || 0;
                    if (prev && now - prev < ttlMs) return false;
                    lastSelectionOpenAt = now;
                    return true;
                };

                const canOpenOnce = (hrefRaw, ttlMsRaw) => {
                    const ttlMs = Math.max(300, Math.min(5000, Number(ttlMsRaw) || 900));
                    const raw = String(hrefRaw || '').trim();
                    if (!raw) return false;
                    let key = raw;
                    try {
                        const u = new URL(raw, location.href);
                        key = u.href;
                    } catch (e) {
                        key = raw;
                    }
                    try {
                        const sanitized = sanitizePanShareUrl(key);
                        if (sanitized) key = sanitized;
                    } catch (e) {}
                    try {
                        const panKey = normalizePanCodeCacheKey(key);
                        if (panKey) key = `pan:${panKey}`;
                    } catch (e) {}
                    const now = Date.now();
                    const map = RecentOpenState.map;
                    for (const [k, t] of map.entries()) {
                        if (!t || now - t > ttlMs * 3) map.delete(k);
                    }
                    const prev = map.get(key) || 0;
                    if (prev && now - prev < ttlMs) return false;
                    map.set(key, now);
                    return true;
                };

                const markSuppressSelectionClick = (...hrefRaws) => {
                    try {
                        const list = Array.isArray(hrefRaws) ? hrefRaws : [];
                        const keys = [];
                        const seen = new Set();
                        for (let i = 0; i < list.length; i++) {
                            let key = String(list[i] || '').trim();
                            if (!key) continue;
                            try {
                                const u = new URL(key, location.href);
                                key = u.href;
                            } catch (e) {}
                            try {
                                const sanitized = sanitizePanShareUrl(key);
                                if (sanitized) key = sanitized;
                            } catch (e) {}
                            if (!key) continue;
                            if (seen.has(key)) continue;
                            seen.add(key);
                            keys.push(key);
                            try {
                                const panKey = normalizePanCodeCacheKey(key);
                                const normalized = panKey ? `pan:${panKey}` : '';
                                if (normalized && !seen.has(normalized)) {
                                    seen.add(normalized);
                                    keys.push(normalized);
                                }
                            } catch (e) {}
                        }
                        if (!keys.length) return;
                        SelectionClickSuppressState.until = Date.now() + 900;
                        SelectionClickSuppressState.keys = keys;
                    } catch (e) {}
                };

                const isLikelyLinkOnlySelection = (selectionTextRaw, resolvedHrefRaw) => {
                    const sel = String(selectionTextRaw || '')
                        .replace(/[\u200B\u200C\u200D\uFEFF]/g, '')
                        .trim();
                    const href = String(resolvedHrefRaw || '').trim();
                    if (!sel || !href) return false;
                    const compactSel = sel.replace(/\s+/g, '');
                    const compactHref = href.replace(/\s+/g, '');
                    if (compactSel === compactHref) return true;
                    if (compactSel.startsWith(compactHref) && /^[`"'â€œâ€â€˜â€™()ï¼ˆï¼‰ã€ã€‘\[\]{}<>ï¼Œã€‚ï¼›;:ã€,.!ï¼?ï¼Ÿ-]*$/.test(compactSel.slice(compactHref.length))) return true;
                    if (compactSel.endsWith(compactHref) && /^[`"'â€œâ€â€˜â€™()ï¼ˆï¼‰ã€ã€‘\[\]{}<>ï¼Œã€‚ï¼›;:ã€,.!ï¼?ï¼Ÿ-]*$/.test(compactSel.slice(0, compactSel.length - compactHref.length))) return true;
                    if (/#[a-zA-Z0-9]{3,8}$/.test(compactSel)) {
                        const withoutHash = compactSel.replace(/#[a-zA-Z0-9]{3,8}$/, '');
                        if (withoutHash === compactHref) return true;
                    }
                    return false;
                };

                const onSmartSelection = (e) => {
                    if (!e) return;
                    if (isEventFromSettingsPanel(e)) return;
                    if (!Boolean(settings.panCodeAssistEnabled) && !Boolean(settings.smartRedirectEnabled)) return;
                    try {
                        const ae = document.activeElement;
                        if (isEditableElement(ae) || isEditableElement(e.target)) return;
                    } catch (e0) {}
                    let sel = null;
                    let selectionText = '';
                    try {
                        sel = window.getSelection ? window.getSelection() : null;
                        if (!sel || sel.isCollapsed) return;
                        selectionText = String(sel.toString() || '');
                    } catch (e1) {
                        selectionText = '';
                    }
                    selectionText = selectionText.replace(/[\u200B\u200C\u200D\uFEFF]/g, '').replace(/\s+/g, ' ').trim();
                    if (!selectionText || selectionText.length > 1600) return;
                    const resolved = resolvePanLinkFromSelection(selectionText, e.target, sel);
                    if (!resolved) {
                        if (!Boolean(settings.smartRedirectEnabled)) return;
                        const storeResolved = resolveStoreLinkFromSelection(selectionText, e.target, sel);
                        if (!storeResolved) return;
                        if (!canSelectionOpenOnce(900)) return;
                        if (!canOpenOnce(storeResolved.href, 900)) return;
                        const opened = openInNewTab(storeResolved.href);
                        try {
                            debugLog('smartSelectionStore', () => ({ ok: Boolean(opened && opened.ok), name: storeResolved.name, href: storeResolved.href, method: opened && opened.method ? opened.method : 'none' }), opened && opened.ok ? 'INFO' : 'WARN');
                        } catch (e2) {}
                        try {
                            if (opened && opened.ok) showPassiveTip(`${storeResolved.name}ï¼šå·²æ‰“å¼€é“¾æ¥`);
                        } catch (e3) {}
                        if (opened && opened.ok) {
                            let anchorAbs0 = '';
                            try {
                                let et = e.target;
                                if (et && et.nodeType === 3) et = et.parentElement;
                                const a = storeResolved.anchor || (et && et.closest ? et.closest('a') : null);
                                if (a && isElementVisible(a)) {
                                    const rawHrefAttr = a.getAttribute ? a.getAttribute('href') : '';
                                    const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                                    const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(a.href || rawHref) : rawHref;
                                    anchorAbs0 = href ? toAbsHref(href, a) : '';
                                }
                            } catch (e0) {
                                anchorAbs0 = '';
                            }
                            markSuppressSelectionClick(storeResolved.href, storeResolved.rawHref, anchorAbs0);
                            try {
                                e.preventDefault();
                                if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                            } catch (e4) {}
                        }
                        return;
                    }

                    let code = extractPanCodeFromText(selectionText);
                    if (!code) {
                        const hint = /(?:æå–ç |æå–ç¢¼|è®¿é—®ç |è¨ªå•ç¢¼|å¯†ç |å¯†ç¢¼|å¯†é’¥|å¯†é‘°|å£ä»¤|åˆ†äº«ç |åˆ†äº«ç¢¼|åˆ†äº«|code|key|pwd|pass(?:word)?)/i.test(selectionText);
                        const allowLinkOnly = isLikelyLinkOnlySelection(selectionText, resolved.rawHref || resolved.href);
                        if (!hint && !allowLinkOnly) return;
                        try {
                            let et = e.target;
                            if (et && et.nodeType === 3) et = et.parentElement;
                            const a = resolved.anchor || (et && et.closest ? et.closest('a') : null);
                            if (a) {
                                const nearby = getNearbyText(a);
                                if (nearby) code = extractPanCodeFromText(nearby);
                            }
                        } catch (e2) {}
                        if (!code) {
                            try {
                                if (!canSelectionOpenOnce(900)) return;
                                if (!canOpenOnce(resolved.href, 900)) return;
                                const opened = openInNewTab(resolved.href);
                                debugLog('panCodeSmartSelection', () => ({ ok: Boolean(opened && opened.ok), stage: 'linkOnly', provider: resolved.info.provider, href: resolved.href, method: opened && opened.method ? opened.method : 'none' }), opened && opened.ok ? 'INFO' : 'WARN');
                                if (opened && opened.ok) {
                                    let anchorAbs0 = '';
                                    try {
                                        let et = e.target;
                                        if (et && et.nodeType === 3) et = et.parentElement;
                                        const a = resolved.anchor || (et && et.closest ? et.closest('a') : null);
                                        if (a && isElementVisible(a)) {
                                            const rawHrefAttr = a.getAttribute ? a.getAttribute('href') : '';
                                            const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                                            const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(a.href || rawHref) : rawHref;
                                            anchorAbs0 = href ? toAbsHref(href, a) : '';
                                        }
                                    } catch (e0) {
                                        anchorAbs0 = '';
                                    }
                                    markSuppressSelectionClick(resolved.href, resolved.rawHref, anchorAbs0);
                                    try {
                                        e.preventDefault();
                                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                        else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                                    } catch (e4) {}
                                }
                            } catch (e3) {}
                            try {
                                showPassiveTip(`${resolved.info.provider}ï¼šå·²æ‰“å¼€é“¾æ¥ï¼ˆæœªè¯†åˆ«åˆ°æå–ç ï¼‰`);
                            } catch (e4) {}
                            return;
                        }
                    }

                    const sig = `${resolved.info.key}|${resolved.href}|${code}|${selectionText.slice(0, 120)}`;
                    const now = Date.now();
                    if (sig === lastSelectionSig && now - lastSelectionAt < 1200) return;
                    lastSelectionSig = sig;
                    lastSelectionAt = now;

                    const cacheKey = normalizePanCodeCacheKey(resolved.href);
                    stashPendingPanCode(code, { providerKey: resolved.info.key, cacheKey });

                    let finalHref = resolved.href;
                    if (Boolean(settings.panCodeLinkMergeEnabled) && resolved.info.queryKey) {
                        const merged = mergePanCodeIntoUrl(finalHref, resolved.info, code);
                        if (merged) finalHref = merged;
                    }
                    recordPanCodeForHref(finalHref, code);

                    if (!canSelectionOpenOnce(900)) return;
                    if (!canOpenOnce(finalHref, 900)) return;
                    const opened = openInNewTab(finalHref);
                    try {
                        debugLog('panCodeSmartSelection', () => ({ ok: Boolean(opened && opened.ok), provider: resolved.info.provider, href: finalHref, code: maskPanCodeForLog(code), method: opened && opened.method ? opened.method : 'none' }), opened && opened.ok ? 'INFO' : 'WARN');
                    } catch (e2) {}
                    if (opened && opened.ok) {
                        let anchorAbs0 = '';
                        try {
                            const a = resolved.anchor || (e.target && e.target.closest ? e.target.closest('a') : null);
                            if (a && isElementVisible(a)) {
                                const rawHrefAttr = a.getAttribute ? a.getAttribute('href') : '';
                                const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                                const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(a.href || rawHref) : rawHref;
                                anchorAbs0 = href ? toAbsHref(href, a) : '';
                            }
                        } catch (e0) {
                            anchorAbs0 = '';
                        }
                        markSuppressSelectionClick(finalHref, resolved.href, resolved.rawHref, anchorAbs0);
                        try {
                            e.preventDefault();
                            if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                            else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                        } catch (e4) {}
                        try {
                            showPassiveTip(`${resolved.info.provider}ï¼šå·²æ‰“å¼€é“¾æ¥ï¼Œç¨åå°†è‡ªåŠ¨å¡«å……æå–ç `);
                        } catch (e3) {}
                    } else {
                        try {
                            recordPanCodeFailure('openFail', { provider: resolved.info.provider, href: finalHref, method: opened && opened.method ? opened.method : 'none' });
                        } catch (e4) {}
                    }
                };

                const onClickCapture = (e) => {
                    if (!e) return;
                    if (isEventFromSettingsPanel(e)) return;
                    if (SelectionClickSuppressState.until && Date.now() < SelectionClickSuppressState.until) {
                        try {
                            let target = e.target;
                            if (target && target.nodeType === 3) target = target.parentElement;
                            const a = target && target.closest ? target.closest('a') : null;
                            let intersected = false;
                            try {
                                const sel = window.getSelection ? window.getSelection() : null;
                                if (sel && !sel.isCollapsed && sel.rangeCount) {
                                    const r = sel.getRangeAt(0);
                                    if (r && typeof r.intersectsNode === 'function') intersected = Boolean(r.intersectsNode(a || target));
                                }
                            } catch (e0) {
                                intersected = false;
                            }
                            if (intersected) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                return;
                            }
                            if (a && isElementVisible(a)) {
                                const resolvedHrefLike = resolveAnchorHrefForHoverTitle(a) || '';
                                const rawHrefAttr = a.getAttribute ? a.getAttribute('href') : '';
                                const rawHref = resolvedHrefLike || (rawHrefAttr != null ? String(rawHrefAttr) : '');
                                const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(a.href || rawHref) : rawHref;
                                const abs0 = href ? toAbsHref(href, a) : '';
                                const abs = abs0 ? (sanitizePanShareUrl(abs0) || abs0) : '';
                                let canon = '';
                                try {
                                    const u = new URL(abs || abs0 || href || '', location.href);
                                    canon = u && u.href ? u.href : '';
                                } catch (e3) {
                                    canon = '';
                                }
                                try {
                                    const sanitized = canon ? sanitizePanShareUrl(canon) : '';
                                    if (sanitized) canon = sanitized;
                                } catch (e4) {}
                                let panAbs = '';
                                let panAbs0 = '';
                                let panCanon = '';
                                try {
                                    const k = abs ? normalizePanCodeCacheKey(abs) : '';
                                    if (k) panAbs = `pan:${k}`;
                                } catch (e0) {}
                                try {
                                    const k = abs0 ? normalizePanCodeCacheKey(abs0) : '';
                                    if (k) panAbs0 = `pan:${k}`;
                                } catch (e1) {}
                                try {
                                    const k = canon ? normalizePanCodeCacheKey(canon) : '';
                                    if (k) panCanon = `pan:${k}`;
                                } catch (e2) {}
                                const keys = SelectionClickSuppressState.keys || [];
                                const match = (v) => {
                                    if (!v) return false;
                                    const s = `${v}`;
                                    for (let i = 0; i < keys.length; i++) {
                                        if (s === `${keys[i]}`) return true;
                                    }
                                    return false;
                                };
                                if (match(abs) || match(abs0) || match(canon) || match(panAbs) || match(panAbs0) || match(panCanon)) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                    return;
                                }
                            }
                        } catch (e2) {}
                    }
                    if (!Boolean(settings.panCodeLinkMergeEnabled)) return;
                    const target = e.target;
                    const a = target && target.closest ? target.closest('a') : null;
                    if (!a) return;
                    if (!isElementVisible(a)) return;
                    const rawHrefAttr = a.getAttribute ? a.getAttribute('href') : '';
                    const rawHref = rawHrefAttr != null ? String(rawHrefAttr) : '';
                    const href = rawHref && !/^https?:\/\//i.test(rawHref) ? String(a.href || rawHref) : rawHref;
                    if (!href || /^javascript:/i.test(href)) return;
                    let resolvedHref = href;
                    try {
                        const sanitized = sanitizePanShareUrl(resolvedHref);
                        if (sanitized && sanitized !== resolvedHref) resolvedHref = sanitized;
                    } catch (e0) {}
                    let info = getPanCodeProviderInfoByHref(resolvedHref);
                    if (!info) {
                        const abs = toAbsHref(rawHref || resolvedHref, a);
                        if (abs) {
                            const match = resolveSmartRedirectChainFromUrl(abs, ['link', 'both']);
                            const cleaned = match && match.target ? String(match.target || '') : '';
                            if (cleaned && cleaned !== resolvedHref) {
                                resolvedHref = cleaned;
                                try {
                                    const sanitized = sanitizePanShareUrl(resolvedHref);
                                    if (sanitized && sanitized !== resolvedHref) resolvedHref = sanitized;
                                } catch (e0) {}
                                info = getPanCodeProviderInfoByHref(resolvedHref);
                                if (info) {
                                    try {
                                        a.setAttribute('href', resolvedHref);
                                    } catch (e) {}
                                    try {
                                        a.href = resolvedHref;
                                    } catch (e2) {}
                                }
                            }
                        }
                    }
                    if (!info) return;
                    const existing = extractPanCodeFromUrl(resolvedHref);
                    if (existing) {
                        recordPanCodeForHref(resolvedHref, existing);
                        return;
                    }
                    const nearbyText = getNearbyText(a);
                    const code = extractPanCodeFromText(nearbyText);
                    if (!code) {
                        try {
                            const pageHost = getCurrentHost();
                            if (debugEnabled() || pageHost === 'itsk.com' || (pageHost && pageHost.endsWith('.itsk.com'))) {
                                recordPanCodeFailure('recognizeMiss', {
                                    provider: info.provider,
                                    href: resolvedHref,
                                    linkText: String(a.textContent || '').replace(/\s+/g, ' ').trim().slice(0, 160),
                                });
                            }
                        } catch (e2) {}
                        return;
                    }
                    stashPendingPanCode(code, { providerKey: info.key, cacheKey: normalizePanCodeCacheKey(resolvedHref) });
                    const next = mergePanCodeIntoUrl(resolvedHref, info, code);
                    if (next && next !== resolvedHref) {
                        try {
                            a.setAttribute('href', next);
                        } catch (e2) {}
                        try {
                            a.href = next;
                        } catch (e3) {}
                        recordPanCodeForHref(next, code);
                    } else {
                        recordPanCodeForHref(resolvedHref, code);
                    }
                };

                window.addEventListener('mouseup', onSmartSelection, true);
                window.addEventListener('click', onClickCapture, true);
                window.addEventListener('auxclick', onClickCapture, true);

                panCodeAssistStop = () => {
                    try {
                        window.removeEventListener('mouseup', onSmartSelection, true);
                    } catch (e0) {}
                    try {
                        window.removeEventListener('click', onClickCapture, true);
                    } catch (e) {}
                    try {
                        window.removeEventListener('auxclick', onClickCapture, true);
                    } catch (e2) {}
                    try {
                        SelectionClickSuppressState.until = 0;
                        SelectionClickSuppressState.keys = [];
                    } catch (e2) {}
                    try {
                        if (autoFillStop) autoFillStop();
                    } catch (e3) {}
                    autoFillStop = null;
                };
            }

            function applyPanCodeAssist(active) {
                const shouldEnable = Boolean(active);
                if (!shouldEnable) return stopPanCodeAssist();
                startPanCodeAssist();
            }

            function restoreHoverTitle(a, hadAttr, origAttr, appliedAttr) {
                if (!a || a.tagName !== 'A') return;
                const had = a.getAttribute(hadAttr);
                if (had == null) return;
                try {
                    if (had === '1') {
                        const orig = a.getAttribute(origAttr);
                        if (orig == null) a.removeAttribute('title');
                        else a.setAttribute('title', orig);
                    } else {
                        a.removeAttribute('title');
                    }
                } catch (e) {}
                try {
                    a.removeAttribute(hadAttr);
                    a.removeAttribute(origAttr);
                    a.removeAttribute(appliedAttr);
                } catch (e2) {}
            }

            function setHoverTitle(a, titleText, hadAttr, origAttr, appliedAttr) {
                if (!a || a.tagName !== 'A') return false;
                const text = String(titleText || '').trim();
                if (!text) return false;
                try {
                    if (a.getAttribute(hadAttr) == null) {
                        const had = a.hasAttribute('title');
                        a.setAttribute(hadAttr, had ? '1' : '0');
                        if (had) a.setAttribute(origAttr, String(a.getAttribute('title') || ''));
                    }
                    if (a.getAttribute('title') !== text) a.setAttribute('title', text);
                    a.setAttribute(appliedAttr, '1');
                    return true;
                } catch (e) {
                    return false;
                }
            }

            function resolveAnchorHrefForHoverTitle(el) {
                if (!el || !(el instanceof Element)) return '';
                const pickRaw = (node) => {
                    if (!node || !(node instanceof Element)) return '';
                    try {
                        const href = node.getAttribute('href');
                        if (href != null && String(href).trim()) return String(href).trim();
                    } catch (e) {}
                    const attrs = ['data-href', 'data-url', 'data-link', 'data-redirect-url', 'data-jump-url'];
                    for (let i = 0; i < attrs.length; i++) {
                        const k = attrs[i];
                        try {
                            const v = node.getAttribute(k);
                            const s = v == null ? '' : String(v).trim();
                            if (s) return s;
                        } catch (e2) {}
                    }
                    return '';
                };

                let cur = el;
                let hrefRaw = '';
                for (let i = 0; i < 4 && cur; i++) {
                    hrefRaw = pickRaw(cur);
                    if (hrefRaw) break;
                    cur = cur.parentElement;
                }
                if (!hrefRaw) {
                    const a = el.closest ? el.closest('a,area') : null;
                    if (a && a !== el) {
                        try {
                            const attr = a.getAttribute('href');
                            hrefRaw = attr == null ? '' : String(attr).trim();
                        } catch (e3) {
                            hrefRaw = '';
                        }
                    }
                }

                if (!hrefRaw) return '';
                if (hrefRaw[0] === '#') return '';
                let abs = resolveAbsoluteHref(hrefRaw, el);
                if (!abs) {
                    if (el.tagName === 'A' || el.tagName === 'AREA') {
                        try {
                            abs = String(el.href || '').trim();
                        } catch (e4) {
                            abs = '';
                        }
                    }
                }
                if (!abs) return '';
                const repaired = repairDoubleSchemeUrl(abs);
                abs = repaired || abs;
                if (!abs) return '';
                if (/^(?:javascript|data):/i.test(abs)) return '';
                return abs;
            }

            let hoverTitleEnhancerStop = null;
            let hoverTitleEnhancerSetConfig = null;

            const HOVER_TIP_STYLE_ID = 'newtab-pro-hover-tip-style';
            const HOVER_TIP_ROOT_ID = 'newtab-pro-hover-tip-root';
            const HOVER_TIP_TITLE_HAD_ATTR = 'data-np-hover-title-had';
            const HOVER_TIP_TITLE_ORIG_ATTR = 'data-np-hover-title-orig';
            const HOVER_TIP_TITLE_SUPPRESSED_ATTR = 'data-np-hover-title-suppressed';
            const HoverTipState = {
                root: null,
                tip: null,
                badge: null,
                host: null,
                url: null,
                copy: null,
                visitCount: null,
                appliedUrl: '',
                visible: false,
                anchor: null,
                placeRaf: 0,
                lastX: 0,
                lastY: 0,
            };

            const DOMAIN_VISIT_COUNT_LS_KEY = `${STORAGE_PREFIX}domainVisitCounts`;
            const DomainVisitCountState = {
                domain: '',
                count: 0,
                ready: false,
                scheduled: false,
            };
            let hoverGreasyForkVisitStatsEnabled = false;

            function getDomainVisitCountLevel(countRaw) {
                const c = Number(countRaw || 0);
                if (!Number.isFinite(c) || c <= 0) return 1;
                if (c <= 5) return 1;
                if (c <= 20) return 2;
                if (c <= 50) return 3;
                return 4;
            }

            function updateHoverTipVisitCountUI() {
                if (!HoverTipState.visible) return;
                const el = HoverTipState.visitCount;
                if (!el) return;
                const appliedUrl = String(HoverTipState.appliedUrl || '').trim();
                if (hoverGreasyForkVisitStatsEnabled && appliedUrl && appliedUrl.indexOf('greasyfork.org') !== -1) {
                    const id = extractGreasyForkScriptId(appliedUrl);
                    if (id) {
                        const c = getGreasyForkScriptVisitCountByUrl(appliedUrl);
                        const count = c == null ? 0 : Number(c || 0);
                        const safe = Number.isFinite(count) ? Math.max(0, Math.floor(count)) : 0;
                        try {
                            el.textContent = String(safe);
                        } catch (e) {}
                        try {
                            el.setAttribute('data-level', String(getDomainVisitCountLevel(safe)));
                        } catch (e2) {}
                        return;
                    }
                }
                const ready = DomainVisitCountState.ready;
                const count = ready ? Number(DomainVisitCountState.count || 0) : 0;
                try {
                    el.textContent = ready ? String(Math.max(0, Math.floor(count))) : '...';
                } catch (e) {}
                try {
                    el.setAttribute('data-level', ready ? String(getDomainVisitCountLevel(count)) : '0');
                } catch (e2) {}
            }

            function scheduleIncrementCurrentDomainVisitCount() {
                if (!isTopWindow()) return;
                if (DomainVisitCountState.scheduled) return;
                DomainVisitCountState.scheduled = true;
                scheduleIdleRafTimeout(
                    'domainVisitCountInc',
                    () => {
                        const domain = getCurrentHost();
                        DomainVisitCountState.domain = domain;
                        if (!domain) {
                            DomainVisitCountState.count = 0;
                            DomainVisitCountState.ready = true;
                            updateHoverTipVisitCountUI();
                            return;
                        }
                        let map = null;
                        try {
                            let raw = localStorage.getItem(DOMAIN_VISIT_COUNT_LS_KEY);
                            if (raw == null) {
                                const legacy = localStorage.getItem('domainVisitCounts');
                                if (legacy != null) {
                                    raw = legacy;
                                    try {
                                        localStorage.setItem(DOMAIN_VISIT_COUNT_LS_KEY, legacy);
                                        localStorage.removeItem('domainVisitCounts');
                                    } catch (e0) {}
                                }
                            }
                            map = raw ? safeJsonParse(raw, null) : null;
                        } catch (e) {
                            map = null;
                        }
                        if (!map || typeof map !== 'object' || Array.isArray(map)) map = {};
                        let cur = Number(map[domain] || 0);
                        if (!Number.isFinite(cur) || cur < 0) cur = 0;
                        const next = Math.min(2147483647, Math.floor(cur) + 1);
                        map[domain] = next;
                        try {
                            localStorage.setItem(DOMAIN_VISIT_COUNT_LS_KEY, JSON.stringify(map));
                        } catch (e2) {}
                        DomainVisitCountState.count = next;
                        DomainVisitCountState.ready = true;
                        updateHoverTipVisitCountUI();
                    },
                    1200,
                    true,
                    50
                );
            }

            function isProbablyHttpUrlText(text) {
                const s = String(text || '').trim();
                if (!s) return false;
                if (!/^https?:\/\//i.test(s)) return false;
                try {
                    const u = new URL(s);
                    return Boolean(u && u.host);
                } catch (e) {
                    return false;
                }
            }

            function suppressNativeTitleForHoverTip(el) {
                if (!el || !(el instanceof Element)) return;
                if (el.getAttribute(HOVER_TIP_TITLE_SUPPRESSED_ATTR) === '1') return;
                let had = false;
                let orig = '';
                try {
                    had = el.hasAttribute('title');
                    orig = had ? String(el.getAttribute('title') || '') : '';
                } catch (e) {
                    had = false;
                    orig = '';
                }
                try {
                    el.setAttribute(HOVER_TIP_TITLE_HAD_ATTR, had ? '1' : '0');
                    if (had) el.setAttribute(HOVER_TIP_TITLE_ORIG_ATTR, orig);
                    el.removeAttribute('title');
                    el.setAttribute(HOVER_TIP_TITLE_SUPPRESSED_ATTR, '1');
                } catch (e2) {}
            }

            function restoreNativeTitleForHoverTip(el) {
                if (!el || !(el instanceof Element)) return;
                if (el.getAttribute(HOVER_TIP_TITLE_SUPPRESSED_ATTR) !== '1') return;
                let had = '0';
                let orig = '';
                try {
                    had = String(el.getAttribute(HOVER_TIP_TITLE_HAD_ATTR) || '0');
                    orig = String(el.getAttribute(HOVER_TIP_TITLE_ORIG_ATTR) || '');
                } catch (e) {
                    had = '0';
                    orig = '';
                }
                try {
                    if (had === '1') el.setAttribute('title', orig);
                    else el.removeAttribute('title');
                } catch (e2) {}
                try {
                    el.removeAttribute(HOVER_TIP_TITLE_HAD_ATTR);
                    el.removeAttribute(HOVER_TIP_TITLE_ORIG_ATTR);
                    el.removeAttribute(HOVER_TIP_TITLE_SUPPRESSED_ATTR);
                } catch (e3) {}
            }

            function ensureHoverTipStyle() {
                if (!isTopWindow()) return;
                const css = `
                    #${HOVER_TIP_ROOT_ID}{position:fixed;left:0;top:0;z-index:2147483647;pointer-events:none;}
                    #${HOVER_TIP_ROOT_ID} .nphover{position:fixed;left:12px;top:12px;max-width:min(720px,calc(100vw - 24px));pointer-events:auto;display:flex;flex-direction:column;gap:8px;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(17,18,20,.82);color:#f3f4f6;box-shadow:0 14px 34px rgba(0,0,0,.28);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);opacity:0;transform:translateY(-6px) scale(.99);transition:opacity .14s ease,transform .14s ease;font:12px/1.35 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;}
                    #${HOVER_TIP_ROOT_ID} .nphover[data-visible="1"]{opacity:1;transform:translateY(0) scale(1);}
                    #${HOVER_TIP_ROOT_ID} .nphRow{display:flex;align-items:center;gap:8px;min-width:0;}
                    #${HOVER_TIP_ROOT_ID} .nphBadge{flex:0 0 auto;display:inline-flex;align-items:center;padding:2px 8px;border-radius:999px;font-weight:700;letter-spacing:.2px;background:rgba(59,130,246,.30);color:#eaf2ff;border:1px solid rgba(59,130,246,.35);text-shadow:0 1px 0 rgba(0,0,0,.35);}
                    #${HOVER_TIP_ROOT_ID} .nphover[data-kind="netdisk"] .nphBadge{background:rgba(16,185,129,.35);color:#ecfdf5;border-color:rgba(16,185,129,.40);text-shadow:0 1px 0 rgba(0,0,0,.35);}
                    #${HOVER_TIP_ROOT_ID} .nphHost{min-width:0;flex:1 1 auto;opacity:.92;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;user-select:text;}
                    #${HOVER_TIP_ROOT_ID} .nphUrl{font:12px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;word-break:break-all;opacity:.98;user-select:text;cursor:text;}
                    #${HOVER_TIP_ROOT_ID} .nphMetaRow{display:flex;align-items:center;gap:8px;min-width:0;opacity:.92;}
                    #${HOVER_TIP_ROOT_ID} .nphMetaLabel{flex:0 0 auto;opacity:.78;}
                    #${HOVER_TIP_ROOT_ID} .nphVisitCount{flex:0 0 auto;font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-weight:800;letter-spacing:.2px;transition:color .18s ease;}
                    #${HOVER_TIP_ROOT_ID} .nphVisitCount[data-level="0"]{color:rgba(255,255,255,.72);}
                    #${HOVER_TIP_ROOT_ID} .nphVisitCount[data-level="1"]{color:#60a5fa;}
                    #${HOVER_TIP_ROOT_ID} .nphVisitCount[data-level="2"]{color:#34d399;}
                    #${HOVER_TIP_ROOT_ID} .nphVisitCount[data-level="3"]{color:#fb923c;}
                    #${HOVER_TIP_ROOT_ID} .nphVisitCount[data-level="4"]{color:#f87171;}
                    @media (prefers-color-scheme: light){
                        #${HOVER_TIP_ROOT_ID} .nphover{border-color:rgba(17,18,20,.08);background:rgba(255,255,255,.92);color:#111214;box-shadow:0 14px 34px rgba(0,0,0,.14);}
                        #${HOVER_TIP_ROOT_ID} .nphBadge{text-shadow:none;color:#0f172a;background:rgba(59,130,246,.22);border-color:rgba(59,130,246,.30);}
                        #${HOVER_TIP_ROOT_ID} .nphover[data-kind="netdisk"] .nphBadge{color:#065f46;background:rgba(16,185,129,.22);border-color:rgba(16,185,129,.30);}
                        #${HOVER_TIP_ROOT_ID} .nphVisitCount[data-level="0"]{color:rgba(17,18,20,.70);}
                    }
                `;
                upsertStyleText(HOVER_TIP_STYLE_ID, css);
            }

            function ensureHoverTipRoot() {
                if (!isTopWindow()) return null;
                if (HoverTipState.root && document.body && HoverTipState.root.isConnected) return HoverTipState.root;
                ensureHoverTipStyle();
                const existing = document.getElementById(HOVER_TIP_ROOT_ID);
                const root = existing || document.createElement('div');
                root.id = HOVER_TIP_ROOT_ID;
                let tip = root.querySelector ? root.querySelector('.nphover') : null;
                if (!tip) {
                    tip = document.createElement('div');
                    tip.className = 'nphover';
                    tip.setAttribute('data-visible', '0');
                    tip.setAttribute('data-kind', '');
                    const row = document.createElement('div');
                    row.className = 'nphRow';
                    const badge = document.createElement('span');
                    badge.className = 'nphBadge';
                    const host = document.createElement('span');
                    host.className = 'nphHost';
                    row.appendChild(badge);
                    row.appendChild(host);
                    const url = document.createElement('div');
                    url.className = 'nphUrl';
                    const meta = document.createElement('div');
                    meta.className = 'nphMetaRow';
                    const metaLabel = document.createElement('span');
                    metaLabel.className = 'nphMetaLabel';
                    metaLabel.textContent = 'è®¿é—®æ¬¡æ•°';
                    const visit = document.createElement('span');
                    visit.className = 'nphVisitCount';
                    visit.textContent = '0';
                    visit.setAttribute('data-level', '0');
                    meta.appendChild(metaLabel);
                    meta.appendChild(visit);
                    tip.appendChild(row);
                    tip.appendChild(url);
                    tip.appendChild(meta);
                    root.appendChild(tip);
                }
                if (!existing) {
                    try {
                        (document.body || document.documentElement || document).appendChild(root);
                    } catch (e) {
                        try {
                            (document.documentElement || document).appendChild(root);
                        } catch (e2) {}
                    }
                }
                HoverTipState.root = root;
                HoverTipState.tip = tip;
                HoverTipState.badge = tip.querySelector('.nphBadge');
                HoverTipState.host = tip.querySelector('.nphHost');
                HoverTipState.url = tip.querySelector('.nphUrl');
                HoverTipState.visitCount = tip.querySelector('.nphVisitCount');
                return root;
            }

            function hideHoverTip() {
                const tip = HoverTipState.tip;
                if (!tip) return;
                try {
                    tip.setAttribute('data-visible', '0');
                } catch (e) {}
                HoverTipState.visible = false;
                restoreNativeTitleForHoverTip(HoverTipState.anchor);
                HoverTipState.anchor = null;
            }

            function placeHoverTipNearAnchor(anchor) {
                const tip = HoverTipState.tip;
                if (!tip || !anchor || !(anchor instanceof Element)) return;
                let rect = null;
                try {
                    rect = anchor.getBoundingClientRect();
                } catch (e) {
                    rect = null;
                }
                const usePoint = !rect || !isFinite(rect.left) || !isFinite(rect.top) || (!rect.width && !rect.height);
                const vw = Math.min(document.documentElement.clientWidth || 0, window.innerWidth || 0) || window.innerWidth || 0;
                const vh = Math.min(document.documentElement.clientHeight || 0, window.innerHeight || 0) || window.innerHeight || 0;
                const margin = 12;
                const gap = 10;
                const w = tip.offsetWidth || 0;
                const h = tip.offsetHeight || 0;
                let left = 12;
                let top = 12;
                if (usePoint) {
                    const x = Number(HoverTipState.lastX || 0);
                    const y = Number(HoverTipState.lastY || 0);
                    left = Math.round(x + 12);
                    top = Math.round(y + 14);
                } else {
                    left = Math.round(rect.left);
                    top = Math.round(rect.bottom + gap);
                }
                left = Math.max(margin, Math.min(left, Math.max(margin, vw - w - margin)));
                if (!usePoint && top + h + margin > vh) top = Math.round(rect.top - h - gap);
                if (usePoint && top + h + margin > vh) top = Math.round(Math.max(margin, (Number(HoverTipState.lastY || 0) - h - 14)));
                if (top < margin) top = margin;
                try {
                    tip.style.left = left + 'px';
                    tip.style.top = top + 'px';
                } catch (e2) {}
            }

            function showHoverTip(anchor, kind, badgeText, urlText) {
                const a = anchor && anchor instanceof Element ? anchor : null;
                const url = String(urlText || '').trim();
                if (!a || !url) return false;
                try { cancelTextLinkifyTooltip(a); } catch (e0) {}
                const root = ensureHoverTipRoot();
                if (!root || !HoverTipState.tip) return false;
                HoverTipState.anchor = a;
                HoverTipState.appliedUrl = url;
                const hostText = (function() {
                    try {
                        return new URL(url, location.href).host || '';
                    } catch (e) {
                        return '';
                    }
                })();
                try {
                    HoverTipState.tip.setAttribute('data-kind', String(kind || '').trim());
                    HoverTipState.tip.setAttribute('data-visible', '1');
                } catch (e) {}
                if (HoverTipState.badge) HoverTipState.badge.textContent = String(badgeText || '').trim() || 'é“¾æ¥';
                if (HoverTipState.host) HoverTipState.host.textContent = hostText;
                if (HoverTipState.url) HoverTipState.url.textContent = url;
                HoverTipState.visible = true;
                updateHoverTipVisitCountUI();
                if (HoverTipState.placeRaf) {
                    try {
                        cancelAnimationFrame(HoverTipState.placeRaf);
                    } catch (e) {}
                    HoverTipState.placeRaf = 0;
                }
                HoverTipState.placeRaf = requestAnimationFrame(() => {
                    HoverTipState.placeRaf = 0;
                    placeHoverTipNearAnchor(a);
                });
                return true;
            }

            function classifyHostBadge(urlAbs) {
                const u = String(urlAbs || '').trim();
                if (!u) return { kind: 'textlink', badge: 'é“¾æ¥' };
                let host = '';
                try { host = new URL(u, location.href).host.toLowerCase(); } catch (e) { host = ''; }
                if (!host) return { kind: 'textlink', badge: 'é“¾æ¥' };
                const map = [
                    [/(\.|^)greasyfork\.org$/, 'textlink', 'æ²¹çŒ´æ’ä»¶è„šæœ¬'],
                    // ç½‘ç›˜
                    [/^pan\.baidu\.com$/, 'netdisk', 'ç™¾åº¦ç½‘ç›˜'],
                    [/\.aliyundrive\.com$/, 'netdisk', 'é˜¿é‡Œäº‘ç›˜'],
                    [/^pan\.quark\.cn$/, 'netdisk', 'å¤¸å…‹ç½‘ç›˜'],
                    [/\.cloud\.189\.cn$/, 'netdisk', 'å¤©ç¿¼äº‘ç›˜'],
                    [/lanzou/i, 'netdisk', 'è“å¥äº‘'],
                    [/\.weiyun\.com$/, 'netdisk', 'å¾®äº‘'],
                    [/\.115\.com$/, 'netdisk', '115ç½‘ç›˜'],
                    [/\.mega\.nz$/, 'netdisk', 'MEGA'],
                    [/^drive\.google\.com$/, 'netdisk', 'Google Drive'],
                    [/\.cowtransfer\.com$/, 'netdisk', 'å¥¶ç‰›å¿«ä¼ '],
                    [/\.wss\.so$/, 'netdisk', 'æ–‡å”å”'],
                    // ç™¾åº¦äº§å“
                    [/^haokan\.baidu\.com$/, 'textlink', 'å¥½çœ‹è§†é¢‘'],
                    [/^v\.baidu\.com$/, 'textlink', 'ç™¾åº¦è§†é¢‘'],
                    [/^video\.baidu\.com$/, 'textlink', 'ç™¾åº¦è§†é¢‘'],
                    [/^zhidao\.baidu\.com$/, 'textlink', 'ç™¾åº¦çŸ¥é“'],
                    [/^tieba\.baidu\.com$/, 'textlink', 'ç™¾åº¦è´´å§'],
                    [/^baike\.baidu\.com$/, 'textlink', 'ç™¾åº¦ç™¾ç§‘'],
                    [/^pan\.baidu\.com$/, 'netdisk', 'ç™¾åº¦ç½‘ç›˜'],
                    [/^aiqicha\.baidu\.com$/, 'textlink', 'çˆ±ä¼æŸ¥'],
                    [/\.baidu\.com$/, 'textlink', 'ç™¾åº¦'],
                    [/^support\.microsoft\.com$/, 'textlink', 'Microsoft æ”¯æŒ'],
                    [/(\.|^)huorong\.cn$/, 'textlink', 'ç«ç»’å®‰å…¨'],
                    // åä¸ºç³»
                    [/^www\.huawei\.com$/, 'textlink', 'åä¸ºå®˜ç½‘'],
                    [/^cloud\.huawei\.com$/, 'textlink', 'åä¸ºäº‘'],
                    [/^developer\.huawei\.com$/, 'textlink', 'åä¸ºå¼€å‘è€…'],
                    [/\.huawei\.com$/, 'textlink', 'åä¸º'],
                    // è…¾è®¯ç³»
                    [/^www\.tencent\.com$/, 'textlink', 'è…¾è®¯'],
                    [/^cloud\.tencent\.com$/, 'textlink', 'è…¾è®¯äº‘'],
                    [/^im\.qq\.com$/, 'textlink', 'è…¾è®¯QQ'],
                    [/^www\.imqq\.com$/, 'textlink', 'è…¾è®¯QQ'],
                    [/\.imqq\.com$/, 'textlink', 'è…¾è®¯QQ'],
                    [/^id\.qq\.com$/, 'textlink', 'QQè´¦å·ä¸­å¿ƒ'],
                    [/^zc\.qq\.com$/, 'textlink', 'QQæ³¨å†Œ'],
                    [/^ssl\.zc\.qq\.com$/, 'textlink', 'QQæ³¨å†Œ'],
                    [/^aq\.qq\.com$/, 'textlink', 'QQå®‰å…¨ä¸­å¿ƒ'],
                    [/^110\.qq\.com$/, 'textlink', 'è…¾è®¯å®‰å…¨ä¸­å¿ƒ'],
                    [/^qzone\.qq\.com$/, 'textlink', 'QQç©ºé—´'],
                    [/^docs\.qq\.com$/, 'textlink', 'è…¾è®¯æ–‡æ¡£'],
                    [/^music\.qq\.com$/, 'textlink', 'QQéŸ³ä¹'],
                    [/^game\.qq\.com$/, 'textlink', 'è…¾è®¯æ¸¸æˆ'],
                    [/^sports\.qq\.com$/, 'textlink', 'è…¾è®¯ä½“è‚²'],
                    [/^browser\.qq\.com$/, 'textlink', 'QQæµè§ˆå™¨'],
                    [/^weixin\.qq\.com$/, 'textlink', 'å¾®ä¿¡'],
                    [/^weixin\.com$/, 'textlink', 'å¾®ä¿¡'],
                    [/^work\.weixin\.qq\.com$/, 'textlink', 'ä¼ä¸šå¾®ä¿¡'],
                    [/^pay\.qq\.com$/, 'textlink', 'QQé’±åŒ…'],
                    [/^open\.qq\.com$/, 'textlink', 'è…¾è®¯å¼€æ”¾å¹³å°'],
                    [/^service\.qq\.com$/, 'textlink', 'è…¾è®¯å®¢æœ'],
                    [/^qun\.qq\.com$/, 'textlink', 'QQç¾¤'],
                    [/^mail\.qq\.com$/, 'textlink', 'QQé‚®ç®±'],
                    [/^wx\.mail\.qq\.com$/, 'textlink', 'QQé‚®ç®±'],
                    [/^exmail\.qq\.com$/, 'textlink', 'QQé‚®ç®±'],
                    [/^en\.mail\.qq\.com$/, 'textlink', 'QQé‚®ç®±'],
                    [/^service\.mail\.qq\.com$/, 'textlink', 'QQé‚®ç®±'],
                    [/\.qq\.com$/, 'textlink', 'è…¾è®¯'],
                    // é˜¿é‡Œç³»
                    [/^www\.alibaba\.com$/, 'textlink', 'é˜¿é‡Œå·´å·´'],
                    [/\.aliyun\.com$/, 'textlink', 'é˜¿é‡Œäº‘'],
                    [/^www\.alipay\.com$/, 'textlink', 'æ”¯ä»˜å®'],
                    [/\.alipay\.com$/, 'textlink', 'æ”¯ä»˜å®'],
                    // å¸¸è§ç«™ç‚¹
                    [/\.csdn\.net$/, 'textlink', 'CSDN'],
                    [/\.github\.com$/, 'textlink', 'GitHub'],
                    [/\.gitee\.com$/, 'textlink', 'Gitee'],
                    [/\.juejin\.cn$/, 'textlink', 'æ˜é‡‘'],
                    [/\.zhihu\.com$/, 'textlink', 'çŸ¥ä¹'],
                    [/\.weibo\.com$/, 'textlink', 'å¾®åš'],
                    [/\.x\.com$/, 'textlink', 'X(Twitter)'],
                    [/\.twitter\.com$/, 'textlink', 'Twitter'],
                    [/\.facebook\.com$/, 'textlink', 'Facebook'],
                    [/\.instagram\.com$/, 'textlink', 'Instagram'],
                    [/\.reddit\.com$/, 'textlink', 'Reddit'],
                    [/\.tiktok\.com$/, 'textlink', 'TikTok'],
                    [/\.taobao\.com$/, 'textlink', 'æ·˜å®'],
                    [/\.tmall\.com$/, 'textlink', 'å¤©çŒ«'],
                    [/\.jd\.com$/, 'textlink', 'äº¬ä¸œ'],
                    [/\.pinduoduo\.com$/, 'textlink', 'æ‹¼å¤šå¤š'],
                    [/\.amazon\.com$/, 'textlink', 'Amazon'],
                    [/\.ebay\.com$/, 'textlink', 'eBay'],
                    [/\.sina\.com\.cn$/, 'textlink', 'æ–°æµª'],
                    [/\.bbc\.co\.uk$/, 'textlink', 'BBC'],
                    [/\.nytimes\.com$/, 'textlink', 'NYTimes'],
                    [/\.cnn\.com$/, 'textlink', 'CNN'],
                    [/^developer\.mozilla\.org$/, 'textlink', 'MDN'],
                    [/^stackoverflow\.com$/, 'textlink', 'StackOverflow'],
                    // è§†é¢‘ä¸åª’ä½“ï¼ˆæ–°å¢ï¼‰
                    [/^v\.qq\.com$/, 'textlink', 'è…¾è®¯è§†é¢‘'],
                    [/\.iqiyi\.com$/, 'textlink', 'çˆ±å¥‡è‰º'],
                    [/\.youku\.com$/, 'textlink', 'ä¼˜é…·'],
                    [/\.mgtv\.com$/, 'textlink', 'èŠ’æœTV'],
                    [/\.bilibili\.com$/, 'textlink', 'å“”å“©å“”å“©'],
                    [/\.ixigua\.com$/, 'textlink', 'è¥¿ç“œè§†é¢‘'],
                    [/\.douyin\.com$/, 'textlink', 'æŠ–éŸ³'],
                    [/\.kuaishou\.com$/, 'textlink', 'å¿«æ‰‹'],
                    [/^tv\.cctv\.com$/, 'textlink', 'CCTV'],
                    [/\.cctv\.com$/, 'textlink', 'CCTV'],
                    [/\.sohu\.com$/, 'textlink', 'æœç‹'],
                    [/\.pptv\.com$/, 'textlink', 'PPTV'],
                    [/\.letv\.com$/, 'textlink', 'ä¹è§†è§†é¢‘'],
                    [/\.youtube\.com$/, 'textlink', 'YouTube'],
                ];
                for (let i = 0; i < map.length; i++) {
                    const [re, kind, label] = map[i];
                    if (re.test(host)) return { kind, badge: label };
                }
                return { kind: 'textlink', badge: host };
            }

            function stopHoverTitleEnhancer() {
                if (!hoverTitleEnhancerStop) return;
                try {
                    hoverTitleEnhancerStop();
                } catch (e) {}
                hoverTitleEnhancerStop = null;
                hoverTitleEnhancerSetConfig = null;
            }

            function applyHoverTitleEnhancer(runtimeShouldActive, currentSettings) {
                const s = currentSettings && typeof currentSettings === 'object' ? currentSettings : settings;
                hoverGreasyForkVisitStatsEnabled = Boolean(runtimeShouldActive) && Boolean(s && s.greasyForkVisitStatsEnabled);
                const enabledNetdisk = Boolean(runtimeShouldActive) && Boolean(s && s.netdiskHoverRealUrlEnabled);
                const enabledTextLink = Boolean(runtimeShouldActive) && Boolean(s && s.textLinkHoverFullUrlEnabled);
                if (!enabledNetdisk && !enabledTextLink) return stopHoverTitleEnhancer();
                startHoverTitleEnhancer({ enabledNetdisk, enabledTextLink });
            }

            function startHoverTitleEnhancer(config) {
                if (hoverTitleEnhancerStop && hoverTitleEnhancerSetConfig) {
                    hoverTitleEnhancerSetConfig(config);
                    return;
                }
                const cache = new Map();
                const cacheKeys = [];
                let activeAnchor = null;
                let netdiskEnabled = Boolean(config && config.enabledNetdisk);
                let textLinkEnabled = Boolean(config && config.enabledTextLink);

                scheduleIncrementCurrentDomainVisitCount();

                const cacheGet = (k) => {
                    const key = String(k || '');
                    if (!key) return '';
                    const v = cache.get(key);
                    return v ? String(v) : '';
                };
                const cacheSet = (k, v) => {
                    const key = String(k || '');
                    const value = String(v || '');
                    if (!key || !value) return;
                    if (cache.has(key)) cache.delete(key);
                    cache.set(key, value);
                    cacheKeys.push(key);
                    if (cache.size > 200) {
                        const rm = cacheKeys.shift();
                        if (rm) cache.delete(rm);
                    }
                };

                const clearNetdiskCache = () => {
                    cache.clear();
                    cacheKeys.length = 0;
                };

                hoverTitleEnhancerSetConfig = (next) => {
                    const nextNetdisk = Boolean(next && next.enabledNetdisk);
                    const nextText = Boolean(next && next.enabledTextLink);
                    if (netdiskEnabled && !nextNetdisk) clearNetdiskCache();
                    netdiskEnabled = nextNetdisk;
                    textLinkEnabled = nextText;
                    if (!netdiskEnabled && !textLinkEnabled) stopHoverTitleEnhancer();
                };

                const resolveBaiduRealFromDataAttrs = (hrefAbs, a) => {
                    const raw = String(hrefAbs || '').trim();
                    if (!raw || !a || !(a instanceof Element)) return '';
                    let u;
                    try { u = new URL(raw, location.href); } catch (e) { return ''; }
                    const host = String(u.hostname || '').toLowerCase();
                    const path = String(u.pathname || '');
                    if (!((host === 'www.baidu.com' || host === 'm.baidu.com') && path === '/link')) return '';
                    const readUrlFromDataClick = (node) => {
                        if (!node || !(node instanceof Element)) return '';
                        let v = '';
                        try { v = String(node.getAttribute('data-click') || ''); } catch (e) { v = ''; }
                        const s = v.trim();
                        if (!s) return '';
                        let obj = null;
                        if (s[0] === '{') {
                            try { obj = safeJsonParse(s, null); } catch (e2) { obj = null; }
                        }
                        if (obj && typeof obj === 'object') {
                            const candidates = ['url', 'mu', 'href', 'target', 'link'];
                            for (let i = 0; i < candidates.length; i++) {
                                const k = candidates[i];
                                const val = obj[k];
                                if (val && typeof val === 'string' && /^https?:\/\//i.test(val)) return val;
                            }
                        }
                        return '';
                    };
                    const readUrlFromMu = (node) => {
                        if (!node || !(node instanceof Element)) return '';
                        let v = '';
                        try {
                            v = String(
                                node.getAttribute('data-mu') ||
                                node.getAttribute('mu') ||
                                node.getAttribute('data-url') ||
                                node.getAttribute('data-target') ||
                                node.getAttribute('data-href') ||
                                node.getAttribute('data-link') ||
                                ''
                            );
                        } catch (e) { v = ''; }
                        const s = v.trim();
                        if (s && /^https?:\/\//i.test(s)) return s;
                        return '';
                    };
                    let cur = a;
                    for (let i = 0; i < 4 && cur; i++) {
                        const got = readUrlFromDataClick(cur) || readUrlFromMu(cur);
                        if (got) return got;
                        cur = cur.parentElement;
                    }
                    // å‘ä¸‹æ‰«æé™„è¿‘èŠ‚ç‚¹ï¼ˆå­å­™/å…„å¼Ÿï¼‰çš„å°èŒƒå›´ï¼Œå…¼å®¹ data-click æŒ‚åœ¨åŒ…è£¹å…ƒç´ çš„æƒ…å†µ
                    const tryScanNearby = (root) => {
                        if (!root || !(root instanceof Element)) return '';
                        let nodes = [];
                        try {
                            nodes = root.querySelectorAll('[data-click],[data-mu],[mu],[data-url],[data-target],[data-href],[data-link]');
                        } catch (e) {
                            nodes = [];
                        }
                        const limit = Math.min(30, nodes.length);
                        for (let i = 0; i < limit; i++) {
                            const n = nodes[i];
                            const got = readUrlFromDataClick(n) || readUrlFromMu(n);
                            if (got) return got;
                        }
                        // æ‰«æå…„å¼ŸèŠ‚ç‚¹
                        const p = root.parentElement;
                        if (p && p instanceof Element) {
                            let siblings = [];
                            try { siblings = p.children; } catch (e2) { siblings = []; }
                            const len = siblings && siblings.length ? Math.min(30, siblings.length) : 0;
                            for (let i = 0; i < len; i++) {
                                const n = siblings[i];
                                if (!(n instanceof Element) || n === root) continue;
                                const got = readUrlFromDataClick(n) || readUrlFromMu(n);
                                if (got) return got;
                            }
                        }
                        return '';
                    };
                    const near = tryScanNearby(a) || tryScanNearby(a.parentElement || null);
                    if (near) return near;
                    return '';
                };

                const findResultRoot = (el) => {
                    if (!el || !(el instanceof Element)) return null;
                    const sels = ['.result', '.result-op', '.c-container', '.cr-content', '.xpath-log', '[srcid]', '[tpl]'];
                    let cur = el;
                    for (let i = 0; i < 6 && cur; i++) {
                        for (let j = 0; j < sels.length; j++) {
                            const s = sels[j];
                            try {
                                if (cur.matches && cur.matches(s)) return cur;
                            } catch (e) {}
                        }
                        cur = cur.parentElement;
                    }
                    try {
                        const p = el.closest && el.closest(sels.join(',')); 
                        if (p) return p;
                    } catch (e2) {}
                    return null;
                };

                const extractUrlFromAttrs = (node) => {
                    if (!node || !(node instanceof Element)) return '';
                    const fromDataClick = (() => {
                        let v = '';
                        try { v = String(node.getAttribute('data-click') || ''); } catch (e) { v = ''; }
                        const s = v.trim();
                        if (!s || s[0] !== '{') return '';
                        const obj = safeJsonParse(s, null);
                        if (obj && typeof obj === 'object') {
                            const keys = ['url', 'mu', 'href', 'target', 'link'];
                            for (let i = 0; i < keys.length; i++) {
                                const k = keys[i];
                                const val = obj[k];
                                if (val && typeof val === 'string' && /^https?:\/\//i.test(val)) return val;
                            }
                        }
                        return '';
                    })();
                    if (fromDataClick) return fromDataClick;
                    const attrs = ['data-mu', 'mu', 'data-url', 'data-target', 'data-href', 'data-link'];
                    for (let i = 0; i < attrs.length; i++) {
                        const k = attrs[i];
                        let v = '';
                        try { v = String(node.getAttribute(k) || ''); } catch (e2) { v = ''; }
                        const s = v.trim();
                        if (s && /^https?:\/\//i.test(s)) return s;
                    }
                    return '';
                };

                const collectCandidateUrls = (root) => {
                    const list = [];
                    if (!root || !(root instanceof Element)) return list;
                    const pushUrl = (u) => {
                        const s = String(u || '').trim();
                        if (!s) return;
                        try {
                            const url = new URL(s, location.href);
                            const host = String(url.hostname || '').toLowerCase();
                            if (host && host !== 'www.baidu.com' && host !== 'm.baidu.com') list.push(url.href);
                        } catch (e) {}
                    };
                    // æ ¹èŠ‚ç‚¹è‡ªèº«å±æ€§ï¼ˆå¦‚ muï¼‰
                    const rootAttrUrl = extractUrlFromAttrs(root);
                    if (rootAttrUrl) pushUrl(rootAttrUrl);
                    try {
                        const nodes = root.querySelectorAll('[data-click],[data-mu],[mu],[data-url],[data-target],[data-href],[data-link]');
                        const limit = Math.min(50, nodes.length);
                        for (let i = 0; i < limit; i++) {
                            const u = extractUrlFromAttrs(nodes[i]);
                            if (u) pushUrl(u);
                        }
                    } catch (e) {}
                    try {
                        const links = root.querySelectorAll('a[href]');
                        const limit = Math.min(80, links.length);
                        for (let i = 0; i < limit; i++) {
                            const a = links[i];
                            let h = '';
                            try { h = String(a.getAttribute('href') || a.href || ''); } catch (e2) { h = ''; }
                            const s = h.trim();
                            if (!s) continue;
                            if (/^(?:javascript|#)/i.test(s)) continue;
                            try {
                                const abs = new URL(s, location.href).href;
                                const u = new URL(abs);
                                const host = String(u.hostname || '').toLowerCase();
                                if (host && host !== 'www.baidu.com' && host !== 'm.baidu.com') pushUrl(u.href);
                            } catch (e3) {}
                        }
                    } catch (e) {}
                    return Array.from(new Set(list));
                };

                const pickBestCandidate = (candidates, titleText) => {
                    const list = Array.isArray(candidates) ? candidates : [];
                    if (!list.length) return '';
                    const t = String(titleText || '').toLowerCase();
                    const preferHosts = ['v.qq.com', 'www.iqiyi.com', 'www.youku.com', 'www.mgtv.com', 'www.bilibili.com'];
                    for (let i = 0; i < preferHosts.length; i++) {
                        const h = preferHosts[i];
                        const hit = list.find((u) => {
                            try { return new URL(u).hostname.toLowerCase() === h; } catch (e) { return false; }
                        });
                        if (hit) return hit;
                    }
                    const withText = list.find((u) => t && u.toLowerCase().includes('qq.com'));
                    if (withText) return withText;
                    return list[0];
                };

                const resolveRealHref = (hrefAbs, a) => {
                    const raw = String(hrefAbs || '').trim();
                    if (!raw) return '';
                    const cached = cacheGet(raw);
                    if (cached) return cached;
                    const quickBaidu = resolveBaiduRealFromDataAttrs(raw, a);
                    if (quickBaidu) {
                        cacheSet(raw, quickBaidu);
                        return quickBaidu;
                    }
                    const match = resolveSmartRedirectChainFromUrl(raw, ['link', 'both', 'redirectPage']);
                    let out = match && match.target ? String(match.target || '').trim() : '';
                    if (!out) out = raw;
                    const repaired = repairDoubleSchemeUrl(out);
                    out = repaired || out;
                    if (out === raw) {
                        let u;
                        try { u = new URL(raw, location.href); } catch (e) { u = null; }
                        const host = u ? String(u.hostname || '').toLowerCase() : '';
                        const path = u ? String(u.pathname || '') : '';
                        if ((host === 'www.baidu.com' || host === 'm.baidu.com') && path === '/link' && a && a instanceof Element) {
                            const root = findResultRoot(a) || a.parentElement || null;
                            const titleText = (() => {
                                let s = '';
                                try { s = String(a.textContent || '').trim(); } catch (e2) { s = ''; }
                                return s;
                            })();
                            const cands = collectCandidateUrls(root);
                            const best = pickBestCandidate(cands, titleText);
                            if (best) out = best;
                        }
                    }
                    if (out) cacheSet(raw, out);
                    return out;
                };

                const computeHoverTip = (a) => {
                    if (!a || !(a instanceof Element)) return null;
                    const hrefAbs = resolveAnchorHrefForHoverTitle(a);
                    if (!hrefAbs) return null;

                    if (netdiskEnabled) {
                        const provider = getPanCodeProviderInfoByHref(hrefAbs);
                        if (provider) {
                        const real = resolveRealHref(hrefAbs, a);
                            if (real) return { kind: 'netdisk', badge: String(provider.provider || 'ç½‘ç›˜'), url: real };
                        }
                    }

                    if (textLinkEnabled) {
                        if (!/^https?:/i.test(hrefAbs)) return null;
                        const realOut = resolveRealHref(hrefAbs, a) || hrefAbs;
                        if (a.hasAttribute && a.hasAttribute('title')) {
                            let t = '';
                            try {
                                t = String(a.getAttribute('title') || '').trim();
                            } catch (e) {
                                t = '';
                            }
                            if (isProbablyHttpUrlText(t)) return null;
                        }
                        const badge = classifyHostBadge(realOut);
                        return { kind: badge.kind || 'textlink', badge: badge.badge || 'é“¾æ¥', url: realOut };
                    }

                    return null;
                };

                const activateOn = (a) => {
                    const info = computeHoverTip(a);
                    if (!info) return false;
                    suppressNativeTitleForHoverTip(a);
                    return showHoverTip(a, info.kind, info.badge, info.url);
                };

                const onOver = (e) => {
                    if (!e) return;
                    try {
                        if (typeof e.clientX === 'number') HoverTipState.lastX = e.clientX;
                        if (typeof e.clientY === 'number') HoverTipState.lastY = e.clientY;
                    } catch (e0) {}
                    const t = e.target;
                    if (!(t instanceof Element)) return;
                    const a =
                        t.closest &&
                        t.closest('a,area,[role="link"][data-href],[role="link"][data-url],[role="link"][data-link],[data-href],[data-url],[data-link],[data-redirect-url],[data-jump-url]');
                    if (!a) return;
                    if (activeAnchor === a) return;
                    if (activeAnchor) hideHoverTip();
                    if (activateOn(a)) activeAnchor = a;
                    else activeAnchor = null;
                };

                const onOut = (e) => {
                    if (!e) return;
                    if (!activeAnchor) return;
                    const t = e.target;
                    if (!(t instanceof Element)) return;
                    const a =
                        t.closest &&
                        t.closest('a,area,[role="link"][data-href],[role="link"][data-url],[role="link"][data-link],[data-href],[data-url],[data-link],[data-redirect-url],[data-jump-url]');
                    if (!a || a !== activeAnchor) return;
                    const rt = e.relatedTarget;
                    if (rt && rt instanceof Node) {
                        try {
                            if (activeAnchor.contains(rt)) return;
                        } catch (e2) {}
                        try {
                            if (HoverTipState.tip && HoverTipState.tip.contains(rt)) return;
                        } catch (e3) {}
                    }
                    hideHoverTip();
                    activeAnchor = null;
                };

                document.addEventListener('mouseover', onOver, true);
                document.addEventListener('mouseout', onOut, true);
                document.addEventListener('focusin', onOver, true);
                document.addEventListener('focusout', onOut, true);

                const root = ensureHoverTipRoot();
                const tip = root ? HoverTipState.tip : null;
                if (tip && !tip.__nph_tip_bound) {
                    tip.__nph_tip_bound = 1;
                    tip.addEventListener(
                        'mouseout',
                        (e) => {
                            if (!activeAnchor) return;
                            const rt = e && e.relatedTarget;
                            if (rt && rt instanceof Node) {
                                try {
                                    if (tip.contains(rt)) return;
                                } catch (e2) {}
                                try {
                                    if (activeAnchor.contains(rt)) return;
                                } catch (e3) {}
                            }
                            hideHoverTip();
                            activeAnchor = null;
                        },
                        true
                    );
                }

                hoverTitleEnhancerStop = () => {
                    try {
                        document.removeEventListener('mouseover', onOver, true);
                        document.removeEventListener('mouseout', onOut, true);
                        document.removeEventListener('focusin', onOver, true);
                        document.removeEventListener('focusout', onOut, true);
                    } catch (e) {}
                    hideHoverTip();
                    activeAnchor = null;
                    clearNetdiskCache();
                };
            }

            function stopItskCloudQueryAutoJump() {
                if (!itskCloudQueryAutoJumpStop) return;
                try {
                    itskCloudQueryAutoJumpStop();
                } catch (e) {}
                itskCloudQueryAutoJumpStop = null;
            }

            function startItskCloudQueryAutoJump(currentSettings) {
                const s = currentSettings && typeof currentSettings === 'object' ? currentSettings : settings;
                if (!s || !isTopWindow()) return;
                const host = getCurrentHost();
                if (!host || !(host === 'itsk.com' || host.endsWith('.itsk.com'))) return;
                if (itskCloudQueryAutoJumpStop) return;

                const openUrlInNewTab = (url) => {
                    const u = String(url || '').trim();
                    if (!u) return false;
                    try {
                        if (typeof GM_openInTab === 'function') {
                            GM_openInTab(u, { active: true, insert: true, setParent: true });
                            return true;
                        }
                    } catch (e) {}
                    try {
                        const w = window.open(u, '_blank', 'noopener,noreferrer');
                        if (w) {
                            try {
                                w.opener = null;
                            } catch (e2) {}
                            return true;
                        }
                    } catch (e3) {}
                    return false;
                };

                const normalizeMaybeHref = (hrefRaw) => {
                    const raw = String(hrefRaw || '').trim();
                    if (!raw) return '';
                    if (/^javascript:/i.test(raw)) return '';
                    try {
                        return new URL(raw, location.href).href;
                    } catch (e) {
                        return '';
                    }
                };

                const inferTargetHrefFromDialog = (dialog) => {
                    if (!dialog || !(dialog instanceof Element)) return '';

                    const goEl = findFirstClickableByText(dialog, /^(?:å‰å¾€|å»å¾€|å»ç½‘ç›˜|æ‰“å¼€|è¿›å…¥)$/i) || findFirstClickableByText(dialog, /å‰å¾€/i);
                    if (goEl && goEl instanceof HTMLAnchorElement) {
                        const h = normalizeMaybeHref(goEl.getAttribute('href') || goEl.href || '');
                        if (h && getPanCodeProviderInfoByHref(h)) return h;
                    }

                    if (goEl && goEl instanceof Element) {
                        const attrs = goEl.getAttributeNames ? goEl.getAttributeNames() : [];
                        for (let i = 0; i < attrs.length; i++) {
                            const k = attrs[i];
                            if (!k) continue;
                            let v = '';
                            try {
                                v = String(goEl.getAttribute(k) || '');
                            } catch (e) {
                                v = '';
                            }
                            if (!v) continue;
                            const m = /(https?:\/\/[^\s"'<>]+)/i.exec(v);
                            if (m && m[1]) {
                                const h = normalizeMaybeHref(m[1]);
                                if (h && getPanCodeProviderInfoByHref(h)) return h;
                            }
                        }
                        const onClick = String(goEl.getAttribute('onclick') || '');
                        if (onClick) {
                            const m = /(https?:\/\/[^\s"'<>]+)/i.exec(onClick);
                            if (m && m[1]) {
                                const h = normalizeMaybeHref(m[1]);
                                if (h && getPanCodeProviderInfoByHref(h)) return h;
                            }
                        }
                    }

                    let links = [];
                    try {
                        links = dialog.querySelectorAll('a[href]');
                    } catch (e) {
                        links = [];
                    }
                    for (let i = 0; i < links.length; i++) {
                        const a = links[i];
                        const h = normalizeMaybeHref(a.getAttribute('href') || a.href || '');
                        if (!h) continue;
                        if (getPanCodeProviderInfoByHref(h)) return h;
                    }

                    const fastAttrSelectors = [
                        '[data-href]',
                        '[data-url]',
                        '[data-link]',
                        '[data-jump]',
                        '[data-target]',
                        '[data-clipboard-text]',
                        '[onclick]',
                    ].join(',');
                    let nodes = [];
                    try {
                        nodes = dialog.querySelectorAll(fastAttrSelectors);
                    } catch (e) {
                        nodes = [];
                    }
                    for (let i = 0; i < nodes.length && i < 80; i++) {
                        const el = nodes[i];
                        if (!el || !(el instanceof Element)) continue;
                        const attrs = el.getAttributeNames ? el.getAttributeNames() : [];
                        for (let j = 0; j < attrs.length; j++) {
                            const k = attrs[j];
                            if (!k) continue;
                            let v = '';
                            try {
                                v = String(el.getAttribute(k) || '');
                            } catch (e2) {
                                v = '';
                            }
                            if (!v) continue;
                            const m = /(https?:\/\/[^\s"'<>]+)/i.exec(v);
                            if (!m || !m[1]) continue;
                            const h = normalizeMaybeHref(m[1]);
                            if (h && getPanCodeProviderInfoByHref(h)) return h;
                        }
                    }

                    const rawText = String(dialog.textContent || '');
                    if (rawText && rawText.indexOf('http') !== -1) {
                        const re = /(https?:\/\/[^\s"'<>]+)/gi;
                        let m;
                        let count = 0;
                        while ((m = re.exec(rawText))) {
                            if (++count > 30) break;
                            const h = normalizeMaybeHref(m[1]);
                            if (h && getPanCodeProviderInfoByHref(h)) return h;
                        }
                    }
                    return '';
                };

                const installPanOpenCapture = (code) => {
                    let stopped = false;
                    let captured = '';
                    const c = normalizePanCodeValue(code);
                    const canRecord = Boolean(c);
                    const wrapUrl = (url) => {
                        if (stopped) return;
                        if (captured) return;
                        const u = normalizeMaybeHref(url);
                        if (!u) return;
                        const info = getPanCodeProviderInfoByHref(u);
                        if (!info) return;
                        captured = u;
                        if (canRecord) recordPanCodeForHref(u, c);
                    };

                    const originalOpen = window.open;
                    try {
                        window.open = function(url, target, features) {
                            try {
                                wrapUrl(url);
                            } catch (e) {}
                            return originalOpen.call(window, url, target, features);
                        };
                    } catch (e) {}

                    const stop = () => {
                        if (stopped) return captured;
                        stopped = true;
                        try {
                            window.open = originalOpen;
                        } catch (e) {}
                        return captured;
                    };
                    setTimeout(stop, 1500);
                    return { stop, getCaptured: () => captured };
                };

                let lastSig = '';
                let lastAt = 0;
                const retryMap = new WeakMap();

                const handleDialog = (dialog) => {
                    if (!dialog || !(dialog instanceof Element)) return;
                    if (!isElementVisible(dialog)) return;
                    const text = String(dialog.textContent || '').replace(/\s+/g, ' ').trim();
                    if (!text) return;
                    const goEl = findFirstClickableByText(dialog, /^(?:å‰å¾€|å»å¾€|å»ç½‘ç›˜|æ‰“å¼€|è¿›å…¥)$/i) || findFirstClickableByText(dialog, /å‰å¾€/i);

                    const code = extractPanCodeFromText(text);
                    const targetHref = inferTargetHrefFromDialog(dialog);
                    if (!targetHref && !goEl) return;

                    const sig = `${code}|${targetHref}|${text.slice(0, 60)}`;
                    const now = Date.now();
                    if (sig === lastSig && now - lastAt < 1200) return;
                    lastSig = sig;
                    lastAt = now;

                    if (code) {
                        try {
                            copyTextToClipboard(code);
                        } catch (e) {}
                    }

                    if (targetHref) {
                        if (code) recordPanCodeForHref(targetHref, code);
                        const ok = openUrlInNewTab(targetHref);
                        if (ok && s && s.passiveTipsEnabled) showPassiveTip(code ? 'ITå¤©ç©ºï¼šå·²å‰å¾€ç½‘ç›˜ï¼ˆæå–ç å·²è®°å½•ï¼‰' : 'ITå¤©ç©ºï¼šå·²å‰å¾€ç½‘ç›˜');
                        return;
                    }

                    if (code) stashPendingPanCode(code);
                    const capture = installPanOpenCapture(code);
                    try {
                        if (goEl) goEl.click();
                    } catch (e) {}
                    setTimeout(() => {
                        try {
                            const got = capture.stop();
                            if (got && s && s.passiveTipsEnabled) showPassiveTip(code ? 'ITå¤©ç©ºï¼šå·²å‰å¾€ç½‘ç›˜ï¼ˆæå–ç å·²è®°å½•ï¼‰' : 'ITå¤©ç©ºï¼šå·²å‰å¾€ç½‘ç›˜');
                        } catch (e) {}
                    }, 600);

                    const prev = retryMap.get(dialog) || 0;
                    if (prev < 2) {
                        retryMap.set(dialog, prev + 1);
                        setTimeout(() => {
                            try {
                                handleDialog(dialog);
                            } catch (e) {}
                        }, prev === 0 ? 280 : 900);
                    }
                };

                const scan = (root) => {
                    const base = root && root.nodeType === 1 ? root : document.body || document.documentElement;
                    if (!base || !(base instanceof Element)) return;
                    let candidates = [];
                    try {
                        candidates = base.querySelectorAll('[role="dialog"], .el-dialog__wrapper, .el-dialog, .ant-modal, .modal, .dialog');
                    } catch (e) {
                        candidates = [];
                    }
                    for (let i = 0; i < candidates.length; i++) handleDialog(candidates[i]);
                    try {
                        if (
                            base.matches &&
                            base.matches('[role="dialog"], .el-dialog__wrapper, .el-dialog, .ant-modal, .modal, .dialog')
                        ) {
                            handleDialog(base);
                        }
                    } catch (e) {}
                };

                let queued = false;
                const queueScan = (node) => {
                    if (queued) return;
                    queued = true;
                    setTimeout(() => {
                        queued = false;
                        scan(document.body || document.documentElement);
                    }, 80);
                };

                const observer = new MutationObserver((records) => {
                    for (let i = 0; i < records.length; i++) {
                        const r = records[i];
                        if (r && r.type === 'attributes') {
                            const t = r.target;
                            if (t && t.nodeType === 1) queueScan(t);
                            continue;
                        }
                        const list = r && r.addedNodes ? r.addedNodes : null;
                        if (!list || !list.length) continue;
                        for (let j = 0; j < list.length; j++) {
                            const n = list[j];
                            if (!n || n.nodeType !== 1) continue;
                            queueScan(n);
                            break;
                        }
                    }
                });
                try {
                    observer.observe(document.documentElement || document.body, {
                        childList: true,
                        subtree: true,
                        attributes: true,
                        attributeFilter: ['style', 'class', 'open', 'aria-hidden'],
                    });
                } catch (e) {}
                queueScan(document.body || document.documentElement);

                itskCloudQueryAutoJumpStop = () => {
                    try {
                        observer.disconnect();
                    } catch (e) {}
                };
            }

            function applyItskCloudQueryAutoJump(active) {
                const shouldEnable = Boolean(active) && isTopWindow();
                if (!shouldEnable) return stopItskCloudQueryAutoJump();
                startItskCloudQueryAutoJump(settings);
            }

            function applySmartRedirectForPage(currentSettings) {
                if (smartRedirectAutoJumpDone) return;
                if (!currentSettings.smartRedirectEnabled || !currentSettings.smartRedirectAutoJump) return;
                smartRedirectAutoJumpDone = true;
                withErrorBoundary('smartRedirectAutoJump', () => {
                    const from = location.href;
                    const match = resolveSmartRedirectChainFromUrl(location.href, ['redirectPage', 'both']);
                    const target = match && match.target ? match.target : null;
                    if (!target || target === location.href) return;
                    stashSmartRedirectTip(buildSmartRedirectTip(match, 'autoJump'));
                    debugLog(
                        'autoJumpRedirectPage',
                        { from: location.href, to: target, host: getCurrentHost(), provider: match && match.provider ? match.provider : null },
                        'INFO'
                    );
                    try {
                        location.replace(target);
                    } catch (e) {
                        try {
                            location.href = target;
                        } catch (e2) {}
                    }
                    setTimeout(() => {
                        if (normalizeTipUrl(location.href) !== normalizeTipUrl(from)) return;
                        try {
                            location.replace(target);
                        } catch (e) {
                            try {
                                location.href = target;
                            } catch (e2) {}
                        }
                    }, 350);
                });
            }

            function readFeatureState() {
                const overlayEnabled = Boolean(settings.debugOverlay);
                const overlayVisible = !!DebugState.overlayEl;
                const goTBEnabled = Boolean(settings.pinScrollEnabled);
                const container = document.getElementById(GO_TB_UI_ID);
                const hasContainer = !!container;
                const hasTop = !!(container && container.querySelector('.gotop'));
                const hasBottom = !!(container && container.querySelector('.bottom'));
                let visible = false;
                if (container) {
                    try {
                        const cs = window.getComputedStyle ? getComputedStyle(container) : null;
                        if (!cs) visible = container.style.display !== 'none';
                        else visible = cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0';
                    } catch (e) {
                        visible = container.style.display !== 'none';
                    }
                }
                return {
                    overlayEnabled,
                    overlayVisible,
                    goTBEnabled,
                    goTBContainer: hasContainer,
                    goTBHasTop: hasTop,
                    goTBHasBottom: hasBottom,
                    goTBVisible: visible,
                };
            }

            function syncFeatureStates(reason) {
                const state = readFeatureState();
                debugLog('featureState', { reason, ...state, url: location.href }, 'DEBUG');
                if (state.overlayEnabled && !state.overlayVisible) {
                    applyDebugOverlay();
                }
                if (!state.goTBEnabled) return;
                if (state.goTBContainer && !state.goTBVisible) {
                    try {
                        const container = document.getElementById(GO_TB_UI_ID);
                        if (container) {
                            container.style.display = '';
                            container.style.visibility = '';
                            container.style.opacity = '';
                        }
                    } catch (e) {}
                }
                if (!state.goTBContainer || !state.goTBHasTop || !state.goTBHasBottom) {
                    try {
                        stopGoTopBottomControls();
                    } catch (e) {}
                    startGoTopBottomControls();
                    const next = readFeatureState();
                    debugLog(
                        'featureRecover',
                        {
                            reason,
                            ok: next.goTBContainer && next.goTBHasTop && next.goTBHasBottom,
                            ...next,
                            url: location.href,
                        },
                        'INFO'
                    );
                }
            }

            /**
             * æŒ‰å½“å‰è®¾ç½®å¯ç”¨æˆ–åœç”¨è„šæœ¬ä¸»åŠŸèƒ½å…¥å£
             */
            function applyRuntimeSettings() {
                runSelfCheckOnce();
                const excluded = isExcludedDomain(settings.excludeDomains);
                const runtimeShouldActive = Boolean(settings.enabled) && !excluded;
                applyAutoUnfold(!excluded && Boolean(settings.autoUnfoldEnabled));
                applyLoginPopupBypass(Boolean(settings.loginPopupBypassEnabled));
                applyCsdnStrongCopy(!excluded && Boolean(settings.csdnStrongCopyEnabled));
                applyCsdnCleanPage(!excluded && Boolean(settings.csdnCleanPageEnabled));
                applyCsdnCommentControl(runtimeShouldActive);
                applyCsdnBottomArticleControl(runtimeShouldActive);
                applyCsdnUnfreezeScroll(!excluded && Boolean(settings.csdnUnfreezeScrollEnabled));
                applyCsdnLoginJumpGuard(runtimeShouldActive);
                applyCsdnRedirectFastJump(!excluded && Boolean(settings.csdnRedirectFastJumpEnabled));
                applyQqMailCleanVipBubble(runtimeShouldActive);
                applyPanCodeAssist(!excluded && Boolean(settings.panCodeAssistEnabled));
                applyPanCodeSmartSelectHotkey(!excluded && Boolean(settings.panCodeAssistEnabled), settings);
                applyHoverTitleEnhancer(runtimeShouldActive, settings);
                applyItskCloudQueryAutoJump(runtimeShouldActive);
                SmartRedirectHintState.tipRecheckAllowed = runtimeShouldActive;
                if (!runtimeShouldActive) stopSmartRedirectTipRecheck();
                const smartRedirectTipShown =
                    consumeSmartRedirectTip(runtimeShouldActive) ||
                    consumeSmartRedirectTipForUrl(location.href, runtimeShouldActive);
                if (runtimeShouldActive && !smartRedirectTipShown) ensureSmartRedirectTipRecheck();
                const wasRuntimeActive = runtimeActive;
                const beforeFeatureState = readFeatureState();
                applyGoTopBottomControls(Boolean(settings.pinScrollEnabled));
                applyDebugOverlay();
                applyCopyCurrentUrlHotkey(runtimeShouldActive, settings);
                applyVisitedLinkColor(runtimeShouldActive, settings);
                applyBaiduSearchEnhance(runtimeShouldActive);
                debugLog('apply', { enabled: Boolean(settings.enabled), excluded, active: runtimeShouldActive });
                if (!runtimeShouldActive) {
                    if (runtimeActive) deactivateRuntime();
                    runtimeActive = false;
                    syncFeatureStates('applyRuntimeSettings.inactive');
                    return;
                }
                applySmartRedirectForPage(settings);
                if (!runtimeActive) runtimeActive = true;
                activateRuntime();
                syncFeatureStates('applyRuntimeSettings.active');
                const afterFeatureState = readFeatureState();
                const runtimeBecameActive = !wasRuntimeActive && runtimeActive;
                const overlayBecameVisible = !beforeFeatureState.overlayVisible && afterFeatureState.overlayVisible;
                const goTBBecameVisible = !beforeFeatureState.goTBVisible && afterFeatureState.goTBVisible;
                const goTBInjected = !beforeFeatureState.goTBContainer && afterFeatureState.goTBContainer;
                if (runtimeBecameActive || overlayBecameVisible || goTBBecameVisible || goTBInjected) {
                    if (!smartRedirectTipShown) {
                        let tipMsg = '';
                        if (overlayBecameVisible) tipMsg = 'è°ƒè¯•ï¼šæ‚¬æµ®çª—å·²å¼€å¯';
                        else if (goTBInjected || goTBBecameVisible) tipMsg = 'ç½®é¡¶/ç½®åº•ï¼šæŒ‰é’®å·²æ˜¾ç¤º';
                        else if (runtimeBecameActive) tipMsg = 'æ–°æ ‡ç­¾é¡µProï¼šæ–°æ ‡ç­¾é¡µæ‰“å¼€å·²ç”Ÿæ•ˆ';
                        scheduleGenericActiveTip(tipMsg);
                    }
                }
            }

            function activateRuntime() {
                applyDebugOverlay();
                debugLog('activate', { url: location.href });
                startClickInterceptor();
                ensureBaseTargetBlank();
                scheduleApplyAllTargets(settings);
                if (settings.enableDiscuz) targetDiscuz();
                if (settings.enableObserver) startObserver();
                else stopObserver();
                if (settings.enableTextLinkify && shouldEnableTextLinkifyForPage(settings)) startTextLinkify();
                else stopTextLinkify();
                ensureShortLinkCacheCleanup();
            }

            function deactivateRuntime() {
                debugLog('deactivate', { url: location.href });
                stopCsdnStrongCopy();
                stopCsdnCleanPage();
                stopCsdnCommentControl();
                stopCsdnBottomArticleControl();
                stopCsdnUnfreezeScroll();
                stopCsdnLoginJumpGuard();
                stopBaiduSearchEnhance();
                stopScheduledApplyAllTargets();
                stopObserver();
                stopTextLinkify();
                stopClickInterceptor();
                removeBaseTargetBlank();
                restoreAllManagedTargets();
                applyDebugOverlay();
                stopShortLinkCacheCleanup();
            }

            /**
             * ç¡®ä¿å…¨å±€ <base> target ä¸º _blankï¼Œç”¨äºç»Ÿä¸€é»˜è®¤æ‰“å¼€æ–¹å¼
             */
            function ensureBaseTargetBlank() {
                const head = document.head || document.getElementsByTagName('head')[0];
                if (!head) return;
                let base = document.getElementById(BASE_ID);
                if (!base) {
                    base = document.createElement('base');
                    base.id = BASE_ID;
                    const firstBase = head.querySelector && head.querySelector('base');
                    head.insertBefore(base, firstBase || head.firstChild);
                }
                base.removeAttribute('href');
                base.target = '_blank';
            }

            /**
             * ç§»é™¤è„šæœ¬æ’å…¥çš„ <base>ï¼Œæ¢å¤é¡µé¢åŸæœ‰è¡Œä¸º
             */
            function removeBaseTargetBlank() {
                const base = document.getElementById(BASE_ID);
                if (base) base.remove();
            }

            function markManagedTarget(el) {
                if (!el || !(el instanceof Element)) return;
                if (!el.hasAttribute(ORIG_TARGET_ATTR)) {
                    const orig = el.getAttribute('target');
                    el.setAttribute(ORIG_TARGET_ATTR, orig == null ? '' : orig);
                }
                el.setAttribute(MANAGED_ATTR, '1');
            }

            function setManagedTarget(el, target) {
                if (!el || !(el instanceof Element)) return;
                markManagedTarget(el);
                el.setAttribute('target', target);
            }

            function restoreManagedTarget(el) {
                if (!el || !(el instanceof Element)) return;
                if (!el.hasAttribute(MANAGED_ATTR)) return;
                const orig = el.getAttribute(ORIG_TARGET_ATTR);
                if (orig == null || orig === '') el.removeAttribute('target');
                else el.setAttribute('target', orig);
                el.removeAttribute(MANAGED_ATTR);
                el.removeAttribute(ORIG_TARGET_ATTR);
            }

            function restoreAllManagedTargets() {
                const managed = document.querySelectorAll(`[${MANAGED_ATTR}]`);
                for (let i = 0; i < managed.length; i++) restoreManagedTarget(managed[i]);
            }

            const ApplyAllTargetsState = {
                sig: '',
                job: null,
                idleId: 0,
                timerId: 0,
            };

            function stopScheduledApplyAllTargets() {
                const job = ApplyAllTargetsState.job;
                if (job) job.cancelled = true;
                ApplyAllTargetsState.job = null;
                ApplyAllTargetsState.sig = '';
                if (ApplyAllTargetsState.idleId && typeof cancelIdleCallback === 'function') {
                    try {
                        cancelIdleCallback(ApplyAllTargetsState.idleId);
                    } catch (e) {}
                }
                ApplyAllTargetsState.idleId = 0;
                if (ApplyAllTargetsState.timerId) {
                    try {
                        clearTimeout(ApplyAllTargetsState.timerId);
                    } catch (e2) {}
                }
                ApplyAllTargetsState.timerId = 0;
            }

            function resolveApplyAllTargetsSig(currentSettings) {
                const s = currentSettings || settings;
                return [
                    location.href,
                    s.keepOnclickSelf ? 1 : 0,
                    s.keepNonHttpSelf ? 1 : 0,
                    s.keepHashSelf ? 1 : 0,
                    s.keepEmptyHrefSelf ? 1 : 0,
                    s.keepFormSelf ? 1 : 0,
                    s.onlyExternalNewTab ? 1 : 0,
                    s.smartRedirectEnabled ? 1 : 0,
                    s.smartRedirectCleanLink ? 1 : 0,
                    s.visitedLinkColorEnabled ? 1 : 0,
                    s.visitedLinkHistoryScope || '',
                ].join('|');
            }

            function scheduleApplyAllTargets(currentSettings) {
                const sig = resolveApplyAllTargetsSig(currentSettings);
                if (ApplyAllTargetsState.job && ApplyAllTargetsState.sig === sig) return;
                stopScheduledApplyAllTargets();
                ApplyAllTargetsState.sig = sig;
                const job = { cancelled: false };
                ApplyAllTargetsState.job = job;

                const pageHost = getCurrentHost();
                const anchors = document.querySelectorAll('a');
                const forms = document.querySelectorAll('form');
                let ai = 0;
                let fi = 0;
                const startedAt = Date.now();

                const now = () => {
                    try {
                        if (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') return performance.now();
                    } catch (e) {}
                    return Date.now();
                };

                const scheduleNext = () => {
                    if (job.cancelled) return;
                    if (typeof requestIdleCallback === 'function') {
                        try {
                            ApplyAllTargetsState.idleId = requestIdleCallback(step, { timeout: 300 });
                            return;
                        } catch (e) {}
                    }
                    try {
                        ApplyAllTargetsState.timerId = setTimeout(() => step(null), 0);
                    } catch (e2) {
                        ApplyAllTargetsState.timerId = 0;
                    }
                };

                const step = (deadline) => {
                    if (job.cancelled) return;
                    const start = now();
                    const budgetMs = computeBudgetMs(deadline, 4, 12, 8);

                    while (ai < anchors.length && now() - start < budgetMs) {
                        applyAnchorRules(anchors[ai++], currentSettings, pageHost);
                    }
                    while (ai >= anchors.length && fi < forms.length && now() - start < budgetMs) {
                        applyFormRules(forms[fi++], currentSettings);
                    }

                    if (job.cancelled) return;
                    if (ai < anchors.length || fi < forms.length) return scheduleNext();

                    ApplyAllTargetsState.job = null;
                    ApplyAllTargetsState.sig = '';
                    debugLog('applyAllTargetsDone', { a: anchors.length, f: forms.length, ms: Date.now() - startedAt }, 'DEBUG');
                };

                scheduleNext();
            }

            function shouldKeepSelfForAnchor(anchor, currentSettings, pageHost) {
                const hrefAttr = anchor.getAttribute('href');
                const hrefRaw = hrefAttr == null ? '' : String(hrefAttr).trim();
                const hasHrefAttr = hrefRaw !== '';

                if (currentSettings.keepEmptyHrefSelf && !hasHrefAttr) return true;
                if (currentSettings.keepHashSelf && hasHrefAttr && hrefRaw.startsWith('#')) return true;

                if (currentSettings.keepOnclickSelf) {
                    const onclickAttr = anchor.getAttribute('onclick');
                    if (onclickAttr && /(return\s+false|preventDefault\s*\()/i.test(String(onclickAttr))) return true;
                    try {
                        const onclickProp = anchor.onclick;
                        if (typeof onclickProp === 'function') {
                            const code = Function.prototype.toString.call(onclickProp);
                            if (/(return\s+false|preventDefault\s*\()/i.test(String(code))) return true;
                        }
                    } catch (e) {}
                }

                if (currentSettings.keepNonHttpSelf) {
                    const m = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.exec(hrefRaw);
                    if (m) {
                        const scheme = m[0].slice(0, -1).toLowerCase();
                        if (scheme !== 'http' && scheme !== 'https') return true;
                    }
                }

                if (currentSettings.onlyExternalNewTab) {
                    try {
                        const u = new URL(hrefRaw, location.href);
                        const linkHost = String(u.hostname || '').toLowerCase();
                        if (linkHost && pageHost && linkHost === pageHost) return true;
                    } catch (e) {}
                }

                return false;
            }

            function getKeepSelfReasonForAnchor(anchor, currentSettings, pageHost) {
                try {
                    const hrefAttr = anchor.getAttribute('href');
                    const hrefRaw = hrefAttr == null ? '' : String(hrefAttr).trim();
                    const hasHrefAttr = hrefRaw !== '';
                    if (currentSettings.keepEmptyHrefSelf && !hasHrefAttr) return 'emptyHref';
                    if (currentSettings.keepHashSelf && hasHrefAttr && hrefRaw.startsWith('#')) return 'hash';

                    if (currentSettings.keepOnclickSelf) {
                        const onclickAttr = anchor.getAttribute('onclick');
                        if (onclickAttr && /(return\s+false|preventDefault\s*\()/i.test(String(onclickAttr))) return 'onclickAttr';
                        try {
                            const onclickProp = anchor.onclick;
                            if (typeof onclickProp === 'function') {
                                const code = Function.prototype.toString.call(onclickProp);
                                if (/(return\s+false|preventDefault\s*\()/i.test(String(code))) return 'onclickProp';
                            }
                        } catch (e) {}
                    }

                    if (currentSettings.keepNonHttpSelf) {
                        const m = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.exec(hrefRaw);
                        if (m) {
                            const scheme = m[0].slice(0, -1).toLowerCase();
                            if (scheme !== 'http' && scheme !== 'https') return 'nonHttp';
                        }
                    }

                    if (currentSettings.onlyExternalNewTab) {
                        try {
                            const u = new URL(hrefRaw, location.href);
                            const linkHost = String(u.hostname || '').toLowerCase();
                            if (linkHost && pageHost && linkHost === pageHost) return 'sameHost';
                        } catch (e) {}
                    }
                } catch (e) {}
                return 'unknown';
            }

            function applyAnchorRules(anchor, currentSettings, pageHost) {
                if (!anchor || anchor.tagName !== 'A') return;

                if (shouldKeepSelfForAnchor(anchor, currentSettings, pageHost)) {
                    setManagedTarget(anchor, '_self');
                    syncVisitedAttrForAnchor(anchor, currentSettings, pageHost, null);
                    return;
                }

                try {
                    const hrefAttr = anchor.getAttribute('href');
                    const hrefRaw = hrefAttr == null ? '' : String(hrefAttr).trim();
                    if (hrefRaw) {
                        const repaired = repairDoubleSchemeUrl(hrefRaw);
                        if (repaired && repaired !== hrefRaw) anchor.setAttribute('href', repaired);
                    }
                } catch (e) {}

                if (currentSettings.smartRedirectEnabled && currentSettings.smartRedirectCleanLink) {
                    const hrefAttr = anchor.getAttribute('href');
                    const hrefRaw = hrefAttr == null ? '' : String(hrefAttr).trim();
                    if (hrefRaw) {
                        const hrefAbs = resolveAbsoluteHref(hrefRaw, anchor);
                        if (hrefAbs) {
                            const match = resolveSmartRedirectChainFromUrl(hrefAbs, ['link', 'both']);
                            const cleaned = match && match.target ? match.target : null;
                            if (cleaned && cleaned !== hrefAbs && cleaned !== hrefRaw) {
                                try {
                                    anchor.setAttribute('href', cleaned);
                                } catch (e) {}
                            }
                        }
                    }
                }

                const targetAttr = anchor.getAttribute('target');
                const normalizedTarget = String(targetAttr || '').trim().toLowerCase();
                if (normalizedTarget === '_blank' && !anchor.hasAttribute(MANAGED_ATTR)) markManagedTarget(anchor);
                else setManagedTarget(anchor, '_blank');
                syncVisitedAttrForAnchor(anchor, currentSettings, pageHost, null);
            }

            /**
             * æŒ‰è®¾ç½®è§„åˆ™è°ƒæ•´ form çš„ target è¡Œä¸º
             */
            function applyFormRules(form, currentSettings) {
                if (!form || form.tagName !== 'FORM') return;
                if (!currentSettings.keepFormSelf) {
                    restoreManagedTarget(form);
                    return;
                }
                const targetAttr = form.getAttribute('target');
                const hasTarget = targetAttr != null && String(targetAttr).trim() !== '';
                if (!hasTarget) setManagedTarget(form, '_self');
            }

            /**
             * å¯åŠ¨ MutationObserverï¼Œå¤„ç†åŠ¨æ€æ’å…¥çš„é“¾æ¥
             */
            function startObserver() {
                if (observerStop) return;
                observerStop = aObserver(settings);
            }

            /**
             * åœæ­¢ MutationObserver
             */
            function stopObserver() {
                if (!observerStop) return;
                try {
                    observerStop();
                } catch (e) {}
                observerStop = null;
            }

            /**
             * å¯åŠ¨ç‚¹å‡»æ‹¦æˆªå™¨ï¼Œä¿®æ­£ç«™ç‚¹é˜»æ­¢æ–°æ ‡ç­¾é¡µæ‰“å¼€çš„è¡Œä¸º
             */
            function startClickInterceptor() {
                if (clickInterceptorStop) return;
                clickInterceptorStop = clickInterceptor(settings);
            }

            /**
             * åœæ­¢ç‚¹å‡»æ‹¦æˆªå™¨
             */
            function stopClickInterceptor() {
                if (!clickInterceptorStop) return;
                try {
                    clickInterceptorStop();
                } catch (e) {}
                clickInterceptorStop = null;
            }

            function extractMicrosoftStoreProductIdFromPath(pathname) {
                const p = String(pathname || '');
                if (!p) return '';
                const segs = p.split('/').filter(Boolean);
                for (let i = segs.length - 1; i >= 0; i--) {
                    const s = String(segs[i] || '').trim();
                    if (/^[0-9A-Za-z]{12}$/.test(s)) return s.toUpperCase();
                }
                return '';
            }

            function buildMicrosoftStoreCanonicalUrl(productId) {
                const id = String(productId || '').trim();
                if (!id) return '';
                return `https://apps.microsoft.com/store/detail/${id}`;
            }

            function extractEdgeAddonIdFromPath(pathname) {
                const p = String(pathname || '');
                if (!p) return '';
                const segs = p.split('/').filter(Boolean);
                for (let i = segs.length - 1; i >= 0; i--) {
                    const s = String(segs[i] || '').trim();
                    if (/^[0-9A-Za-z]{32}$/.test(s)) return s.toLowerCase();
                }
                return '';
            }

            const SMART_REDIRECT_RULES = [
                {
                    name: 'Microsoft Store é“¾æ¥',
                    type: 'both',
                    hosts: ['www.microsoft.com'],
                    pathPrefix: null,
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ path }) => {
                        if (!path || (!path.startsWith('/store/') && !path.startsWith('/p/'))) return null;
                        const productId = extractMicrosoftStoreProductIdFromPath(path);
                        if (!productId) return null;
                        return buildMicrosoftStoreCanonicalUrl(productId);
                    },
                },
                {
                    name: 'Microsoft Store é“¾æ¥',
                    type: 'both',
                    hosts: ['apps.microsoft.com'],
                    pathPrefix: null,
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ url, path }) => {
                        if (!path || !path.startsWith('/store/detail/')) return null;
                        const productId = extractMicrosoftStoreProductIdFromPath(path);
                        if (!productId) return null;
                        const canonical = buildMicrosoftStoreCanonicalUrl(productId);
                        const current = `${url.origin}${url.pathname}`;
                        if (current === canonical) return null;
                        return canonical;
                    },
                },
                {
                    name: 'Chrome Web Store é“¾æ¥',
                    type: 'both',
                    hosts: ['chrome.google.com'],
                    pathPrefix: '/webstore/detail/',
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ url, path }) => {
                        if (!path) return null;
                        const nextPath = path.startsWith('/webstore/') ? path.slice('/webstore'.length) : path;
                        const next = `https://chromewebstore.google.com${nextPath}${url.search}${url.hash}`;
                        return next;
                    },
                },
                {
                    name: 'Edge Add-ons é“¾æ¥',
                    type: 'both',
                    hosts: ['microsoftedge.microsoft.com'],
                    pathPrefix: '/addons/detail/',
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ path }) => {
                        const id = extractEdgeAddonIdFromPath(path);
                        if (!id) return null;
                        return `https://microsoftedge.microsoft.com/addons/detail/${id}`;
                    },
                },
                {
                    name: 'Firefox Add-ons é“¾æ¥',
                    type: 'both',
                    hosts: ['addons.mozilla.org'],
                    pathPrefix: null,
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ url, path }) => {
                        if (!path || path.indexOf('/firefox/addon/') === -1) return null;
                        const m = /\/firefox\/addon\/([^/]+)/.exec(path);
                        const slug = m && m[1] ? String(m[1]) : '';
                        if (!slug) return null;
                        const canonical = `https://addons.mozilla.org/firefox/addon/${slug}/`;
                        const current = `${url.origin}${url.pathname}`;
                        if (current === canonical) return null;
                        return canonical;
                    },
                },
                {
                    name: 'Bing /ck è·³è½¬',
                    type: 'both',
                    hosts: ['www.bing.com', 'cn.bing.com'],
                    pathPrefix: '/ck/',
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ searchParams }) => {
                        const encoded = searchParams.get('u');
                        return normalizeSmartRedirectTargetValue(decodeBingRedirectU(encoded));
                    },
                },
                {
                    name: 'Steam å¤–é“¾',
                    type: 'both',
                    hosts: ['steamcommunity.com', 'store.steampowered.com', 'help.steampowered.com'],
                    pathPrefix: '/linkfilter/',
                    queryParams: ['url'],
                    hashParams: [],
                },
                {
                    name: 'Facebook å¤–é“¾',
                    type: 'both',
                    hosts: ['l.facebook.com', 'lm.facebook.com', 'l.messenger.com'],
                    pathPrefix: '/l.php',
                    queryParams: ['u'],
                    hashParams: [],
                },
                {
                    name: 'Reddit å¤–é“¾',
                    type: 'both',
                    hosts: ['out.reddit.com'],
                    pathPrefix: null,
                    queryParams: ['url'],
                    hashParams: [],
                },
                {
                    name: 'çŸ¥ä¹å¤–é“¾',
                    type: 'both',
                    hosts: ['link.zhihu.com'],
                    pathPrefix: null,
                    queryParams: ['target', 'url', 'u'],
                    hashParams: ['target', 'url', 'u'],
                },
                {
                    name: 'çŸ¥ä¹ç«™å†…è·³è½¬',
                    type: 'both',
                    hosts: ['www.zhihu.com'],
                    pathPrefix: '/redirect',
                    queryParams: ['target', 'url', 'u'],
                    hashParams: ['target', 'url', 'u'],
                },
                {
                    name: 'æ˜é‡‘å¤–é“¾',
                    type: 'both',
                    hosts: ['link.juejin.cn'],
                    pathPrefix: null,
                    queryParams: ['target', 'url'],
                    hashParams: [],
                },
                {
                    name: 'CSDN å¤–é“¾',
                    type: 'both',
                    hosts: ['link.csdn.net'],
                    pathPrefix: null,
                    queryParams: ['target', 'url'],
                    hashParams: [],
                },
                {
                    name: '423down å¤–é“¾',
                    type: 'both',
                    hosts: ['www.423down.com', '423down.com'],
                    pathPrefix: '/go.php',
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ searchParams }) => {
                        let encoded = '';
                        try {
                            encoded = searchParams.get('url') || '';
                        } catch (e) {
                            encoded = '';
                        }
                        const decoded = decodeUrlSafeBase64ToString(encoded);
                        return normalizeSmartRedirectTargetValue(decoded);
                    },
                },
                {
                    name: 'ç™¾åº¦é“¾æ¥è·³è½¬',
                    type: 'redirectPage',
                    hosts: ['www.baidu.com'],
                    pathPrefix: '/link',
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ searchParams }) => {
                        let raw = '';
                        try {
                            raw = searchParams.get('url') || '';
                        } catch (e) {
                            raw = '';
                        }
                        if (!raw) return null;
                        const hasExplicitProtocol = /^https?:\/\//i.test(raw);
                        const hasEncodedProtocol = /https?%3A%2F%2F/i.test(raw);
                        if (!hasExplicitProtocol && !hasEncodedProtocol) return null;
                        return normalizeSmartRedirectTargetValue(raw);
                    },
                },
                {
                    name: 'é…·å®‰é“¾æ¥è·³è½¬',
                    type: 'both',
                    hosts: ['www.coolapk.com'],
                    pathPrefix: '/link',
                    queryParams: ['url'],
                    hashParams: [],
                },
                {
                    name: 'Google å¤–é“¾',
                    type: 'both',
                    hosts: ['www.google.com', 'www.google.com.hk'],
                    pathPrefix: '/url',
                    queryParams: ['url', 'q'],
                    hashParams: [],
                },
                {
                    name: 'å¾®åšå¤–é“¾',
                    type: 'both',
                    hosts: ['weibo.cn', 'weibo.com'],
                    pathPrefix: null,
                    queryParams: ['u', 'url'],
                    hashParams: [],
                },
                {
                    name: 'ç®€ä¹¦å¤–é“¾',
                    type: 'both',
                    hosts: ['www.jianshu.com'],
                    pathPrefix: '/go-wild',
                    queryParams: ['url'],
                    hashParams: [],
                },
                {
                    name: 'QQPC å¤–é“¾',
                    type: 'both',
                    hosts: ['c.pc.qq.com'],
                    pathPrefix: '/middlem.html',
                    queryParams: ['pfurl', 'url'],
                    hashParams: [],
                },
                {
                    name: 'QQPC å¤–é“¾',
                    type: 'both',
                    hosts: ['c.pc.qq.com'],
                    pathPrefix: '/middlect.html',
                    queryParams: ['pfurl', 'url'],
                    hashParams: [],
                },
                {
                    name: 'QQ é‚®ç®±å¤–é“¾ç¡®è®¤é¡µ',
                    type: 'both',
                    hosts: ['mail.qq.com', 'wx.mail.qq.com', 'exmail.qq.com', 'en.mail.qq.com', 'service.mail.qq.com'],
                    pathPrefix: '/cgi-bin/readtemplate',
                    queryParams: [],
                    hashParams: [],
                    resolve: ({ searchParams, hashParams }) => {
                        const keys = ['url', 'u', 'target', 'dest', 'pfurl', 'link', 'redirect', 'to', 'gourl', 'goto', 'jump', 'jump_url', 'jumpurl'];
                        for (let i = 0; i < keys.length; i++) {
                            const k = keys[i];
                            let value = '';
                            try {
                                value = searchParams.get(k) || '';
                            } catch (e) {
                                value = '';
                            }
                            if (!value && hashParams) {
                                try {
                                    value = hashParams.get(k) || '';
                                } catch (e2) {
                                    value = '';
                                }
                            }
                            const target = normalizeSmartRedirectTargetValue(value);
                            if (target) return target;
                        }
                        return null;
                    },
                },
                {
                    name: 'ç«™é•¿ä¹‹å®¶å¤–é“¾',
                    type: 'both',
                    hosts: ['www.chinaz.com'],
                    pathPrefix: '/go.shtml',
                    queryParams: ['url'],
                    hashParams: [],
                },
                {
                    name: 'å¾®ä¿¡å¼€æ”¾ç¤¾åŒºå¤–é“¾',
                    type: 'both',
                    hosts: ['developers.weixin.qq.com'],
                    pathPrefix: '/community/middlepage/href',
                    queryParams: ['href'],
                    hashParams: [],
                },
                {
                    name: 'è…¾è®¯æ–‡æ¡£å¤–é“¾',
                    type: 'both',
                    hosts: ['docs.qq.com'],
                    pathPrefix: '/scenario/link.html',
                    queryParams: ['url'],
                    hashParams: [],
                },
                {
                    name: 'å¤©çœ¼æŸ¥å¤–é“¾',
                    type: 'both',
                    hosts: ['www.tianyancha.com'],
                    pathPrefix: '/security',
                    queryParams: ['target', 'redirectUrl'],
                    hashParams: [],
                },
                {
                    name: 'è¯­é›€å¤–é“¾',
                    type: 'both',
                    hosts: ['.yuque.com'],
                    pathPrefix: '/r/goto',
                    queryParams: ['url'],
                    hashParams: [],
                },
                {
                    name: 'é‡‘å±±æ–‡æ¡£å¤–é“¾',
                    type: 'both',
                    hosts: ['www.kdocs.cn'],
                    pathPrefix: '/office/link',
                    queryParams: ['target', 'url'],
                    hashParams: [],
                },
                {
                    name: 'å°‘æ•°æ´¾å¤–é“¾',
                    type: 'both',
                    hosts: ['sspai.com', 'niu.sspai.com'],
                    pathPrefix: '/link',
                    queryParams: ['target', 'url'],
                    hashParams: [],
                },
                {
                    name: 'å“”å“©å“”å“©å¤–é“¾',
                    type: 'both',
                    hosts: ['game.bilibili.com'],
                    pathPrefix: '/linkfilter/',
                    queryParams: ['url'],
                    hashParams: [],
                },
            ];

            const SMART_REDIRECT_FAST_TOKENS = [
                '://www.microsoft.com/store/',
                '://www.microsoft.com/p/',
                '://apps.microsoft.com/store/detail/',
                '://chrome.google.com/webstore/detail/',
                '://microsoftedge.microsoft.com/addons/detail/',
                'addons.mozilla.org/firefox/addon/',
                '://www.bing.com/ck/',
                '://cn.bing.com/ck/',
                '://steamcommunity.com/linkfilter/',
                '://store.steampowered.com/linkfilter/',
                '://help.steampowered.com/linkfilter/',
                '://l.facebook.com/l.php',
                '://lm.facebook.com/l.php',
                '://l.messenger.com/l.php',
                '://out.reddit.com/',
                '://link.zhihu.com',
                '://www.zhihu.com/redirect',
                '://link.juejin.cn',
                '://link.csdn.net',
                '://www.423down.com/go.php?url=',
                '://423down.com/go.php?url=',
                '://www.baidu.com/link',
                '://www.coolapk.com/link',
                '://www.google.com/url',
                '://www.google.com.hk/url',
                '://weibo.cn/',
                '://weibo.com/',
                '://www.jianshu.com/go-wild',
                '://c.pc.qq.com/middlem.html',
                '://c.pc.qq.com/middlect.html',
                '://mail.qq.com/cgi-bin/readtemplate',
                '://wx.mail.qq.com/cgi-bin/readtemplate',
                '://exmail.qq.com/cgi-bin/readtemplate',
                '://www.chinaz.com/go.shtml',
                '://developers.weixin.qq.com/community/middlepage/href',
                '://docs.qq.com/scenario/link.html',
                '://www.tianyancha.com/security',
                'yuque.com/r/goto',
                '://www.kdocs.cn/office/link',
                '://sspai.com/link',
                '://niu.sspai.com/link',
                '://game.bilibili.com/linkfilter/',
            ];

            const SMART_SHORTLINK_PROVIDERS = [
                { name: 'å¾®åšçŸ­é“¾', hosts: ['t.cn'] },
                { name: 'å¾®ä¿¡/QQ çŸ­é“¾', hosts: ['url.cn'] },
                { name: 'B ç«™çŸ­é“¾', hosts: ['b23.tv'] },
                { name: 'äº¬ä¸œçŸ­é“¾', hosts: ['u.jd.com'] },
                { name: 'æ·˜å®çŸ­é“¾', hosts: ['tb.cn', 'm.tb.cn'] },
                { name: 'Bitly', hosts: ['bit.ly'] },
                { name: 'TinyURL', hosts: ['tinyurl.com'] },
            ];

            function decodeUrlSafeBase64ToString(encoded) {
                const raw = String(encoded || '').trim();
                if (!raw) return '';
                const normalized = raw.replace(/-/g, '+').replace(/_/g, '/');
                const mod = normalized.length % 4;
                const padded = mod ? normalized + '='.repeat(4 - mod) : normalized;
                try {
                    return atob(padded);
                } catch (e) {
                    return '';
                }
            }

            function detectSmartShortLinkProvider(href) {
                let url;
                try {
                    url = new URL(String(href || ''), location.href);
                } catch (e) {
                    return null;
                }
                const host = String(url.hostname || '').toLowerCase();
                if (!host) return null;
                for (let i = 0; i < SMART_SHORTLINK_PROVIDERS.length; i++) {
                    const row = SMART_SHORTLINK_PROVIDERS[i];
                    const hosts = row && Array.isArray(row.hosts) ? row.hosts : [];
                    for (let j = 0; j < hosts.length; j++) {
                        const h = String(hosts[j] || '').toLowerCase();
                        if (!h) continue;
                        if (host === h || host.endsWith(`.${h}`)) {
                            return { name: String(row.name || ''), host };
                        }
                    }
                }
                return null;
            }

            function resolveSmartShortLinkTarget(href, provider, callback) {
                if (typeof callback !== 'function') return;
                const url = String(href || '').trim();
                if (!url) {
                    callback(null, { status: 'empty' });
                    return;
                }
                if (typeof GM_xmlhttpRequest !== 'function') {
                    callback(null, { status: 'noGM' });
                    return;
                }
                let fromCache = false;
                try {
                    const cached = SmartShortLinkSessionCache.get(url);
                    const now = Date.now();
                    if (cached && typeof cached.at === 'number' && now - cached.at < 800) {
                        fromCache = true;
                        try { DebugState.metrics.cacheHits++; updateDebugMetricsUI(); } catch (e) {}
                        callback(cached.target, cached.detail);
                        return;
                    }
                } catch (e) {}
                let done = false;
                let timer = 0;
                const finish = (target, detail) => {
                    if (done) return;
                    done = true;
                    if (timer) {
                        try {
                            clearTimeout(timer);
                        } catch (e) {}
                        timer = 0;
                    }
                    try {
                        SmartShortLinkSessionCache.set(url, { target, detail: detail || { status: 'unknown' }, at: Date.now() });
                    } catch (e) {}
                    try {
                        if (!fromCache) {
                            DebugState.metrics.cacheMiss++;
                            updateDebugMetricsUI();
                        }
                    } catch (e) {}
                    callback(target, detail || { status: 'unknown' });
                };
                try {
                    timer = setTimeout(() => {
                        finish(null, { status: 'timeout' });
                    }, 8000);
                } catch (e) {
                    timer = 0;
                }
                let usedMethod = '';
                gmGet(url, { Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' }, 8000)
                    .then((resp) => {
                        usedMethod = 'onload';
                        const finalUrlRaw = resp && resp.finalUrl ? String(resp.finalUrl) : url;
                        const target = normalizeSmartRedirectTargetValue(finalUrlRaw) || finalUrlRaw;
                        const status = resp && typeof resp.status === 'number' ? resp.status : 0;
                        finish(target, { status: 'ok', code: status, via: usedMethod, provider: provider && provider.name ? String(provider.name) : '' });
                    })
                    .catch((err) => {
                        const s = err && err.status ? String(err.status) : '';
                        if (s === 'timeout') usedMethod = 'ontimeout';
                        else usedMethod = 'onerror';
                        finish(null, { status: s || 'error', via: usedMethod, provider: provider && provider.name ? String(provider.name) : '' });
                    });
            }
            function gmGet(url, headers, timeoutMs, retries) {
                return new Promise((resolve, reject) => {
                    const maxRetries = typeof retries === 'number' && retries > 0 ? Math.min(retries, 3) : 0;
                    let attempt = 0;
                    const run = () => {
                        try {
                            GM_xmlhttpRequest({
                                method: 'GET',
                                url,
                                headers: headers || {},
                                nocache: true,
                                timeout: typeof timeoutMs === 'number' && timeoutMs > 0 ? timeoutMs : 8000,
                                onload: (resp) => resolve(resp),
                                onerror: () => {
                                    if (attempt < maxRetries) {
                                        attempt++;
                                        setTimeout(run, 200 * attempt);
                                        return;
                                    }
                                    reject({ status: 'error' });
                                },
                                ontimeout: () => {
                                    if (attempt < maxRetries) {
                                        attempt++;
                                        setTimeout(run, 300 * attempt);
                                        return;
                                    }
                                    reject({ status: 'timeout' });
                                },
                            });
                        } catch (e) {
                            reject({ status: 'exception', error: String(e && e.message ? e.message : e) });
                        }
                    };
                    run();
                });
            }

            function ensureShortLinkCacheCleanup() {
                if (shortLinkCacheCleanupTimer) return;
                try {
                    shortLinkCacheCleanupTimer = setInterval(() => {
                        const now = Date.now();
                        const keys = Array.from(SmartShortLinkSessionCache.keys());
                        for (let i = 0; i < keys.length; i++) {
                            const k = keys[i];
                            const row = SmartShortLinkSessionCache.get(k);
                            if (!row || typeof row.at !== 'number') {
                                SmartShortLinkSessionCache.delete(k);
                                continue;
                            }
                            if (now - row.at > SHORTLINK_CACHE_TTL_MS) SmartShortLinkSessionCache.delete(k);
                        }
                    }, SHORTLINK_CACHE_CLEAN_INTERVAL_MS);
                } catch (e) {
                    shortLinkCacheCleanupTimer = 0;
                }
            }
            function stopShortLinkCacheCleanup() {
                if (!shortLinkCacheCleanupTimer) return;
                try {
                    clearInterval(shortLinkCacheCleanupTimer);
                } catch (e) {}
                shortLinkCacheCleanupTimer = 0;
            }

            function decodeBingRedirectU(encoded) {
                let v = String(encoded || '').trim();
                if (!v) return '';
                if (v.startsWith('a1')) v = v.slice(2);
                return decodeUrlSafeBase64ToString(v);
            }

            function normalizeSmartRedirectTargetValue(raw) {
                let v = String(raw || '').trim();
                if (!v) return null;
                for (let i = 0; i < 3; i++) {
                    let decoded;
                    try {
                        decoded = decodeURIComponent(v);
                    } catch (e) {
                        break;
                    }
                    if (decoded === v) break;
                    v = decoded;
                }

                v = v.trim();
                if (!v) return null;
                if (v.startsWith('//')) v = 'https:' + v;
                else if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(v) && v[0] !== '/') {
                    const firstSeg = v.split('/')[0] || '';
                    const hostSeg = firstSeg.startsWith('[') ? firstSeg : firstSeg.split(':')[0] || '';
                    const hostLower = hostSeg.toLowerCase();
                    const hostLooksValid =
                        hostLower === 'localhost' ||
                        hostLower.includes('.') ||
                        /^\d{1,3}(\.\d{1,3}){3}$/.test(hostLower) ||
                        (hostLower.startsWith('[') && hostLower.endsWith(']'));
                    if (!hostLooksValid) return null;
                    v = 'https://' + v;
                }

                let url;
                try {
                    url = new URL(v);
                } catch (e) {
                    return null;
                }
                const protocol = String(url.protocol || '').toLowerCase();
                if (protocol !== 'http:' && protocol !== 'https:') return null;
                return url.href;
            }

            function buildSmartRedirectTip(match, scene) {
                const provider = match && match.provider ? String(match.provider || '') : '';
                if (scene === 'autoJump') {
                    if (provider) return `æ™ºèƒ½å»é‡å®šå‘å·²ç”Ÿæ•ˆï¼šå·²è‡ªåŠ¨è·³è¿‡ä¸­è½¬ï¼ˆ${provider}ï¼‰`;
                    return 'æ™ºèƒ½å»é‡å®šå‘å·²ç”Ÿæ•ˆï¼šå·²è‡ªåŠ¨è·³è¿‡ä¸­è½¬';
                }
                if (provider) return `æ™ºèƒ½å»é‡å®šå‘å·²ç”Ÿæ•ˆï¼šå·²æ¸…ç†é‡å®šå‘é“¾æ¥ï¼ˆ${provider}ï¼‰`;
                return 'æ™ºèƒ½å»é‡å®šå‘å·²ç”Ÿæ•ˆï¼šå·²æ¸…ç†é‡å®šå‘é“¾æ¥';
            }

            function resolveSmartRedirectMatchFromUrl(href, allowedTypes) {
                if (!href) return null;
                const rawHref = String(href || '');
                let fastHit = false;
                for (let i = 0; i < SMART_REDIRECT_FAST_TOKENS.length; i++) {
                    if (rawHref.indexOf(SMART_REDIRECT_FAST_TOKENS[i]) !== -1) {
                        fastHit = true;
                        break;
                    }
                }
                if (!fastHit) return null;
                let url;
                try {
                    url = new URL(rawHref);
                } catch (e) {
                    return null;
                }
                const host = String(url.hostname || '').toLowerCase();
                const path = String(url.pathname || '');
                const searchParams = url.searchParams;
                const hashRaw = url.hash ? url.hash.replace(/^#/, '') : '';
                const hashParams = hashRaw && hashRaw.indexOf('=') !== -1 ? new URLSearchParams(hashRaw) : null;
                const types = Array.isArray(allowedTypes) && allowedTypes.length ? allowedTypes : null;
                const tryFromParams = (names) => {
                    if (!names || !names.length) return null;
                    for (let i = 0; i < names.length; i++) {
                        const name = names[i];
                        let value = searchParams.get(name);
                        if (!value && hashParams) value = hashParams.get(name);
                        if (!value) continue;
                        const target = normalizeSmartRedirectTargetValue(value);
                        if (target) return target;
                    }
                    return null;
                };
                for (let i = 0; i < SMART_REDIRECT_RULES.length; i++) {
                    const rule = SMART_REDIRECT_RULES[i];
                    const ruleType = String(rule.type || 'both');
                    if (types && types.indexOf(ruleType) === -1) continue;
                    const hosts = Array.isArray(rule.hosts) ? rule.hosts : [];
                    let hostMatched = false;
                    for (let j = 0; j < hosts.length; j++) {
                        const h = String(hosts[j] || '').toLowerCase();
                        if (!h) continue;
                        if (h[0] === '.') {
                            if (host === h.slice(1) || host.endsWith(h)) {
                                hostMatched = true;
                                break;
                            }
                        } else if (host === h) {
                            hostMatched = true;
                            break;
                        }
                    }
                    if (!hostMatched) continue;
                    if (rule.pathPrefix && !path.startsWith(rule.pathPrefix)) continue;
                    if (typeof rule.resolve === 'function') {
                        const target = rule.resolve({ url, href: rawHref, host, path, searchParams, hashParams });
                        if (target) {
                            debugLog(
                                'smartRedirectMatch',
                                { href, target, provider: rule.name || null, type: ruleType, host },
                                'DEBUG'
                            );
                            return { target, provider: rule.name || null, type: ruleType, host };
                        }
                    }
                    const target = tryFromParams(rule.queryParams || []);
                    if (target) {
                        debugLog(
                            'smartRedirectMatch',
                            { href, target, provider: rule.name || null, type: ruleType, host },
                            'DEBUG'
                        );
                        return { target, provider: rule.name || null, type: ruleType, host };
                    }
                    if (hashParams) {
                        const targetFromHash = tryFromParams(rule.hashParams || []);
                        if (targetFromHash) {
                            debugLog(
                                'smartRedirectMatch',
                                { href, target: targetFromHash, provider: rule.name || null, type: ruleType, host },
                                'DEBUG'
                            );
                            return { target: targetFromHash, provider: rule.name || null, type: ruleType, host };
                        }
                    }
                }
                return null;
            }

            function resolveSmartRedirectChainFromUrl(href, allowedTypes, maxDepth) {
                const depthLimit = typeof maxDepth === 'number' && maxDepth > 0 ? Math.min(8, Math.floor(maxDepth)) : 4;
                let current = String(href || '').trim();
                if (!current) return null;
                const seen = new Set([current]);
                const providers = [];
                let lastMatch = null;
                for (let i = 0; i < depthLimit; i++) {
                    const match = resolveSmartRedirectMatchFromUrl(current, allowedTypes);
                    const next = match && match.target ? String(match.target || '').trim() : '';
                    if (!next || next === current) break;
                    lastMatch = match;
                    if (match && match.provider) providers.push(match.provider);
                    if (seen.has(next)) break;
                    seen.add(next);
                    current = next;
                }
                if (!lastMatch) return null;
                return {
                    target: current,
                    provider: providers.length ? providers.join('â†’') : lastMatch.provider || null,
                    providers,
                    type: lastMatch.type || null,
                    host: lastMatch.host || null,
                };
            }

            function resolveSmartRedirectTargetFromUrl(href, allowedTypes) {
                const match = resolveSmartRedirectChainFromUrl(href, allowedTypes);
                return match && match.target ? match.target : null;
            }

            /**
             * ç‚¹å‡»æ‹¦æˆªå™¨æ ¸å¿ƒå®ç°ï¼Œç»Ÿä¸€åœ¨åå°å¤„ç†â€œæ–°æ ‡ç­¾é¡µæ‰“å¼€â€
             */
            function clickInterceptor(currentSettings) {
                const pageHost = getCurrentHost();
                let lastOpenedHref = '';
                let lastOpenedAt = 0;
                const preferNativeNewTabHosts = new Set(['greasyfork.org', 'sleazyfork.org']);
                const preferNativeNewTab = preferNativeNewTabHosts.has(pageHost);
                const smartRedirectEnabled = Boolean(currentSettings.smartRedirectEnabled);
                const smartRedirectCleanLink = smartRedirectEnabled && Boolean(currentSettings.smartRedirectCleanLink);
                const smartShortLinkEnabled = smartRedirectEnabled && Boolean(currentSettings.smartShortLinkEnabled);
                const isReferrerSensitiveLink = (href) => {
                    let u;
                    try {
                        u = new URL(String(href || ''), location.href);
                    } catch (e) {
                        u = null;
                    }
                    if (!u) return false;
                    const host = String(u.hostname || '').toLowerCase();
                    if (!host) return false;
                    if (host === 's.click.taobao.com') return true;
                    if (host === 'click.mz.simba.taobao.com') return true;
                    if (host.endsWith('.simba.taobao.com')) return true;
                    return false;
                };
                const openInNewTab = (url) => {
                    if (!url) return { ok: false, method: 'none' };
                    if (typeof GM_openInTab === 'function') {
                        try {
                            GM_openInTab(String(url), { active: true, insert: true, setParent: true });
                            return { ok: true, method: 'GM_openInTab' };
                        } catch (e) {}
                    }
                    try {
                        const w = window.open(String(url), '_blank', 'noopener,noreferrer');
                        if (w) {
                            try {
                                w.opener = null;
                            } catch (e2) {}
                            return { ok: true, method: 'window.open' };
                        }
                    } catch (e) {}
                    return { ok: false, method: 'none' };
                };

                const onActivate = (e) => {
                    if (!e) return;
                    if (typeof e.button === 'number' && e.button !== 0) return;
                    if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
                    if (isEventFromSettingsPanel(e)) return;

                    let a = null;
                    const path = typeof e.composedPath === 'function' ? e.composedPath() : null;
                    if (path && path.length) {
                        for (let i = 0; i < path.length; i++) {
                            const n = path[i];
                            if (!(n instanceof Element)) continue;
                            if (n.tagName === 'A') {
                                a = n;
                                break;
                            }
                        }
                    }
                    if (!a) {
                        const t = e.target;
                        if (!(t instanceof Element)) return;
                        if (t.isContentEditable) return;
                        a = t.closest && t.closest('a');
                    }
                    if (!a || a.tagName !== 'A') return;
                    let isManaged = a.hasAttribute(MANAGED_ATTR);
                    if (!isManaged && !smartRedirectCleanLink) {
                        const t = String(a.getAttribute('target') || '')
                            .trim()
                            .toLowerCase();
                        if (t !== '_blank') return;
                        try {
                            markManagedTarget(a);
                            isManaged = true;
                        } catch (e0) {}
                    }
                    if (a.isContentEditable) return;
                    if (a.hasAttribute('download')) return;

                    const hrefAttr = a.getAttribute('href');
                    let hrefRaw = hrefAttr == null ? '' : String(hrefAttr).trim();
                    let href = '';
                    try {
                        if (!hrefRaw) hrefRaw = resolveAnchorHrefForHoverTitle(a) || '';
                        if (!hrefRaw) throw new Error('emptyHref');
                        href = new URL(hrefRaw, location.href).href;
                    } catch (e2) {
                        try {
                            href = String(a.href || hrefRaw || '');
                            if (!hrefRaw) hrefRaw = href;
                        } catch (e3) {
                            href = '';
                        }
                    }
                    try {
                        if (SelectionClickSuppressState.until && Date.now() < SelectionClickSuppressState.until) {
                            let intersected = false;
                            try {
                                const sel = window.getSelection ? window.getSelection() : null;
                                if (sel && !sel.isCollapsed && sel.rangeCount) {
                                    const r = sel.getRangeAt(0);
                                    if (r && typeof r.intersectsNode === 'function') intersected = Boolean(r.intersectsNode(a));
                                }
                            } catch (e0) {
                                intersected = false;
                            }
                            if (intersected) {
                                try {
                                    e.preventDefault();
                                    if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                    else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                                } catch (e3) {}
                                return;
                            }
                            const keys = SelectionClickSuppressState.keys || [];
                            let canon = href;
                            try {
                                canon = new URL(String(canon || ''), location.href).href;
                            } catch (e0) {
                                canon = href;
                            }
                            if (!canon) canon = hrefRaw || '';
                            if (!canon) {
                                try {
                                    canon = resolveAnchorHrefForHoverTitle(a) || '';
                                } catch (e0) {
                                    canon = '';
                                }
                            }
                            let sanitized = '';
                            try {
                                sanitized = sanitizePanShareUrl(canon);
                            } catch (e1) {
                                sanitized = '';
                            }
                            const candidates = [];
                            if (canon) candidates.push(canon);
                            if (sanitized && sanitized !== canon) candidates.push(sanitized);
                            try {
                                const panKey = normalizePanCodeCacheKey(sanitized || canon);
                                if (panKey) candidates.push(`pan:${panKey}`);
                            } catch (e2) {}
                            let hit = false;
                            for (let i = 0; i < candidates.length && !hit; i++) {
                                const v = String(candidates[i] || '');
                                for (let j = 0; j < keys.length; j++) {
                                    if (v && v === String(keys[j] || '')) {
                                        hit = true;
                                        break;
                                    }
                                }
                            }
                            if (hit) {
                                try {
                                    e.preventDefault();
                                    if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                    else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                                } catch (e3) {}
                                return;
                            }
                        }
                    } catch (e0) {}
                    if (!href) return;
                    const repairedHref = repairDoubleSchemeUrl(href);
                    if (repairedHref && repairedHref !== href) href = repairedHref;

                    const panInfo = getPanCodeProviderInfoByHref(href);
                    if (panInfo) {
                        try {
                            const sel = window.getSelection ? window.getSelection() : null;
                            if (sel && !sel.isCollapsed && sel.rangeCount) {
                                let hit = false;
                                try {
                                    const r = sel.getRangeAt(0);
                                    if (r && typeof r.intersectsNode === 'function') hit = Boolean(r.intersectsNode(a));
                                } catch (e2) {
                                    hit = false;
                                }
                                if (hit) {
                                    try {
                                        e.preventDefault();
                                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                        else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                                    } catch (e3) {}
                                    debugLog('panSelectionBypassOpen', () => ({ href, detail: typeof e.detail === 'number' ? e.detail : null, host: pageHost }), 'INFO');
                                    return;
                                }
                            }
                        } catch (e2) {}
                    }

                    if (isManaged && isReferrerSensitiveLink(href)) {
                        debugLog('bypassOpen', () => ({ href, host: pageHost, reason: 'referrerSensitiveLink' }), 'INFO');
                        return;
                    }

                    if (pageHost === 'itsk.com' || pageHost === 'www.itsk.com' || pageHost.endsWith('.itsk.com')) {
                        try {
                            const u = new URL(href);
                            const host = String(u.hostname || '').toLowerCase();
                            const path = String(u.pathname || '');
                            const name = u.searchParams.get('name') || '';
                            const isCloudBtn = a.classList && a.classList.contains('cloud-download-a');
                            if ((host === 'itsk.com' || host.endsWith('.itsk.com')) && path === '/download' && (isCloudBtn || name)) return;
                        } catch (e2) {}
                    }

                    debugLog('click', () => ({
                        type: e.type,
                        href,
                        hrefRaw,
                        prevented: Boolean(e.defaultPrevented),
                        host: pageHost,
                        button: typeof e.button === 'number' ? e.button : null,
                        detail: typeof e.detail === 'number' ? e.detail : null,
                        targetTag: e.target && e.target.tagName ? String(e.target.tagName) : null,
                        anchorTarget: a.getAttribute('target'),
                    }));
                    let redirectMatch = null;
                    let cleaned = null;
                    if (smartRedirectCleanLink) {
                        redirectMatch = resolveSmartRedirectChainFromUrl(href, ['link', 'both']);
                        cleaned = redirectMatch && redirectMatch.target ? redirectMatch.target : null;
                    }
                    if (cleaned) {
                        const repairedCleaned = repairDoubleSchemeUrl(cleaned);
                        if (repairedCleaned && repairedCleaned !== cleaned) cleaned = repairedCleaned;
                    }
                    if (!isManaged) {
                        if (!cleaned || cleaned === href) return;
                        debugLog(
                            'redirectClean',
                            () => ({ from: href, to: cleaned, host: pageHost, provider: redirectMatch && redirectMatch.provider ? redirectMatch.provider : null }),
                            'INFO'
                        );
                        const tip = buildSmartRedirectTip(redirectMatch, 'cleanLink');
                        stashSmartRedirectTipForUrl(tip, cleaned);
                        showPassiveTip(tip);

                        const keepSelf = shouldKeepSelfForAnchor(a, currentSettings, pageHost);
                        if (keepSelf) {
                            try {
                                e.preventDefault();
                                if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                            } catch (e2) {}
                            debugLog('open', () => ({ href: cleaned, ok: true, method: 'location', preferNativeNewTab }));
                            try {
                                location.assign(cleaned);
                            } catch (e3) {
                                try {
                                    location.href = cleaned;
                                } catch (e4) {}
                            }
                            return;
                        }
                        href = cleaned;
                    }

                    if (shouldKeepSelfForAnchor(a, currentSettings, pageHost)) {
                        const keepReason = getKeepSelfReasonForAnchor(a, currentSettings, pageHost);
                        const isOnclickKeep = keepReason === 'onclickAttr' || keepReason === 'onclickProp';
                        const canBypass = isOnclickKeep && cleaned && cleaned !== href;
                        if (!canBypass) {
                            debugLog('keepSelf', () => ({ href, reason: keepReason }));
                            return;
                        }
                        debugLog(
                            'keepSelfBypass',
                            () => ({ href, to: cleaned, reason: keepReason, provider: redirectMatch && redirectMatch.provider ? redirectMatch.provider : null }),
                            'INFO'
                        );
                    }

                    if (smartRedirectCleanLink && cleaned && cleaned !== href) {
                        debugLog(
                            'redirectClean',
                            () => ({ from: href, to: cleaned, host: pageHost, provider: redirectMatch && redirectMatch.provider ? redirectMatch.provider : null }),
                            'INFO'
                        );
                        const tip = buildSmartRedirectTip(redirectMatch, 'cleanLink');
                        stashSmartRedirectTipForUrl(tip, cleaned);
                        showPassiveTip(tip);
                        href = cleaned;
                    }

                    const openWithFinalHref = (finalHref, extra) => {
                        const targetHref = String(finalHref || href || '').trim();
                        if (!targetHref) return;
                        const now = Date.now();
                        const isDuplicate = targetHref === lastOpenedHref && now - lastOpenedAt < getShortLinkDebounceMs(settings);
                        if (isDuplicate) {
                            try {
                                e.preventDefault();
                                if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                            } catch (e2) {}
                            debugLog('duplicate', () => ({ href: targetHref }));
                            return;
                        }
                        const opened = openInNewTab(targetHref);
                        debugLog(
                            'open',
                            () => ({
                                href: targetHref,
                                ok: opened && opened.ok,
                                method: opened && opened.method,
                                preferNativeNewTab,
                                shortLink: extra && extra.shortLink ? true : false,
                                shortLinkStatus: extra && extra.status ? extra.status : null,
                                shortLinkProvider: extra && extra.provider ? extra.provider : null,
                            })
                        );
                        if (!opened || !opened.ok) {
                            const reason = resolveOpenFailureReason(opened, targetHref);
                            markOpenFailure(targetHref, reason);
                            return;
                        }
                        if (currentSettings && currentSettings.visitedLinkColorEnabled) {
                            const eligible = syncVisitedEligibleAttrForAnchor(a, currentSettings, pageHost, targetHref);
                            if (eligible) {
                                recordVisitedHref(targetHref, currentSettings, pageHost);
                                try {
                                    a.setAttribute(VISITED_ATTR, '1');
                                } catch (e2) {}
                            }
                        }
                        lastOpenedHref = targetHref;
                        lastOpenedAt = now;
                        try {
                            e.preventDefault();
                            if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                            else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                        } catch (e3) {}
                        if (DebugState.failureMap.has(targetHref)) {
                            DebugState.failureMap.delete(targetHref);
                            ensureFailuresRendered();
                            debugLog('openRecovered', () => ({ href: targetHref }), 'INFO');
                        }
                    };

                    if (smartShortLinkEnabled) {
                        const provider = detectSmartShortLinkProvider(href);
                        if (provider) {
                            debugLog(
                                'shortLinkResolveStart',
                                () => ({
                                    href,
                                    host: provider.host,
                                    provider: provider.name || '',
                                }),
                                'INFO'
                            );
                            try {
                                e.preventDefault();
                                if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                                else if (typeof e.stopPropagation === 'function') e.stopPropagation();
                            } catch (e2) {}
                            resolveSmartShortLinkTarget(href, provider, (target, detail) => {
                                const info = detail || {};
                                const providerName = provider && provider.name ? String(provider.name) : '';
                                const status = info.status || 'unknown';
                                const finalHref = target && target !== href ? target : href;
                                if (target && target !== href) {
                                    debugLog(
                                        'shortLinkResolved',
                                        () => ({
                                            from: href,
                                            to: target,
                                            provider: providerName,
                                            status,
                                            code: typeof info.code === 'number' ? info.code : null,
                                        }),
                                        'INFO'
                                    );
                                    const tip = SmartRedirectHintState && SmartRedirectHintState.anchorTip ? buildSmartRedirectTip({ provider: providerName }, 'cleanLink') : '';
                                    if (tip) {
                                        stashSmartRedirectTipForUrl(tip, target);
                                        showPassiveTip(tip);
                                    }
                                } else {
                                    debugLog(
                                        'shortLinkResolveFallback',
                                        () => ({
                                            href,
                                            provider: providerName,
                                            status,
                                        }),
                                        'DEBUG'
                                    );
                                }
                                openWithFinalHref(finalHref, {
                                    shortLink: true,
                                    status,
                                    provider: providerName || null,
                                });
                            });
                            return;
                        }
                    }

                    openWithFinalHref(href, null);
                };

                addListener(window, 'click', onActivate, { passive: false, capture: true });
                return () => {
                    removeListener(window, 'click', onActivate, { passive: false, capture: true });
                };
            }

            function matchHostList(host, raw) {
                const h = String(host || '').toLowerCase();
                if (!h) return false;
                const key = `${h}__${String(raw || '').trim()}`;
                const cached = HostListResultCache.get(key);
                if (typeof cached === 'boolean') return cached;
                const compiled = (() => {
                    const k = String(raw || '').trim();
                    const hit = HostListCompileCache.get(k);
                    if (hit) return hit;
                    const tokens = k.split(/[,ï¼Œ]+/g).map((s) => s.trim()).filter(Boolean);
                    if (!tokens.length) {
                        const r = { plains: [], wildcards: [], regexes: [] };
                        HostListCompileCache.set(k, r);
                        return r;
                    }
                    const plains = [];
                    const wildcards = [];
                    const regexes = [];
                    for (let i = 0; i < tokens.length; i++) {
                        const t = tokens[i];
                        if (!t) continue;
                        if (t[0] === '/' && t.lastIndexOf('/') > 0) {
                            const last = t.lastIndexOf('/');
                            const body = t.slice(1, last);
                            const flags = t.slice(last + 1) || 'i';
                            try {
                                regexes.push(new RegExp(body, flags));
                            } catch (e) {}
                            continue;
                        }
                        if (t.startsWith('*.')) {
                            wildcards.push(t.slice(2).toLowerCase());
                            continue;
                        }
                        plains.push(t.toLowerCase());
                    }
                    const r = { plains, wildcards, regexes };
                    HostListCompileCache.set(k, r);
                    return r;
                })();
                let ok = false;
                for (let i = 0; i < compiled.plains.length; i++) {
                    const p = compiled.plains[i];
                    if (h === p || h.endsWith(`.${p}`)) {
                        ok = true;
                        break;
                    }
                }
                if (!ok) {
                    for (let i = 0; i < compiled.wildcards.length; i++) {
                        const w = compiled.wildcards[i];
                        if (h === w || h.endsWith(`.${w}`)) {
                            ok = true;
                            break;
                        }
                    }
                }
                if (!ok) {
                    for (let i = 0; i < compiled.regexes.length; i++) {
                        const r = compiled.regexes[i];
                        try {
                            if (r.test(h)) {
                                ok = true;
                                break;
                            }
                        } catch (e) {}
                    }
                }
                HostListResultCache.set(key, ok);
                return ok;
            }

            function shouldEnableTextLinkifyForPage(currentSettings) {
                const host = getCurrentHost();
                if (!host) return false;
                if (host === 'update.greasyfork.org' || host.endsWith('.update.greasyfork.org')) return true;
                if (host === 'pagetual.hoothin.com' || host.endsWith('.pagetual.hoothin.com')) return false;
                const includeRaw = currentSettings.textLinkifyIncludeHosts || '';
                const excludeRaw = currentSettings.textLinkifyExcludeHosts || '';
                const hasInclude = String(includeRaw).trim() !== '';
                const includeHit = hasInclude && matchHostList(host, includeRaw);
                const excludeHit = String(excludeRaw).trim() !== '' && matchHostList(host, excludeRaw);
                if (includeHit) return true;
                if (hasInclude && !includeHit) return false;
                if (excludeHit) return false;
                return true;
            }

            function startTextLinkify() {
                if (textLinkifyStop) return;
                ensureTextLinkifyStyle();
                ensureTextLinkifyTooltip();
                try {
                    textLinkifyStop = textLinkify(settings);
                    debugLog('textLinkifyStart', { ok: true });
                } catch (e) {
                    textLinkifyStop = null;
                    debugLog('textLinkifyStart', { ok: false, error: String(e && e.message ? e.message : e) }, 'ERROR');
                }
            }

            function stopTextLinkify() {
                if (!textLinkifyStop) return;
                try {
                    textLinkifyStop();
                } catch (e) {}
                textLinkifyStop = null;
            }

            function ensureTextLinkifyStyle() {
                const existing = document.getElementById(TEXT_LINKIFY_STYLE_ID);
                if (existing) return;
                const style = document.createElement('style');
                style.id = TEXT_LINKIFY_STYLE_ID;
                style.type = 'text/css';
                style.textContent = `
                    a.newtab-open-links-textlink {
                        color: #2563eb !important;
                        text-decoration: underline !important;
                        text-underline-offset: 2px;
                    }
                    a.newtab-open-links-textlink:hover {
                        color: #1d4ed8 !important;
                    }
                    .newtab-open-links-textlink-source {
                        margin-left: 4px;
                        padding: 1px 6px;
                        border-radius: 999px;
                        border: 1px solid rgba(148,163,184,.7);
                        background: rgba(15,23,42,.03);
                        color: inherit;
                        opacity: .8;
                        font-size: 11px;
                        line-height: 1.4;
                        white-space: nowrap;
                        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
                    }
                    .newtab-open-links-tooltip {
                        position: fixed;
                        z-index: 2147483645;
                        max-width: min(320px, 80vw);
                        padding: 6px 10px;
                        border-radius: 8px;
                        border: 1px solid rgba(15,23,42,.22);
                        background: rgba(15,23,42,.96);
                        color: #e5e7eb;
                        box-shadow: 0 12px 32px rgba(15,23,42,.55);
                        font-size: 12px;
                        line-height: 1.45;
                        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
                        pointer-events: none;
                        opacity: 0;
                        transform: translate(-50%, -4px);
                        transition: opacity .18s ease-out, transform .18s ease-out;
                        white-space: normal;
                        box-sizing: border-box;
                    }
                    .newtab-open-links-tooltip.is-visible {
                        opacity: 1;
                        transform: translate(-50%, 0);
                    }
                    .newtab-open-links-tooltip__title {
                        font-weight: 600;
                        margin-bottom: 2px;
                    }
                    .newtab-open-links-tooltip__desc {
                        font-size: 11px;
                        opacity: .9;
                    }
                    @media (max-width: 600px) {
                        .newtab-open-links-tooltip {
                            font-size: 11px;
                            max-width: 88vw;
                        }
                    }
                `;
                try {
                    (document.head || document.documentElement || document.body).appendChild(style);
                } catch (e) {}
            }

            function getOrCreateTextLinkifyTooltip() {
                if (textLinkifyTooltipEl && textLinkifyTooltipEl.parentNode) return textLinkifyTooltipEl;
                const el = document.getElementById(TEXT_LINKIFY_TOOLTIP_ID) || document.createElement('div');
                el.id = TEXT_LINKIFY_TOOLTIP_ID;
                el.className = 'newtab-open-links-tooltip';
                el.setAttribute('role', 'tooltip');
                el.setAttribute('aria-hidden', 'true');
                el.innerHTML = '<div class="newtab-open-links-tooltip__title">æ¥è‡ªã€Œæ–°æ ‡ç­¾é¡µProã€</div><div class="newtab-open-links-tooltip__desc">æ­¤é“¾æ¥å·²ç”±è„šæœ¬æ”¹ä¸ºåœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€ã€‚</div>';
                try {
                    (document.body || document.documentElement || document).appendChild(el);
                } catch (e) {}
                textLinkifyTooltipEl = el;
                return el;
            }

            function showTextLinkifyTooltip(target) {
                if (!target || !(target instanceof Element)) return;
                const href = String((target.getAttribute && target.getAttribute('href')) || target.href || '').trim();
                if (!/^https?:/i.test(href)) return;
                try { hideTextLinkifyTooltip(target); } catch (e0) {}
                try { hideHoverTip(); } catch (e1) {}
                const r = target.getBoundingClientRect && target.getBoundingClientRect();
                if (r && r.width < 3 && r.height < 3) return;
                const realOut = (function(u){
                    try {
                        const match = resolveSmartRedirectChainFromUrl(u, ['link','both','redirectPage']);
                        let out = match && match.target ? String(match.target || '').trim() : '';
                        if (!out) out = u;
                        const repaired = repairDoubleSchemeUrl(out);
                        return repaired || out;
                    } catch (e) {
                        return u;
                    }
                })(href);
                const badge = classifyHostBadge(realOut) || { kind:'textlink', badge:'é“¾æ¥' };
                showHoverTip(target, badge.kind || 'textlink', badge.badge || 'é“¾æ¥', realOut);
            }

            function hideTextLinkifyTooltip(target) {
                const el = textLinkifyTooltipEl;
                if (!el) return;
                el.classList.remove('is-visible');
                el.setAttribute('aria-hidden', 'true');
                const t = target || textLinkifyTooltipTarget;
                if (t && t.getAttribute && el.id && t.getAttribute('aria-describedby') === el.id) {
                    t.removeAttribute('aria-describedby');
                }
                textLinkifyTooltipTarget = null;
            }

            function scheduleTextLinkifyTooltip(target) {
                if (!target) return;
                if (textLinkifyTooltipTimer) {
                    clearTimeout(textLinkifyTooltipTimer);
                    textLinkifyTooltipTimer = 0;
                }
                textLinkifyTooltipTimer = setTimeout(() => {
                    textLinkifyTooltipTimer = 0;
                    showTextLinkifyTooltip(target);
                }, TEXT_LINKIFY_TOOLTIP_DELAY);
            }

            function cancelTextLinkifyTooltip(target) {
                if (textLinkifyTooltipTimer) {
                    clearTimeout(textLinkifyTooltipTimer);
                    textLinkifyTooltipTimer = 0;
                }
                hideTextLinkifyTooltip(target);
            }

            function attachTextLinkifyTooltipHandlers(a) {
                if (!a || !a.addEventListener) return;
                addListener(a, 'mouseenter', () => scheduleTextLinkifyTooltip(a), { passive: true });
                addListener(a, 'mouseleave', () => cancelTextLinkifyTooltip(a), { passive: true });
                addListener(a, 'focus', () => scheduleTextLinkifyTooltip(a), { passive: true });
                addListener(a, 'blur', () => cancelTextLinkifyTooltip(a), { passive: true });
            }

            function ensureTextLinkifyTooltip() {
                getOrCreateTextLinkifyTooltip();
            }

            function textLinkify(currentSettings) {
                const combinedRegex = getCombinedTextLinkifyRegex();
                const pageHost = getCurrentHost();
                const ignoredTags = new Set(['A', 'SCRIPT', 'STYLE', 'TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION', 'CODE', 'PRE', 'HEAD', 'TITLE']);
                const host = String(pageHost || '');
                if (host === 'update.greasyfork.org' || host.endsWith('.update.greasyfork.org')) {
                    const path = String(location && location.pathname ? location.pathname : '');
                    const ct = String(document.contentType || '').toLowerCase();
                    const looksMetaOrUser = /\.meta\.js$/i.test(path) || /\.user\.js$/i.test(path);
                    const looksPlain = ct.startsWith('text/plain') || ct.startsWith('text/javascript') || ct.startsWith('application/javascript') || ct.startsWith('application/x-javascript');
                    if (looksMetaOrUser || looksPlain) ignoredTags.delete('PRE');
                }
                const processedTextNodes = new WeakSet();
                const pendingNodes = new Set();
                let tipShown = false;

                let scheduled = false;
                let disposed = false;
                let idleId = 0;
                let rafId = 0;
                let timeoutId = 0;

                function sanitizeMatchedUrl(rawText, markdownUrl) {
                    const isMarkdown = !!markdownUrl;
                    const isWww = !isMarkdown && /^www\./i.test(rawText);
                    const rawUrl0 = isMarkdown ? markdownUrl : rawText;
                    const rawUrl = isWww ? `https://${rawUrl0}` : rawUrl0;
                    const extEnd = findLikelyFileExtensionEndForSplit(rawUrl);
                    const splitByExt = extEnd !== -1 && extEnd < rawUrl.length && shouldSplitAfterFileExtension(rawUrl, extEnd);
                    const realUrl = splitByExt ? rawUrl.slice(0, extEnd) : cleanUrlEnd(rawUrl);
                    const overflowText = splitByExt ? rawUrl.slice(extEnd) : rawUrl.slice(realUrl.length);
                    let displayText = isMarkdown ? '' : (isWww ? rawText : rawUrl);
                    if (isMarkdown) {
                        const idx = rawText.indexOf('](');
                        displayText = idx > 1 ? rawText.slice(1, idx) : (rawUrl || '');
                    }
                    return { realUrl, overflowText, displayText };
                }
                function findLikelyFileExtensionEndForSplit(url) {
                    const s = String(url || '');
                    if (!s) return -1;
                    const stop = s.search(/[?#]/);
                    const head = stop === -1 ? s : s.slice(0, stop);
                    const lowerHead = head.toLowerCase();
                    let bestEnd = -1;
                    for (let i = 0; i < TEXT_LINKIFY_FILE_EXTS.length; i++) {
                        const ext = TEXT_LINKIFY_FILE_EXTS[i];
                        const idx = lowerHead.lastIndexOf(ext);
                        if (idx !== -1) bestEnd = Math.max(bestEnd, idx + ext.length);
                    }
                    return bestEnd;
                }

                function shouldSplitAfterFileExtension(url, extEnd) {
                    const s = String(url || '');
                    if (!s) return false;
                    if (extEnd < 0 || extEnd >= s.length) return false;
                    const ch = s[extEnd];
                    if (!ch) return false;
                    if (/^[A-Za-z0-9]$/.test(ch)) return false;
                    if (/^[/?#&=._~%+\-]$/.test(ch)) return false;
                    return true;
                }

                function cleanUrlEnd(url) {
                    let s = String(url || '');
                    if (!s) return s;
                    const markdownGlueIdx = s.indexOf('](');
                    if (markdownGlueIdx > 0) return s.slice(0, markdownGlueIdx);
                    let parenOpen = 0;
                    let parenClose = 0;
                    let bracketOpen = 0;
                    let bracketClose = 0;
                    let braceOpen = 0;
                    let braceClose = 0;
                    for (let i = 0; i < s.length; i++) {
                        const ch = s[i];
                        if (ch === '(') parenOpen++;
                        else if (ch === ')') parenClose++;
                        else if (ch === '[') bracketOpen++;
                        else if (ch === ']') bracketClose++;
                        else if (ch === '{') braceOpen++;
                        else if (ch === '}') braceClose++;
                    }
                    const plainTrim = (c) =>
                        c === '.' ||
                        c === ',' ||
                        c === '!' ||
                        c === '?' ||
                        c === ';' ||
                        c === ':' ||
                        c === '\'' ||
                        c === '"' ||
                        c === 'ï¼Œ' ||
                        c === 'ã€‚' ||
                        c === 'ï¼' ||
                        c === 'ï¼Ÿ' ||
                        c === 'ï¼›' ||
                        c === 'ï¼š' ||
                        c === 'ã€' ||
                        c === 'â€¦' ||
                        c === 'ã€‹' ||
                        c === 'ã€‘' ||
                        c === 'ï¼‰';
                    while (s) {
                        const last = s[s.length - 1];
                        if (last === ')' && parenClose > parenOpen) {
                            s = s.slice(0, -1);
                            parenClose--;
                            continue;
                        }
                        if (last === ']' && bracketClose > bracketOpen) {
                            s = s.slice(0, -1);
                            bracketClose--;
                            continue;
                        }
                        if (last === '}' && braceClose > braceOpen) {
                            s = s.slice(0, -1);
                            braceClose--;
                            continue;
                        }
                        if (plainTrim(last)) {
                            s = s.slice(0, -1);
                            continue;
                        }
                        break;
                    }
                    return s;
                }

                function hasIgnoredAncestor(node) {
                    let cur = node;
                    while (cur && cur.nodeType === 1) {
                        const el = cur;
                        if (el.isContentEditable) return true;
                        if (el.namespaceURI && el.namespaceURI !== 'http://www.w3.org/1999/xhtml') return true;
                        if (ignoredTags.has(el.tagName)) return true;
                        cur = el.parentElement;
                    }
                    return false;
                }

                function quickTest(text) {
                    const t = String(text || '');
                    if (!t) return false;
                    combinedRegex.lastIndex = 0;
                    return combinedRegex.test(t);
                }

                function createLinkElement(url, text) {
                    const frag = document.createDocumentFragment();
                    const a = document.createElement('a');
                    a.href = url;
                    a.textContent = text == null ? url : String(text);
                    a.target = '_blank';
                    a.rel = 'noopener noreferrer';
                    a.className = 'newtab-open-links-textlink';
                    a.setAttribute('data-newtab-open-links-source', SCRIPT_LABEL);
                    a.setAttribute('data-newtab-open-links-kind', 'textLinkify');
                    a.removeAttribute('title');
                    applyAnchorRules(a, currentSettings, pageHost);
                    attachTextLinkifyTooltipHandlers(a);
                    frag.appendChild(a);
                    return frag;
                }

                function processTextNode(textNode) {
                    if (disposed) return;
                    if (!textNode || textNode.nodeType !== 3) return;
                    if (!textNode.parentNode) return;
                    if (processedTextNodes.has(textNode)) return;
                    if (hasIgnoredAncestor(textNode.parentNode)) return;

                    let text = textNode.nodeValue;
                    if (!quickTest(text)) return;

                    text = String(text || '');
                    combinedRegex.lastIndex = 0;
                    if (!combinedRegex.test(text)) return;

                    const frag = document.createDocumentFragment();
                    let lastIndex = 0;
                    let match;
                    combinedRegex.lastIndex = 0;

                    while ((match = combinedRegex.exec(text)) !== null) {
                        const matchStart = match.index;
                        const rawText = match[0];
                        const markdownUrl = match[1];
                        const s = sanitizeMatchedUrl(rawText, markdownUrl);

                        if (matchStart > lastIndex) {
                            frag.appendChild(document.createTextNode(text.slice(lastIndex, matchStart)));
                        }
                        frag.appendChild(createLinkElement(s.realUrl, s.displayText));
                        incMetric('tlLinks', 1);
                        if (!tipShown) {
                            tipShown = true;
                            showPassiveTip('æ–‡æœ¬é“¾æ¥ï¼šå·²è½¬æ¢ä¸ºå¯ç‚¹å‡»é“¾æ¥');
                        }
                        if (s.overflowText) frag.appendChild(document.createTextNode(s.overflowText));

                        lastIndex = matchStart + rawText.length;
                    }

                    if (lastIndex < text.length) {
                        frag.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }

                    processedTextNodes.add(textNode);
                    try {
                        textNode.parentNode.replaceChild(frag, textNode);
                    } catch (e) {}
                }

                function walkAndProcess(root) {
                    if (disposed) return;
                    if (!root) return;
                    const walker = document.createTreeWalker(
                        root,
                        NodeFilter.SHOW_TEXT,
                        {
                            acceptNode(node) {
                                if (!node || node.nodeType !== 3) return NodeFilter.FILTER_REJECT;
                                if (!node.parentNode) return NodeFilter.FILTER_REJECT;
                                if (processedTextNodes.has(node)) return NodeFilter.FILTER_REJECT;
                                if (hasIgnoredAncestor(node.parentNode)) return NodeFilter.FILTER_REJECT;
                                return quickTest(node.nodeValue) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                            },
                        }
                    );

                    let node;
                    while ((node = walker.nextNode())) processTextNode(node);
                }

                function runPending() {
                    if (disposed) return;
                    const startTs = Date.now();
                    const nodes = Array.from(pendingNodes);
                    pendingNodes.clear();
                    scheduled = false;
                    idleId = 0;
                    timeoutId = 0;
                    if (!nodes.length) return;
                    const limit = getTextLinkifyRunLimit();
                    const max = typeof limit === 'number' && limit > 0 ? limit : nodes.length;
                    const count = nodes.length < max ? nodes.length : max;
                    debugLogSampling('textLinkifyRun', () => ({ count, limit, pending: nodes.length }), 'DEBUG', 100);
                    for (let i = 0; i < count; i++) {
                        const node = nodes[i];
                        if (!node) continue;
                        if (node.nodeType === 3) processTextNode(node);
                        else if (node.nodeType === 1) walkAndProcess(node);
                    }
                    incMetric('tlBatches', 1);
                    try { DebugState.metrics.tlLastMs = Math.max(0, Date.now() - startTs); } catch (e) {}
                    updateDebugMetricsUI();
                    if (nodes.length > count) {
                        for (let i = count; i < nodes.length; i++) {
                            const node = nodes[i];
                            if (!node) continue;
                            if (node.nodeType !== 1 && node.nodeType !== 3) continue;
                            pendingNodes.add(node);
                        }
                        scheduleProcessing();
                    }
                }

                function scheduleProcessing() {
                    if (disposed || scheduled) return;
                    scheduled = true;
                    const id = scheduleIdleRafTimeout('textLinkifyRun', runPending, 600, true, 50);
                    if (typeof id === 'number') idleId = id;
                }

                const textLinkifyObserverCallback = (mutations) => {
                    if (disposed) return;
                    for (let i = 0; i < mutations.length; i++) {
                        const mutation = mutations[i];
                        if (!mutation || !mutation.addedNodes) continue;
                        for (let j = 0; j < mutation.addedNodes.length; j++) {
                            const node = mutation.addedNodes[j];
                            if (!node) continue;
                            if (node.nodeType !== 1 && node.nodeType !== 3) continue;
                            pendingNodes.add(node);
                        }
                    }
                    if (pendingNodes.size) scheduleProcessing();
                };

                const observer = new MutationObserver((mutations) => {
                    withErrorBoundary('textLinkifyMutation', () => {
                        textLinkifyObserverCallback(mutations);
                    });
                });

                const root = document.body || document.documentElement;
                if (root) {
                    observer.observe(root, { childList: true, subtree: true });
                    pendingNodes.add(root);
                    scheduleProcessing();
                }

                return () => {
                    disposed = true;
                    if (idleId && typeof cancelIdleCallback === 'function') {
                        try {
                            cancelIdleCallback(idleId);
                        } catch (e) {}
                    }
                    idleId = 0;
                    if (rafId) {
                        try {
                            cancelAnimationFrame(rafId);
                        } catch (e) {}
                    }
                    rafId = 0;
                    if (timeoutId) {
                        try {
                            clearTimeout(timeoutId);
                        } catch (e) {}
                    }
                    timeoutId = 0;
                    try {
                        observer.disconnect();
                    } catch (e) {}
                    pendingNodes.clear();
                };
            }

            // é’ˆå¯¹ Discuz! è®ºå›çš„å¸–å­
            function targetDiscuz() {
                if (document.querySelector('meta[name="author"][content*="Discuz!"], meta[name="generator"][content*="Discuz!"]') || document.querySelector('body[id="nv_forum"][class^="pg_"][onkeydown*="27"]') || document.querySelector('body[id="nv_search"][onkeydown*="27"]') || (document.querySelector('a[href*="www.discuz.net"]') && document.querySelector('a[href*="www.discuz.net"]').textContent.indexOf('Discuz!') > -1) || (document.getElementById('ft') && document.getElementById('ft').textContent.indexOf('Discuz!') > -1)) {
                    let atarget = document.getElementById('atarget');
                    if (atarget && atarget.className.indexOf('atarget_1') === -1) { // å¼ºåˆ¶å‹¾é€‰ [æ–°çª—]
                        atarget.click();
                    }
                }
            }


            // é’ˆå¯¹åŠ¨æ€åŠ è½½å†…å®¹ä¸­çš„ a æ ‡ç­¾
            function aObserver(settings) {
                const pageHost = getCurrentHost();
                let scheduled = false;
                let pending = [];
                let rafId = 0;
                let timeoutId = 0;
                function markNodeDepth(node) {
                    try {
                        let d = 0;
                        let cur = node;
                        while (cur && cur.parentElement && d < 64) {
                            d++;
                            cur = cur.parentElement;
                        }
                        node.__newtab_depth = d;
                    } catch (e) {}
                }
                function resolveObserverRoots(selectorsRaw) {
                    const raw = String(selectorsRaw || '').trim();
                    if (!raw) return [document.body || document.documentElement || document];
                    const selectors = raw.split(/[,ï¼Œ]+/g).map((s) => s.trim()).filter(Boolean);
                    const list = [];
                    for (let i = 0; i < selectors.length; i++) {
                        try {
                            const els = document.querySelectorAll(selectors[i]);
                            els.forEach((el) => list.push(el));
                        } catch (e) {}
                    }
                    return list.length ? list : [document.body || document.documentElement || document];
                }

                const flush = () => {
                    scheduled = false;
                    rafId = 0;
                    timeoutId = 0;
                    let nodes = pending;
                    pending = [];
                    if (!nodes.length) return;
                    try {
                        nodes.sort((a, b) => {
                            const da = a && a.nodeType === 1 ? (a.__newtab_depth || 0) : 0;
                            const db = b && b.nodeType === 1 ? (b.__newtab_depth || 0) : 0;
                            return da - db;
                        });
                    } catch (e) {}
                    const limit = getObserverFlushLimit();
                    const max = typeof limit === 'number' && limit > 0 ? limit : nodes.length;
                    const count = nodes.length < max ? nodes.length : max;
                    incMetric('aFlushes', 1);
                    incMetric('aQueued', count);
                    debugLogSampling('aObserverFlush', () => ({ count, limit, queued: nodes.length }), 'DEBUG', 100);
                    for (let i = 0; i < count; i++) {
                        const node = nodes[i];
                        if (!node || node.nodeType !== 1) continue;
                        const anchors = getAnchorsUnder(node);
                        for (let j = 0; j < anchors.length; j++) applyAnchorRules(anchors[j], settings, pageHost);
                    }
                    updateDebugMetricsUI();
                    if (nodes.length > count) {
                        for (let i = count; i < nodes.length; i++) {
                            const node = nodes[i];
                            if (!node || node.nodeType !== 1) continue;
                            pending.push(node);
                        }
                        scheduleFlush();
                    }
                };

                const scheduleFlush = () => {
                    if (scheduled) return;
                    scheduled = true;
                    const id = scheduleIdleRafTimeout('aObserverFlush', flush, 200, true, 16);
                    if (typeof id === 'number') timeoutId = id;
                };

                const callback = (mutationsList) => {
                    for (let i = 0; i < mutationsList.length; i++) {
                        const mutation = mutationsList[i];
                        if (!mutation || !mutation.addedNodes) continue;
                        for (let j = 0; j < mutation.addedNodes.length; j++) {
                            const node = mutation.addedNodes[j];
                            if (!node || node.nodeType !== 1) continue;
                            if (pending.length >= getObserverPendingLimit()) continue;
                            markNodeDepth(node);
                            pending.push(node);
                        }
                    }
                    if (pending.length) scheduleFlush();
                };

                const observerRoots = resolveObserverRoots(settings && settings.observerWhitelistSelectors);
                const observers = [];
                for (let i = 0; i < observerRoots.length; i++) {
                    const root = observerRoots[i];
                    try {
                        const obs = new MutationObserver(callback);
                        obs.observe(root, { childList: true, subtree: true });
                        observers.push(obs);
                    } catch (e) {}
                }
                return () => {
                    try {
                        for (let i = 0; i < observers.length; i++) observers[i].disconnect();
                    } catch (e) {}
                    if (rafId) {
                        try {
                            cancelAnimationFrame(rafId);
                        } catch (e) {}
                    }
                    rafId = 0;
                    if (timeoutId) {
                        try {
                            clearTimeout(timeoutId);
                        } catch (e) {}
                    }
                    timeoutId = 0;
                    pending = [];
                    scheduled = false;
                };
            }
        })();
